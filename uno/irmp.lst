   1               		.file	"irmp.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 129               	irmp_store_bit:
 130               		.stabd	46,0,0
   1:irmp.c        **** /*-------------------------------------------------------------------------------------------------
   2:irmp.c        ****  * irmp.c - infrared multi-protocol decoder, supports several remote control protocols
   3:irmp.c        ****  *
   4:irmp.c        ****  * Copyright (c) 2009-2019 Frank Meyer - frank(at)fli4l.de
   5:irmp.c        ****  *
   6:irmp.c        ****  * Supported AVR mikrocontrollers:
   7:irmp.c        ****  *
   8:irmp.c        ****  * ATtiny87,  ATtiny167
   9:irmp.c        ****  * ATtiny45,  ATtiny85
  10:irmp.c        ****  * ATtiny44,  ATtiny84
  11:irmp.c        ****  * ATmega8,   ATmega16,  ATmega32
  12:irmp.c        ****  * ATmega162
  13:irmp.c        ****  * ATmega164, ATmega324, ATmega644,  ATmega644P, ATmega1284, ATmega1284P
  14:irmp.c        ****  * ATmega88,  ATmega88P, ATmega168,  ATmega168P, ATmega328P
  15:irmp.c        ****  *
  16:irmp.c        ****  * This program is free software; you can redistribute it and/or modify
  17:irmp.c        ****  * it under the terms of the GNU General Public License as published by
  18:irmp.c        ****  * the Free Software Foundation; either version 2 of the License, or
  19:irmp.c        ****  * (at your option) any later version.
  20:irmp.c        ****  *-------------------------------------------------------------------------------------------------
  21:irmp.c        ****  */
  22:irmp.c        **** 
  23:irmp.c        **** #include "irmp.h"
  24:irmp.c        **** 
  25:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_PROTOCOL == 1 || IRMP_SUPPORT_NOKIA_PROTOCOL == 1 || IRMP_SUPPORT_IR60_PRO
  26:irmp.c        **** #  define IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL  1
  27:irmp.c        **** #else
  28:irmp.c        **** #  define IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL  0
  29:irmp.c        **** #endif
  30:irmp.c        **** 
  31:irmp.c        **** #if IRMP_SUPPORT_SIEMENS_PROTOCOL == 1 || IRMP_SUPPORT_RUWIDO_PROTOCOL == 1
  32:irmp.c        **** #  define IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL   1
  33:irmp.c        **** #else
  34:irmp.c        **** #  define IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL   0
  35:irmp.c        **** #endif
  36:irmp.c        **** 
  37:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 ||                   \
  38:irmp.c        ****     IRMP_SUPPORT_RCII_PROTOCOL == 1 ||                  \
  39:irmp.c        ****     IRMP_SUPPORT_S100_PROTOCOL == 1 ||                  \
  40:irmp.c        ****     IRMP_SUPPORT_RC6_PROTOCOL == 1 ||                   \
  41:irmp.c        ****     IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1 ||    \
  42:irmp.c        ****     IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1 ||     \
  43:irmp.c        ****     IRMP_SUPPORT_IR60_PROTOCOL == 1 ||                  \
  44:irmp.c        ****     IRMP_SUPPORT_A1TVBOX_PROTOCOL == 1 ||               \
  45:irmp.c        ****     IRMP_SUPPORT_MERLIN_PROTOCOL == 1 ||                \
  46:irmp.c        ****     IRMP_SUPPORT_ORTEK_PROTOCOL == 1
  47:irmp.c        **** #  define IRMP_SUPPORT_MANCHESTER                   1
  48:irmp.c        **** #else
  49:irmp.c        **** #  define IRMP_SUPPORT_MANCHESTER                   0
  50:irmp.c        **** #endif
  51:irmp.c        **** 
  52:irmp.c        **** #if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
  53:irmp.c        **** #  define IRMP_SUPPORT_SERIAL                       1
  54:irmp.c        **** #else
  55:irmp.c        **** #  define IRMP_SUPPORT_SERIAL                       0
  56:irmp.c        **** #endif
  57:irmp.c        **** 
  58:irmp.c        **** #define IRMP_KEY_REPETITION_LEN                 (uint_fast16_t)(F_INTERRUPTS * 150.0e-3 + 0.5)     
  59:irmp.c        **** 
  60:irmp.c        **** #define MIN_TOLERANCE_00                        1.0                           // -0%
  61:irmp.c        **** #define MAX_TOLERANCE_00                        1.0                           // +0%
  62:irmp.c        **** 
  63:irmp.c        **** #define MIN_TOLERANCE_02                        0.98                          // -2%
  64:irmp.c        **** #define MAX_TOLERANCE_02                        1.02                          // +2%
  65:irmp.c        **** 
  66:irmp.c        **** #define MIN_TOLERANCE_03                        0.97                          // -3%
  67:irmp.c        **** #define MAX_TOLERANCE_03                        1.03                          // +3%
  68:irmp.c        **** 
  69:irmp.c        **** #define MIN_TOLERANCE_05                        0.95                          // -5%
  70:irmp.c        **** #define MAX_TOLERANCE_05                        1.05                          // +5%
  71:irmp.c        **** 
  72:irmp.c        **** #define MIN_TOLERANCE_10                        0.9                           // -10%
  73:irmp.c        **** #define MAX_TOLERANCE_10                        1.1                           // +10%
  74:irmp.c        **** 
  75:irmp.c        **** #define MIN_TOLERANCE_15                        0.85                          // -15%
  76:irmp.c        **** #define MAX_TOLERANCE_15                        1.15                          // +15%
  77:irmp.c        **** 
  78:irmp.c        **** #define MIN_TOLERANCE_20                        0.8                           // -20%
  79:irmp.c        **** #define MAX_TOLERANCE_20                        1.2                           // +20%
  80:irmp.c        **** 
  81:irmp.c        **** #define MIN_TOLERANCE_30                        0.7                           // -30%
  82:irmp.c        **** #define MAX_TOLERANCE_30                        1.3                           // +30%
  83:irmp.c        **** 
  84:irmp.c        **** #define MIN_TOLERANCE_40                        0.6                           // -40%
  85:irmp.c        **** #define MAX_TOLERANCE_40                        1.4                           // +40%
  86:irmp.c        **** 
  87:irmp.c        **** #define MIN_TOLERANCE_50                        0.5                           // -50%
  88:irmp.c        **** #define MAX_TOLERANCE_50                        1.5                           // +50%
  89:irmp.c        **** 
  90:irmp.c        **** #define MIN_TOLERANCE_60                        0.4                           // -60%
  91:irmp.c        **** #define MAX_TOLERANCE_60                        1.6                           // +60%
  92:irmp.c        **** 
  93:irmp.c        **** #define MIN_TOLERANCE_70                        0.3                           // -70%
  94:irmp.c        **** #define MAX_TOLERANCE_70                        1.7                           // +70%
  95:irmp.c        **** 
  96:irmp.c        **** #define SIRCS_START_BIT_PULSE_LEN_MIN           ((uint_fast8_t)(F_INTERRUPTS * SIRCS_START_BIT_PULS
  97:irmp.c        **** #define SIRCS_START_BIT_PULSE_LEN_MAX           ((uint_fast8_t)(F_INTERRUPTS * SIRCS_START_BIT_PULS
  98:irmp.c        **** #define SIRCS_START_BIT_PAUSE_LEN_MIN           ((uint_fast8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUS
  99:irmp.c        **** #if IRMP_SUPPORT_NETBOX_PROTOCOL                // only 5% to avoid conflict with NETBOX:
 100:irmp.c        **** #  define SIRCS_START_BIT_PAUSE_LEN_MAX         ((uint_fast8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUS
 101:irmp.c        **** #else                                           // only 5% + 1 to avoid conflict with RC6:
 102:irmp.c        **** #  define SIRCS_START_BIT_PAUSE_LEN_MAX         ((uint_fast8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUS
 103:irmp.c        **** #endif
 104:irmp.c        **** #define SIRCS_1_PULSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * SIRCS_1_PULSE_TIME *
 105:irmp.c        **** #define SIRCS_1_PULSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * SIRCS_1_PULSE_TIME *
 106:irmp.c        **** #define SIRCS_0_PULSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * SIRCS_0_PULSE_TIME *
 107:irmp.c        **** #define SIRCS_0_PULSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * SIRCS_0_PULSE_TIME *
 108:irmp.c        **** #define SIRCS_PAUSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * SIRCS_PAUSE_TIME * M
 109:irmp.c        **** #define SIRCS_PAUSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * SIRCS_PAUSE_TIME * M
 110:irmp.c        **** 
 111:irmp.c        **** #define NEC_START_BIT_PULSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * NEC_START_BIT_PULSE_
 112:irmp.c        **** #define NEC_START_BIT_PULSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * NEC_START_BIT_PULSE_
 113:irmp.c        **** #define NEC_START_BIT_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * NEC_START_BIT_PAUSE_
 114:irmp.c        **** #define NEC_START_BIT_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * NEC_START_BIT_PAUSE_
 115:irmp.c        **** #define NEC_REPEAT_START_BIT_PAUSE_LEN_MIN      ((uint_fast8_t)(F_INTERRUPTS * NEC_REPEAT_START_BIT
 116:irmp.c        **** #define NEC_REPEAT_START_BIT_PAUSE_LEN_MAX      ((uint_fast8_t)(F_INTERRUPTS * NEC_REPEAT_START_BIT
 117:irmp.c        **** #define NEC_PULSE_LEN_MIN                       ((uint_fast8_t)(F_INTERRUPTS * NEC_PULSE_TIME * MIN
 118:irmp.c        **** #define NEC_PULSE_LEN_MAX                       ((uint_fast8_t)(F_INTERRUPTS * NEC_PULSE_TIME * MAX
 119:irmp.c        **** #define NEC_1_PAUSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * NEC_1_PAUSE_TIME * M
 120:irmp.c        **** #define NEC_1_PAUSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * NEC_1_PAUSE_TIME * M
 121:irmp.c        **** #define NEC_0_PAUSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * NEC_0_PAUSE_TIME * M
 122:irmp.c        **** #define NEC_0_PAUSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * NEC_0_PAUSE_TIME * M
 123:irmp.c        **** // autodetect nec repetition frame within 50 msec:
 124:irmp.c        **** // NEC seems to send the first repetition frame after 40ms, further repetition frames after 100 ms
 125:irmp.c        **** #if 0
 126:irmp.c        **** #define NEC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint_fast16_t)(F_INTERRUPTS * NEC_FRAME_REPEAT_PAU
 127:irmp.c        **** #else
 128:irmp.c        **** #define NEC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint_fast16_t)(F_INTERRUPTS * 100.0e-3 * MAX_TOLER
 129:irmp.c        **** #endif
 130:irmp.c        **** 
 131:irmp.c        **** #define SAMSUNG_START_BIT_PULSE_LEN_MIN         ((uint_fast8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PU
 132:irmp.c        **** #define SAMSUNG_START_BIT_PULSE_LEN_MAX         ((uint_fast8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PU
 133:irmp.c        **** #define SAMSUNG_START_BIT_PAUSE_LEN_MIN         ((uint_fast8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PA
 134:irmp.c        **** #define SAMSUNG_START_BIT_PAUSE_LEN_MAX         ((uint_fast8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PA
 135:irmp.c        **** #define SAMSUNG_PULSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * SAMSUNG_PULSE_TIME *
 136:irmp.c        **** #define SAMSUNG_PULSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * SAMSUNG_PULSE_TIME *
 137:irmp.c        **** #define SAMSUNG_1_PAUSE_LEN_MIN                 ((uint_fast8_t)(F_INTERRUPTS * SAMSUNG_1_PAUSE_TIME
 138:irmp.c        **** #define SAMSUNG_1_PAUSE_LEN_MAX                 ((uint_fast8_t)(F_INTERRUPTS * SAMSUNG_1_PAUSE_TIME
 139:irmp.c        **** #define SAMSUNG_0_PAUSE_LEN_MIN                 ((uint_fast8_t)(F_INTERRUPTS * SAMSUNG_0_PAUSE_TIME
 140:irmp.c        **** #define SAMSUNG_0_PAUSE_LEN_MAX                 ((uint_fast8_t)(F_INTERRUPTS * SAMSUNG_0_PAUSE_TIME
 141:irmp.c        **** 
 142:irmp.c        **** #define SAMSUNGAH_START_BIT_PULSE_LEN_MIN       ((uint_fast8_t)(F_INTERRUPTS * SAMSUNGAH_START_BIT_
 143:irmp.c        **** #define SAMSUNGAH_START_BIT_PULSE_LEN_MAX       ((uint_fast8_t)(F_INTERRUPTS * SAMSUNGAH_START_BIT_
 144:irmp.c        **** #define SAMSUNGAH_START_BIT_PAUSE_LEN_MIN       ((uint_fast8_t)(F_INTERRUPTS * SAMSUNGAH_START_BIT_
 145:irmp.c        **** #define SAMSUNGAH_START_BIT_PAUSE_LEN_MAX       ((uint_fast8_t)(F_INTERRUPTS * SAMSUNGAH_START_BIT_
 146:irmp.c        **** #define SAMSUNGAH_PULSE_LEN_MIN                 ((uint_fast8_t)(F_INTERRUPTS * SAMSUNGAH_PULSE_TIME
 147:irmp.c        **** #define SAMSUNGAH_PULSE_LEN_MAX                 ((uint_fast8_t)(F_INTERRUPTS * SAMSUNGAH_PULSE_TIME
 148:irmp.c        **** #define SAMSUNGAH_1_PAUSE_LEN_MIN               ((uint_fast8_t)(F_INTERRUPTS * SAMSUNGAH_1_PAUSE_TI
 149:irmp.c        **** #define SAMSUNGAH_1_PAUSE_LEN_MAX               ((uint_fast8_t)(F_INTERRUPTS * SAMSUNGAH_1_PAUSE_TI
 150:irmp.c        **** #define SAMSUNGAH_0_PAUSE_LEN_MIN               ((uint_fast8_t)(F_INTERRUPTS * SAMSUNGAH_0_PAUSE_TI
 151:irmp.c        **** #define SAMSUNGAH_0_PAUSE_LEN_MAX               ((uint_fast8_t)(F_INTERRUPTS * SAMSUNGAH_0_PAUSE_TI
 152:irmp.c        **** 
 153:irmp.c        **** #define MATSUSHITA_START_BIT_PULSE_LEN_MIN      ((uint_fast8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT
 154:irmp.c        **** #define MATSUSHITA_START_BIT_PULSE_LEN_MAX      ((uint_fast8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT
 155:irmp.c        **** #define MATSUSHITA_START_BIT_PAUSE_LEN_MIN      ((uint_fast8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT
 156:irmp.c        **** #define MATSUSHITA_START_BIT_PAUSE_LEN_MAX      ((uint_fast8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT
 157:irmp.c        **** #define MATSUSHITA_PULSE_LEN_MIN                ((uint_fast8_t)(F_INTERRUPTS * MATSUSHITA_PULSE_TIM
 158:irmp.c        **** #define MATSUSHITA_PULSE_LEN_MAX                ((uint_fast8_t)(F_INTERRUPTS * MATSUSHITA_PULSE_TIM
 159:irmp.c        **** #define MATSUSHITA_1_PAUSE_LEN_MIN              ((uint_fast8_t)(F_INTERRUPTS * MATSUSHITA_1_PAUSE_T
 160:irmp.c        **** #define MATSUSHITA_1_PAUSE_LEN_MAX              ((uint_fast8_t)(F_INTERRUPTS * MATSUSHITA_1_PAUSE_T
 161:irmp.c        **** #define MATSUSHITA_0_PAUSE_LEN_MIN              ((uint_fast8_t)(F_INTERRUPTS * MATSUSHITA_0_PAUSE_T
 162:irmp.c        **** #define MATSUSHITA_0_PAUSE_LEN_MAX              ((uint_fast8_t)(F_INTERRUPTS * MATSUSHITA_0_PAUSE_T
 163:irmp.c        **** 
 164:irmp.c        **** #define KASEIKYO_START_BIT_PULSE_LEN_MIN        ((uint_fast8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_P
 165:irmp.c        **** #define KASEIKYO_START_BIT_PULSE_LEN_MAX        ((uint_fast8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_P
 166:irmp.c        **** #define KASEIKYO_START_BIT_PAUSE_LEN_MIN        ((uint_fast8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_P
 167:irmp.c        **** #define KASEIKYO_START_BIT_PAUSE_LEN_MAX        ((uint_fast8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_P
 168:irmp.c        **** #define KASEIKYO_PULSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * KASEIKYO_PULSE_TIME 
 169:irmp.c        **** #define KASEIKYO_PULSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * KASEIKYO_PULSE_TIME 
 170:irmp.c        **** #define KASEIKYO_1_PAUSE_LEN_MIN                ((uint_fast8_t)(F_INTERRUPTS * KASEIKYO_1_PAUSE_TIM
 171:irmp.c        **** #define KASEIKYO_1_PAUSE_LEN_MAX                ((uint_fast8_t)(F_INTERRUPTS * KASEIKYO_1_PAUSE_TIM
 172:irmp.c        **** #define KASEIKYO_0_PAUSE_LEN_MIN                ((uint_fast8_t)(F_INTERRUPTS * KASEIKYO_0_PAUSE_TIM
 173:irmp.c        **** #define KASEIKYO_0_PAUSE_LEN_MAX                ((uint_fast8_t)(F_INTERRUPTS * KASEIKYO_0_PAUSE_TIM
 174:irmp.c        **** 
 175:irmp.c        **** #define MITSU_HEAVY_START_BIT_PULSE_LEN_MIN     ((uint_fast8_t)(F_INTERRUPTS * MITSU_HEAVY_START_BI
 176:irmp.c        **** #define MITSU_HEAVY_START_BIT_PULSE_LEN_MAX     ((uint_fast8_t)(F_INTERRUPTS * MITSU_HEAVY_START_BI
 177:irmp.c        **** #define MITSU_HEAVY_START_BIT_PAUSE_LEN_MIN     ((uint_fast8_t)(F_INTERRUPTS * MITSU_HEAVY_START_BI
 178:irmp.c        **** #define MITSU_HEAVY_START_BIT_PAUSE_LEN_MAX     ((uint_fast8_t)(F_INTERRUPTS * MITSU_HEAVY_START_BI
 179:irmp.c        **** #define MITSU_HEAVY_PULSE_LEN_MIN               ((uint_fast8_t)(F_INTERRUPTS * MITSU_HEAVY_PULSE_TI
 180:irmp.c        **** #define MITSU_HEAVY_PULSE_LEN_MAX               ((uint_fast8_t)(F_INTERRUPTS * MITSU_HEAVY_PULSE_TI
 181:irmp.c        **** #define MITSU_HEAVY_1_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * MITSU_HEAVY_1_PAUSE_
 182:irmp.c        **** #define MITSU_HEAVY_1_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * MITSU_HEAVY_1_PAUSE_
 183:irmp.c        **** #define MITSU_HEAVY_0_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * MITSU_HEAVY_0_PAUSE_
 184:irmp.c        **** #define MITSU_HEAVY_0_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * MITSU_HEAVY_0_PAUSE_
 185:irmp.c        **** 
 186:irmp.c        **** #define VINCENT_START_BIT_PULSE_LEN_MIN         ((uint_fast8_t)(F_INTERRUPTS * VINCENT_START_BIT_PU
 187:irmp.c        **** #define VINCENT_START_BIT_PULSE_LEN_MAX         ((uint_fast8_t)(F_INTERRUPTS * VINCENT_START_BIT_PU
 188:irmp.c        **** #define VINCENT_START_BIT_PAUSE_LEN_MIN         ((uint_fast8_t)(F_INTERRUPTS * VINCENT_START_BIT_PA
 189:irmp.c        **** #define VINCENT_START_BIT_PAUSE_LEN_MAX         ((uint_fast8_t)(F_INTERRUPTS * VINCENT_START_BIT_PA
 190:irmp.c        **** #define VINCENT_PULSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * VINCENT_PULSE_TIME *
 191:irmp.c        **** #define VINCENT_PULSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * VINCENT_PULSE_TIME *
 192:irmp.c        **** #define VINCENT_1_PAUSE_LEN_MIN                 ((uint_fast8_t)(F_INTERRUPTS * VINCENT_1_PAUSE_TIME
 193:irmp.c        **** #define VINCENT_1_PAUSE_LEN_MAX                 ((uint_fast8_t)(F_INTERRUPTS * VINCENT_1_PAUSE_TIME
 194:irmp.c        **** #define VINCENT_0_PAUSE_LEN_MIN                 ((uint_fast8_t)(F_INTERRUPTS * VINCENT_0_PAUSE_TIME
 195:irmp.c        **** #define VINCENT_0_PAUSE_LEN_MAX                 ((uint_fast8_t)(F_INTERRUPTS * VINCENT_0_PAUSE_TIME
 196:irmp.c        **** 
 197:irmp.c        **** #define PANASONIC_START_BIT_PULSE_LEN_MIN       ((uint_fast8_t)(F_INTERRUPTS * PANASONIC_START_BIT_
 198:irmp.c        **** #define PANASONIC_START_BIT_PULSE_LEN_MAX       ((uint_fast8_t)(F_INTERRUPTS * PANASONIC_START_BIT_
 199:irmp.c        **** #define PANASONIC_START_BIT_PAUSE_LEN_MIN       ((uint_fast8_t)(F_INTERRUPTS * PANASONIC_START_BIT_
 200:irmp.c        **** #define PANASONIC_START_BIT_PAUSE_LEN_MAX       ((uint_fast8_t)(F_INTERRUPTS * PANASONIC_START_BIT_
 201:irmp.c        **** #define PANASONIC_PULSE_LEN_MIN                 ((uint_fast8_t)(F_INTERRUPTS * PANASONIC_PULSE_TIME
 202:irmp.c        **** #define PANASONIC_PULSE_LEN_MAX                 ((uint_fast8_t)(F_INTERRUPTS * PANASONIC_PULSE_TIME
 203:irmp.c        **** #define PANASONIC_1_PAUSE_LEN_MIN               ((uint_fast8_t)(F_INTERRUPTS * PANASONIC_1_PAUSE_TI
 204:irmp.c        **** #define PANASONIC_1_PAUSE_LEN_MAX               ((uint_fast8_t)(F_INTERRUPTS * PANASONIC_1_PAUSE_TI
 205:irmp.c        **** #define PANASONIC_0_PAUSE_LEN_MIN               ((uint_fast8_t)(F_INTERRUPTS * PANASONIC_0_PAUSE_TI
 206:irmp.c        **** #define PANASONIC_0_PAUSE_LEN_MAX               ((uint_fast8_t)(F_INTERRUPTS * PANASONIC_0_PAUSE_TI
 207:irmp.c        **** 
 208:irmp.c        **** #define RECS80_START_BIT_PULSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * RECS80_START_BIT_PUL
 209:irmp.c        **** #define RECS80_START_BIT_PULSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * RECS80_START_BIT_PUL
 210:irmp.c        **** #define RECS80_START_BIT_PAUSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * RECS80_START_BIT_PAU
 211:irmp.c        **** #define RECS80_START_BIT_PAUSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * RECS80_START_BIT_PAU
 212:irmp.c        **** #define RECS80_PULSE_LEN_MIN                    ((uint_fast8_t)(F_INTERRUPTS * RECS80_PULSE_TIME * 
 213:irmp.c        **** #define RECS80_PULSE_LEN_MAX                    ((uint_fast8_t)(F_INTERRUPTS * RECS80_PULSE_TIME * 
 214:irmp.c        **** #define RECS80_1_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * RECS80_1_PAUSE_TIME 
 215:irmp.c        **** #define RECS80_1_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * RECS80_1_PAUSE_TIME 
 216:irmp.c        **** #define RECS80_0_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * RECS80_0_PAUSE_TIME 
 217:irmp.c        **** #define RECS80_0_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * RECS80_0_PAUSE_TIME 
 218:irmp.c        **** 
 219:irmp.c        **** #if IRMP_SUPPORT_BOSE_PROTOCOL == 1 // BOSE conflicts with RC5, so keep tolerance for RC5 minimal h
 220:irmp.c        **** #define RC5_START_BIT_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * RC5_BIT_TIME * MIN_T
 221:irmp.c        **** #define RC5_START_BIT_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * RC5_BIT_TIME * MAX_T
 222:irmp.c        **** #else
 223:irmp.c        **** #define RC5_START_BIT_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * RC5_BIT_TIME * MIN_T
 224:irmp.c        **** #define RC5_START_BIT_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * RC5_BIT_TIME * MAX_T
 225:irmp.c        **** #endif
 226:irmp.c        **** 
 227:irmp.c        **** #define RC5_BIT_LEN_MIN                         ((uint_fast8_t)(F_INTERRUPTS * RC5_BIT_TIME * MIN_T
 228:irmp.c        **** #define RC5_BIT_LEN_MAX                         ((uint_fast8_t)(F_INTERRUPTS * RC5_BIT_TIME * MAX_T
 229:irmp.c        **** 
 230:irmp.c        **** #define RCII_START_BIT_PULSE_LEN_MIN            ((uint_fast8_t)(F_INTERRUPTS * RCII_START_BIT_PULSE
 231:irmp.c        **** #define RCII_START_BIT_PULSE_LEN_MAX            ((uint_fast8_t)(F_INTERRUPTS * RCII_START_BIT_PULSE
 232:irmp.c        **** #define RCII_START_BIT_PAUSE_LEN_MIN            ((uint_fast8_t)(F_INTERRUPTS * RCII_START_BIT_PAUSE
 233:irmp.c        **** #define RCII_START_BIT_PAUSE_LEN_MAX            ((uint_fast8_t)(F_INTERRUPTS * RCII_START_BIT_PAUSE
 234:irmp.c        **** #define RCII_START_BIT2_PULSE_LEN_MIN           ((uint_fast8_t)(F_INTERRUPTS * RCII_START_BIT2_PULS
 235:irmp.c        **** #define RCII_START_BIT2_PULSE_LEN_MAX           ((uint_fast8_t)(F_INTERRUPTS * RCII_START_BIT2_PULS
 236:irmp.c        **** 
 237:irmp.c        **** #define RCII_BIT_LEN_MIN                        ((uint_fast8_t)(F_INTERRUPTS * RCII_BIT_TIME * MIN_
 238:irmp.c        **** #define RCII_BIT_LEN                            ((uint_fast8_t)(F_INTERRUPTS * RCII_BIT_TIME))
 239:irmp.c        **** #define RCII_BIT_LEN_MAX                        ((uint_fast8_t)(F_INTERRUPTS * RCII_BIT_TIME * MAX_
 240:irmp.c        **** 
 241:irmp.c        **** #if IRMP_SUPPORT_BOSE_PROTOCOL == 1 // BOSE conflicts with S100, so keep tolerance for S100 minimal
 242:irmp.c        **** #define S100_START_BIT_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * S100_BIT_TIME * MIN
 243:irmp.c        **** #define S100_START_BIT_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * S100_BIT_TIME * MAX
 244:irmp.c        **** #else
 245:irmp.c        **** #define S100_START_BIT_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * S100_BIT_TIME * MIN
 246:irmp.c        **** #define S100_START_BIT_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * S100_BIT_TIME * MAX
 247:irmp.c        **** #endif
 248:irmp.c        **** 
 249:irmp.c        **** #define S100_BIT_LEN_MIN                         ((uint_fast8_t)(F_INTERRUPTS * S100_BIT_TIME * MIN
 250:irmp.c        **** #define S100_BIT_LEN_MAX                         ((uint_fast8_t)(F_INTERRUPTS * S100_BIT_TIME * MAX
 251:irmp.c        **** 
 252:irmp.c        **** #define DENON_PULSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * DENON_PULSE_TIME * M
 253:irmp.c        **** #define DENON_PULSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * DENON_PULSE_TIME * M
 254:irmp.c        **** #define DENON_1_PAUSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * DENON_1_PAUSE_TIME *
 255:irmp.c        **** #define DENON_1_PAUSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * DENON_1_PAUSE_TIME *
 256:irmp.c        **** // RUWIDO (see t-home-mediareceiver-15kHz.txt) conflicts here with DENON
 257:irmp.c        **** #define DENON_0_PAUSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * DENON_0_PAUSE_TIME *
 258:irmp.c        **** #define DENON_0_PAUSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * DENON_0_PAUSE_TIME *
 259:irmp.c        **** #define DENON_AUTO_REPETITION_PAUSE_LEN         ((uint_fast16_t)(F_INTERRUPTS * DENON_AUTO_REPETITI
 260:irmp.c        **** 
 261:irmp.c        **** #define THOMSON_PULSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * THOMSON_PULSE_TIME *
 262:irmp.c        **** #define THOMSON_PULSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * THOMSON_PULSE_TIME *
 263:irmp.c        **** #define THOMSON_1_PAUSE_LEN_MIN                 ((uint_fast8_t)(F_INTERRUPTS * THOMSON_1_PAUSE_TIME
 264:irmp.c        **** #define THOMSON_1_PAUSE_LEN_MAX                 ((uint_fast8_t)(F_INTERRUPTS * THOMSON_1_PAUSE_TIME
 265:irmp.c        **** #define THOMSON_0_PAUSE_LEN_MIN                 ((uint_fast8_t)(F_INTERRUPTS * THOMSON_0_PAUSE_TIME
 266:irmp.c        **** #define THOMSON_0_PAUSE_LEN_MAX                 ((uint_fast8_t)(F_INTERRUPTS * THOMSON_0_PAUSE_TIME
 267:irmp.c        **** 
 268:irmp.c        **** #define RC6_START_BIT_PULSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * RC6_START_BIT_PULSE_
 269:irmp.c        **** #define RC6_START_BIT_PULSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * RC6_START_BIT_PULSE_
 270:irmp.c        **** #define RC6_START_BIT_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * RC6_START_BIT_PAUSE_
 271:irmp.c        **** #define RC6_START_BIT_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * RC6_START_BIT_PAUSE_
 272:irmp.c        **** #define RC6_TOGGLE_BIT_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * RC6_TOGGLE_BIT_TIME 
 273:irmp.c        **** #define RC6_TOGGLE_BIT_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * RC6_TOGGLE_BIT_TIME 
 274:irmp.c        **** #define RC6_BIT_PULSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * RC6_BIT_TIME * MIN_T
 275:irmp.c        **** #define RC6_BIT_PULSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * RC6_BIT_TIME * MAX_T
 276:irmp.c        **** #define RC6_BIT_PAUSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * RC6_BIT_TIME * MIN_T
 277:irmp.c        **** #define RC6_BIT_PAUSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * RC6_BIT_TIME * MAX_T
 278:irmp.c        **** 
 279:irmp.c        **** #define RECS80EXT_START_BIT_PULSE_LEN_MIN       ((uint_fast8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_
 280:irmp.c        **** #define RECS80EXT_START_BIT_PULSE_LEN_MAX       ((uint_fast8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_
 281:irmp.c        **** #define RECS80EXT_START_BIT_PAUSE_LEN_MIN       ((uint_fast8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_
 282:irmp.c        **** #define RECS80EXT_START_BIT_PAUSE_LEN_MAX       ((uint_fast8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_
 283:irmp.c        **** #define RECS80EXT_PULSE_LEN_MIN                 ((uint_fast8_t)(F_INTERRUPTS * RECS80EXT_PULSE_TIME
 284:irmp.c        **** #define RECS80EXT_PULSE_LEN_MAX                 ((uint_fast8_t)(F_INTERRUPTS * RECS80EXT_PULSE_TIME
 285:irmp.c        **** #define RECS80EXT_1_PAUSE_LEN_MIN               ((uint_fast8_t)(F_INTERRUPTS * RECS80EXT_1_PAUSE_TI
 286:irmp.c        **** #define RECS80EXT_1_PAUSE_LEN_MAX               ((uint_fast8_t)(F_INTERRUPTS * RECS80EXT_1_PAUSE_TI
 287:irmp.c        **** #define RECS80EXT_0_PAUSE_LEN_MIN               ((uint_fast8_t)(F_INTERRUPTS * RECS80EXT_0_PAUSE_TI
 288:irmp.c        **** #define RECS80EXT_0_PAUSE_LEN_MAX               ((uint_fast8_t)(F_INTERRUPTS * RECS80EXT_0_PAUSE_TI
 289:irmp.c        **** 
 290:irmp.c        **** #define NUBERT_START_BIT_PULSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * NUBERT_START_BIT_PUL
 291:irmp.c        **** #define NUBERT_START_BIT_PULSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * NUBERT_START_BIT_PUL
 292:irmp.c        **** #define NUBERT_START_BIT_PAUSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * NUBERT_START_BIT_PAU
 293:irmp.c        **** #define NUBERT_START_BIT_PAUSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * NUBERT_START_BIT_PAU
 294:irmp.c        **** #define NUBERT_1_PULSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * NUBERT_1_PULSE_TIME 
 295:irmp.c        **** #define NUBERT_1_PULSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * NUBERT_1_PULSE_TIME 
 296:irmp.c        **** #define NUBERT_1_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * NUBERT_1_PAUSE_TIME 
 297:irmp.c        **** #define NUBERT_1_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * NUBERT_1_PAUSE_TIME 
 298:irmp.c        **** #define NUBERT_0_PULSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * NUBERT_0_PULSE_TIME 
 299:irmp.c        **** #define NUBERT_0_PULSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * NUBERT_0_PULSE_TIME 
 300:irmp.c        **** #define NUBERT_0_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * NUBERT_0_PAUSE_TIME 
 301:irmp.c        **** #define NUBERT_0_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * NUBERT_0_PAUSE_TIME 
 302:irmp.c        **** 
 303:irmp.c        **** #define FAN_START_BIT_PULSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * FAN_START_BIT_PULSE_
 304:irmp.c        **** #define FAN_START_BIT_PULSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * FAN_START_BIT_PULSE_
 305:irmp.c        **** #define FAN_START_BIT_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * FAN_START_BIT_PAUSE_
 306:irmp.c        **** #define FAN_START_BIT_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * FAN_START_BIT_PAUSE_
 307:irmp.c        **** #define FAN_1_PULSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * FAN_1_PULSE_TIME * M
 308:irmp.c        **** #define FAN_1_PULSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * FAN_1_PULSE_TIME * M
 309:irmp.c        **** #define FAN_1_PAUSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * FAN_1_PAUSE_TIME * M
 310:irmp.c        **** #define FAN_1_PAUSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * FAN_1_PAUSE_TIME * M
 311:irmp.c        **** #define FAN_0_PULSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * FAN_0_PULSE_TIME * M
 312:irmp.c        **** #define FAN_0_PULSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * FAN_0_PULSE_TIME * M
 313:irmp.c        **** #define FAN_0_PAUSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * FAN_0_PAUSE_TIME * M
 314:irmp.c        **** #define FAN_0_PAUSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * FAN_0_PAUSE_TIME * M
 315:irmp.c        **** 
 316:irmp.c        **** #define SPEAKER_START_BIT_PULSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_START_BIT_P
 317:irmp.c        **** #define SPEAKER_START_BIT_PULSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_START_BIT_P
 318:irmp.c        **** #define SPEAKER_START_BIT_PAUSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_START_BIT_P
 319:irmp.c        **** #define SPEAKER_START_BIT_PAUSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_START_BIT_P
 320:irmp.c        **** #define SPEAKER_1_PULSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_1_PULSE_TIM
 321:irmp.c        **** #define SPEAKER_1_PULSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_1_PULSE_TIM
 322:irmp.c        **** #define SPEAKER_1_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_1_PAUSE_TIM
 323:irmp.c        **** #define SPEAKER_1_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_1_PAUSE_TIM
 324:irmp.c        **** #define SPEAKER_0_PULSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_0_PULSE_TIM
 325:irmp.c        **** #define SPEAKER_0_PULSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_0_PULSE_TIM
 326:irmp.c        **** #define SPEAKER_0_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_0_PAUSE_TIM
 327:irmp.c        **** #define SPEAKER_0_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * SPEAKER_0_PAUSE_TIM
 328:irmp.c        **** 
 329:irmp.c        **** #define BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 330:irmp.c        **** #define BANG_OLUFSEN_START_BIT1_PULSE_LEN_MAX   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 331:irmp.c        **** #define BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 332:irmp.c        **** #define BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MAX   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 333:irmp.c        **** #define BANG_OLUFSEN_START_BIT2_PULSE_LEN_MIN   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 334:irmp.c        **** #define BANG_OLUFSEN_START_BIT2_PULSE_LEN_MAX   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 335:irmp.c        **** #define BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MIN   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 336:irmp.c        **** #define BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MAX   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 337:irmp.c        **** #define BANG_OLUFSEN_START_BIT3_PULSE_LEN_MIN   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 338:irmp.c        **** #define BANG_OLUFSEN_START_BIT3_PULSE_LEN_MAX   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 339:irmp.c        **** #define BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 340:irmp.c        **** #define BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MAX   ((PAUSE_LEN)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3
 341:irmp.c        **** #define BANG_OLUFSEN_START_BIT4_PULSE_LEN_MIN   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 342:irmp.c        **** #define BANG_OLUFSEN_START_BIT4_PULSE_LEN_MAX   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 343:irmp.c        **** #define BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MIN   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 344:irmp.c        **** #define BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MAX   ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_B
 345:irmp.c        **** #define BANG_OLUFSEN_PULSE_LEN_MIN              ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_PULSE_T
 346:irmp.c        **** #define BANG_OLUFSEN_PULSE_LEN_MAX              ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_PULSE_T
 347:irmp.c        **** #define BANG_OLUFSEN_1_PAUSE_LEN_MIN            ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_1_PAUSE
 348:irmp.c        **** #define BANG_OLUFSEN_1_PAUSE_LEN_MAX            ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_1_PAUSE
 349:irmp.c        **** #define BANG_OLUFSEN_0_PAUSE_LEN_MIN            ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_0_PAUSE
 350:irmp.c        **** #define BANG_OLUFSEN_0_PAUSE_LEN_MAX            ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_0_PAUSE
 351:irmp.c        **** #define BANG_OLUFSEN_R_PAUSE_LEN_MIN            ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_R_PAUSE
 352:irmp.c        **** #define BANG_OLUFSEN_R_PAUSE_LEN_MAX            ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_R_PAUSE
 353:irmp.c        **** #define BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MIN  ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_TRAILER
 354:irmp.c        **** #define BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MAX  ((uint_fast8_t)(F_INTERRUPTS * BANG_OLUFSEN_TRAILER
 355:irmp.c        **** 
 356:irmp.c        **** #define IR60_TIMEOUT_LEN                        ((uint_fast8_t)(F_INTERRUPTS * IR60_TIMEOUT_TIME * 
 357:irmp.c        **** #define GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN    ((uint_fast8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_B
 358:irmp.c        **** #define GRUNDIG_NOKIA_IR60_START_BIT_LEN_MAX    ((uint_fast8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_B
 359:irmp.c        **** #define GRUNDIG_NOKIA_IR60_BIT_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_B
 360:irmp.c        **** #define GRUNDIG_NOKIA_IR60_BIT_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_B
 361:irmp.c        **** #define GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN    ((uint_fast8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_P
 362:irmp.c        **** #define GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MAX    ((uint_fast8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_P
 363:irmp.c        **** 
 364:irmp.c        **** #define SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN       ((uint_fast8_t)(F_INTERRUPTS * SIEMENS_OR_R
 365:irmp.c        **** #define SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX       ((uint_fast8_t)(F_INTERRUPTS * SIEMENS_OR_R
 366:irmp.c        **** #define SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN       ((uint_fast8_t)(F_INTERRUPTS * SIEMENS_OR_R
 367:irmp.c        **** #define SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX       ((uint_fast8_t)(F_INTERRUPTS * SIEMENS_OR_R
 368:irmp.c        **** #define SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * SIEMENS_OR_R
 369:irmp.c        **** #define SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * SIEMENS_OR_R
 370:irmp.c        **** #define SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * SIEMENS_OR_R
 371:irmp.c        **** #define SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * SIEMENS_OR_R
 372:irmp.c        **** 
 373:irmp.c        **** #define FDC_START_BIT_PULSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * FDC_START_BIT_PULSE_
 374:irmp.c        **** #define FDC_START_BIT_PULSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * FDC_START_BIT_PULSE_
 375:irmp.c        **** #define FDC_START_BIT_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * FDC_START_BIT_PAUSE_
 376:irmp.c        **** #define FDC_START_BIT_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * FDC_START_BIT_PAUSE_
 377:irmp.c        **** #define FDC_PULSE_LEN_MIN                       ((uint_fast8_t)(F_INTERRUPTS * FDC_PULSE_TIME * MIN
 378:irmp.c        **** #define FDC_PULSE_LEN_MAX                       ((uint_fast8_t)(F_INTERRUPTS * FDC_PULSE_TIME * MAX
 379:irmp.c        **** #define FDC_1_PAUSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * FDC_1_PAUSE_TIME * M
 380:irmp.c        **** #define FDC_1_PAUSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * FDC_1_PAUSE_TIME * M
 381:irmp.c        **** #if 0
 382:irmp.c        **** #define FDC_0_PAUSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * FDC_0_PAUSE_TIME * M
 383:irmp.c        **** #else
 384:irmp.c        **** #define FDC_0_PAUSE_LEN_MIN                     (1)                                                
 385:irmp.c        **** #endif
 386:irmp.c        **** #define FDC_0_PAUSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * FDC_0_PAUSE_TIME * M
 387:irmp.c        **** 
 388:irmp.c        **** #define RCCAR_START_BIT_PULSE_LEN_MIN           ((uint_fast8_t)(F_INTERRUPTS * RCCAR_START_BIT_PULS
 389:irmp.c        **** #define RCCAR_START_BIT_PULSE_LEN_MAX           ((uint_fast8_t)(F_INTERRUPTS * RCCAR_START_BIT_PULS
 390:irmp.c        **** #define RCCAR_START_BIT_PAUSE_LEN_MIN           ((uint_fast8_t)(F_INTERRUPTS * RCCAR_START_BIT_PAUS
 391:irmp.c        **** #define RCCAR_START_BIT_PAUSE_LEN_MAX           ((uint_fast8_t)(F_INTERRUPTS * RCCAR_START_BIT_PAUS
 392:irmp.c        **** #define RCCAR_PULSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * RCCAR_PULSE_TIME * M
 393:irmp.c        **** #define RCCAR_PULSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * RCCAR_PULSE_TIME * M
 394:irmp.c        **** #define RCCAR_1_PAUSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * RCCAR_1_PAUSE_TIME *
 395:irmp.c        **** #define RCCAR_1_PAUSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * RCCAR_1_PAUSE_TIME *
 396:irmp.c        **** #define RCCAR_0_PAUSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * RCCAR_0_PAUSE_TIME *
 397:irmp.c        **** #define RCCAR_0_PAUSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * RCCAR_0_PAUSE_TIME *
 398:irmp.c        **** 
 399:irmp.c        **** #define JVC_START_BIT_PULSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_
 400:irmp.c        **** #define JVC_START_BIT_PULSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_
 401:irmp.c        **** #define JVC_REPEAT_START_BIT_PAUSE_LEN_MIN      ((uint_fast8_t)(F_INTERRUPTS * (JVC_FRAME_REPEAT_PA
 402:irmp.c        **** #define JVC_REPEAT_START_BIT_PAUSE_LEN_MAX      ((uint_fast8_t)(F_INTERRUPTS * (JVC_FRAME_REPEAT_PA
 403:irmp.c        **** #define JVC_PULSE_LEN_MIN                       ((uint_fast8_t)(F_INTERRUPTS * JVC_PULSE_TIME * MIN
 404:irmp.c        **** #define JVC_PULSE_LEN_MAX                       ((uint_fast8_t)(F_INTERRUPTS * JVC_PULSE_TIME * MAX
 405:irmp.c        **** #define JVC_1_PAUSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * JVC_1_PAUSE_TIME * M
 406:irmp.c        **** #define JVC_1_PAUSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * JVC_1_PAUSE_TIME * M
 407:irmp.c        **** #define JVC_0_PAUSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * JVC_0_PAUSE_TIME * M
 408:irmp.c        **** #define JVC_0_PAUSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * JVC_0_PAUSE_TIME * M
 409:irmp.c        **** // autodetect JVC repetition frame within 50 msec:
 410:irmp.c        **** #define JVC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint_fast16_t)(F_INTERRUPTS * JVC_FRAME_REPEAT_PAU
 411:irmp.c        **** 
 412:irmp.c        **** #define NIKON_START_BIT_PULSE_LEN_MIN           ((uint_fast8_t)(F_INTERRUPTS * NIKON_START_BIT_PULS
 413:irmp.c        **** #define NIKON_START_BIT_PULSE_LEN_MAX           ((uint_fast8_t)(F_INTERRUPTS * NIKON_START_BIT_PULS
 414:irmp.c        **** #define NIKON_START_BIT_PAUSE_LEN_MIN           ((uint_fast16_t)(F_INTERRUPTS * NIKON_START_BIT_PAU
 415:irmp.c        **** #define NIKON_START_BIT_PAUSE_LEN_MAX           ((uint_fast16_t)(F_INTERRUPTS * NIKON_START_BIT_PAU
 416:irmp.c        **** #define NIKON_REPEAT_START_BIT_PAUSE_LEN_MIN    ((uint_fast8_t)(F_INTERRUPTS * NIKON_REPEAT_START_B
 417:irmp.c        **** #define NIKON_REPEAT_START_BIT_PAUSE_LEN_MAX    ((uint_fast8_t)(F_INTERRUPTS * NIKON_REPEAT_START_B
 418:irmp.c        **** #define NIKON_PULSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * NIKON_PULSE_TIME * M
 419:irmp.c        **** #define NIKON_PULSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * NIKON_PULSE_TIME * M
 420:irmp.c        **** #define NIKON_1_PAUSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * NIKON_1_PAUSE_TIME *
 421:irmp.c        **** #define NIKON_1_PAUSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * NIKON_1_PAUSE_TIME *
 422:irmp.c        **** #define NIKON_0_PAUSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * NIKON_0_PAUSE_TIME *
 423:irmp.c        **** #define NIKON_0_PAUSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * NIKON_0_PAUSE_TIME *
 424:irmp.c        **** #define NIKON_FRAME_REPEAT_PAUSE_LEN_MAX        (uint_fast16_t)(F_INTERRUPTS * NIKON_FRAME_REPEAT_P
 425:irmp.c        **** 
 426:irmp.c        **** #define KATHREIN_START_BIT_PULSE_LEN_MIN        ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_START_BIT_P
 427:irmp.c        **** #define KATHREIN_START_BIT_PULSE_LEN_MAX        ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_START_BIT_P
 428:irmp.c        **** #define KATHREIN_START_BIT_PAUSE_LEN_MIN        ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_START_BIT_P
 429:irmp.c        **** #define KATHREIN_START_BIT_PAUSE_LEN_MAX        ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_START_BIT_P
 430:irmp.c        **** #define KATHREIN_1_PULSE_LEN_MIN                ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_1_PULSE_TIM
 431:irmp.c        **** #define KATHREIN_1_PULSE_LEN_MAX                ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_1_PULSE_TIM
 432:irmp.c        **** #define KATHREIN_1_PAUSE_LEN_MIN                ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_1_PAUSE_TIM
 433:irmp.c        **** #define KATHREIN_1_PAUSE_LEN_MAX                ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_1_PAUSE_TIM
 434:irmp.c        **** #define KATHREIN_0_PULSE_LEN_MIN                ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_0_PULSE_TIM
 435:irmp.c        **** #define KATHREIN_0_PULSE_LEN_MAX                ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_0_PULSE_TIM
 436:irmp.c        **** #define KATHREIN_0_PAUSE_LEN_MIN                ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_0_PAUSE_TIM
 437:irmp.c        **** #define KATHREIN_0_PAUSE_LEN_MAX                ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_0_PAUSE_TIM
 438:irmp.c        **** #define KATHREIN_SYNC_BIT_PAUSE_LEN_MIN         ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_SYNC_BIT_PA
 439:irmp.c        **** #define KATHREIN_SYNC_BIT_PAUSE_LEN_MAX         ((uint_fast8_t)(F_INTERRUPTS * KATHREIN_SYNC_BIT_PA
 440:irmp.c        **** 
 441:irmp.c        **** #define NETBOX_START_BIT_PULSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * NETBOX_START_BIT_PUL
 442:irmp.c        **** #define NETBOX_START_BIT_PULSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * NETBOX_START_BIT_PUL
 443:irmp.c        **** #define NETBOX_START_BIT_PAUSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * NETBOX_START_BIT_PAU
 444:irmp.c        **** #define NETBOX_START_BIT_PAUSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * NETBOX_START_BIT_PAU
 445:irmp.c        **** #define NETBOX_PULSE_LEN                        ((uint_fast8_t)(F_INTERRUPTS * NETBOX_PULSE_TIME))
 446:irmp.c        **** #define NETBOX_PAUSE_LEN                        ((uint_fast8_t)(F_INTERRUPTS * NETBOX_PAUSE_TIME))
 447:irmp.c        **** #define NETBOX_PULSE_REST_LEN                   ((uint_fast8_t)(F_INTERRUPTS * NETBOX_PULSE_TIME / 
 448:irmp.c        **** #define NETBOX_PAUSE_REST_LEN                   ((uint_fast8_t)(F_INTERRUPTS * NETBOX_PAUSE_TIME / 
 449:irmp.c        **** 
 450:irmp.c        **** #define LEGO_START_BIT_PULSE_LEN_MIN            ((uint_fast8_t)(F_INTERRUPTS * LEGO_START_BIT_PULSE
 451:irmp.c        **** #define LEGO_START_BIT_PULSE_LEN_MAX            ((uint_fast8_t)(F_INTERRUPTS * LEGO_START_BIT_PULSE
 452:irmp.c        **** #define LEGO_START_BIT_PAUSE_LEN_MIN            ((uint_fast8_t)(F_INTERRUPTS * LEGO_START_BIT_PAUSE
 453:irmp.c        **** #define LEGO_START_BIT_PAUSE_LEN_MAX            ((uint_fast8_t)(F_INTERRUPTS * LEGO_START_BIT_PAUSE
 454:irmp.c        **** #define LEGO_PULSE_LEN_MIN                      ((uint_fast8_t)(F_INTERRUPTS * LEGO_PULSE_TIME * MI
 455:irmp.c        **** #define LEGO_PULSE_LEN_MAX                      ((uint_fast8_t)(F_INTERRUPTS * LEGO_PULSE_TIME * MA
 456:irmp.c        **** #define LEGO_1_PAUSE_LEN_MIN                    ((uint_fast8_t)(F_INTERRUPTS * LEGO_1_PAUSE_TIME * 
 457:irmp.c        **** #define LEGO_1_PAUSE_LEN_MAX                    ((uint_fast8_t)(F_INTERRUPTS * LEGO_1_PAUSE_TIME * 
 458:irmp.c        **** #define LEGO_0_PAUSE_LEN_MIN                    ((uint_fast8_t)(F_INTERRUPTS * LEGO_0_PAUSE_TIME * 
 459:irmp.c        **** #define LEGO_0_PAUSE_LEN_MAX                    ((uint_fast8_t)(F_INTERRUPTS * LEGO_0_PAUSE_TIME * 
 460:irmp.c        **** 
 461:irmp.c        **** #define IRMP16_START_BIT_PULSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * IRMP16_START_BIT_PUL
 462:irmp.c        **** #define IRMP16_START_BIT_PULSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * IRMP16_START_BIT_PUL
 463:irmp.c        **** #define IRMP16_START_BIT_PAUSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * IRMP16_START_BIT_PAU
 464:irmp.c        **** #define IRMP16_START_BIT_PAUSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * IRMP16_START_BIT_PAU
 465:irmp.c        **** #define IRMP16_PULSE_LEN_MIN                    ((uint_fast8_t)(F_INTERRUPTS * IRMP16_PULSE_TIME * 
 466:irmp.c        **** #define IRMP16_PULSE_LEN_MAX                    ((uint_fast8_t)(F_INTERRUPTS * IRMP16_PULSE_TIME * 
 467:irmp.c        **** #define IRMP16_1_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * IRMP16_1_PAUSE_TIME 
 468:irmp.c        **** #define IRMP16_1_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * IRMP16_1_PAUSE_TIME 
 469:irmp.c        **** #define IRMP16_0_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * IRMP16_0_PAUSE_TIME 
 470:irmp.c        **** #define IRMP16_0_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * IRMP16_0_PAUSE_TIME 
 471:irmp.c        **** 
 472:irmp.c        **** #define GREE_START_BIT_PULSE_LEN_MIN            ((uint_fast8_t)(F_INTERRUPTS * GREE_START_BIT_PULSE
 473:irmp.c        **** #define GREE_START_BIT_PULSE_LEN_MAX            ((uint_fast8_t)(F_INTERRUPTS * GREE_START_BIT_PULSE
 474:irmp.c        **** #define GREE_START_BIT_PAUSE_LEN_MIN            ((uint_fast8_t)(F_INTERRUPTS * GREE_START_BIT_PAUSE
 475:irmp.c        **** #define GREE_START_BIT_PAUSE_LEN_MAX            ((uint_fast8_t)(F_INTERRUPTS * GREE_START_BIT_PAUSE
 476:irmp.c        **** #define GREE_PULSE_LEN_MIN                      ((uint_fast8_t)(F_INTERRUPTS * GREE_PULSE_TIME * MI
 477:irmp.c        **** #define GREE_PULSE_LEN_MAX                      ((uint_fast8_t)(F_INTERRUPTS * GREE_PULSE_TIME * MA
 478:irmp.c        **** #define GREE_1_PAUSE_LEN_MIN                    ((uint_fast8_t)(F_INTERRUPTS * GREE_1_PAUSE_TIME * 
 479:irmp.c        **** #define GREE_1_PAUSE_LEN_MAX                    ((uint_fast8_t)(F_INTERRUPTS * GREE_1_PAUSE_TIME * 
 480:irmp.c        **** #define GREE_0_PAUSE_LEN_MIN                    ((uint_fast8_t)(F_INTERRUPTS * GREE_0_PAUSE_TIME * 
 481:irmp.c        **** #define GREE_0_PAUSE_LEN_MAX                    ((uint_fast8_t)(F_INTERRUPTS * GREE_0_PAUSE_TIME * 
 482:irmp.c        **** 
 483:irmp.c        **** #define BOSE_START_BIT_PULSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * BOSE_START_BIT_PULS
 484:irmp.c        **** #define BOSE_START_BIT_PULSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * BOSE_START_BIT_PULS
 485:irmp.c        **** #define BOSE_START_BIT_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * BOSE_START_BIT_PAUS
 486:irmp.c        **** #define BOSE_START_BIT_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * BOSE_START_BIT_PAUS
 487:irmp.c        **** #define BOSE_PULSE_LEN_MIN                       ((uint_fast8_t)(F_INTERRUPTS * BOSE_PULSE_TIME * M
 488:irmp.c        **** #define BOSE_PULSE_LEN_MAX                       ((uint_fast8_t)(F_INTERRUPTS * BOSE_PULSE_TIME * M
 489:irmp.c        **** #define BOSE_1_PAUSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * BOSE_1_PAUSE_TIME *
 490:irmp.c        **** #define BOSE_1_PAUSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * BOSE_1_PAUSE_TIME *
 491:irmp.c        **** #define BOSE_0_PAUSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * BOSE_0_PAUSE_TIME *
 492:irmp.c        **** #define BOSE_0_PAUSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * BOSE_0_PAUSE_TIME *
 493:irmp.c        **** #define BOSE_FRAME_REPEAT_PAUSE_LEN_MAX          (uint_fast16_t)(F_INTERRUPTS * 100.0e-3 * MAX_TOLE
 494:irmp.c        **** 
 495:irmp.c        **** #define A1TVBOX_START_BIT_PULSE_LEN_MIN         ((uint_fast8_t)(F_INTERRUPTS * A1TVBOX_START_BIT_PU
 496:irmp.c        **** #define A1TVBOX_START_BIT_PULSE_LEN_MAX         ((uint_fast8_t)(F_INTERRUPTS * A1TVBOX_START_BIT_PU
 497:irmp.c        **** #define A1TVBOX_START_BIT_PAUSE_LEN_MIN         ((uint_fast8_t)(F_INTERRUPTS * A1TVBOX_START_BIT_PA
 498:irmp.c        **** #define A1TVBOX_START_BIT_PAUSE_LEN_MAX         ((uint_fast8_t)(F_INTERRUPTS * A1TVBOX_START_BIT_PA
 499:irmp.c        **** #define A1TVBOX_BIT_PULSE_LEN_MIN               ((uint_fast8_t)(F_INTERRUPTS * A1TVBOX_BIT_PULSE_TI
 500:irmp.c        **** #define A1TVBOX_BIT_PULSE_LEN_MAX               ((uint_fast8_t)(F_INTERRUPTS * A1TVBOX_BIT_PULSE_TI
 501:irmp.c        **** #define A1TVBOX_BIT_PAUSE_LEN_MIN               ((uint_fast8_t)(F_INTERRUPTS * A1TVBOX_BIT_PAUSE_TI
 502:irmp.c        **** #define A1TVBOX_BIT_PAUSE_LEN_MAX               ((uint_fast8_t)(F_INTERRUPTS * A1TVBOX_BIT_PAUSE_TI
 503:irmp.c        **** 
 504:irmp.c        **** #define MERLIN_START_BIT_PULSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * MERLIN_START_BIT_PUL
 505:irmp.c        **** #define MERLIN_START_BIT_PULSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * MERLIN_START_BIT_PUL
 506:irmp.c        **** #define MERLIN_START_BIT_PAUSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * MERLIN_START_BIT_PAU
 507:irmp.c        **** #define MERLIN_START_BIT_PAUSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * MERLIN_START_BIT_PAU
 508:irmp.c        **** #define MERLIN_BIT_PULSE_LEN_MIN                ((uint_fast8_t)(F_INTERRUPTS * MERLIN_BIT_PULSE_TIM
 509:irmp.c        **** #define MERLIN_BIT_PULSE_LEN_MAX                ((uint_fast8_t)(F_INTERRUPTS * MERLIN_BIT_PULSE_TIM
 510:irmp.c        **** #define MERLIN_BIT_PAUSE_LEN_MIN                ((uint_fast8_t)(F_INTERRUPTS * MERLIN_BIT_PAUSE_TIM
 511:irmp.c        **** #define MERLIN_BIT_PAUSE_LEN_MAX                ((uint_fast8_t)(F_INTERRUPTS * MERLIN_BIT_PAUSE_TIM
 512:irmp.c        **** 
 513:irmp.c        **** #define ORTEK_START_BIT_PULSE_LEN_MIN           ((uint_fast8_t)(F_INTERRUPTS * ORTEK_START_BIT_PULS
 514:irmp.c        **** #define ORTEK_START_BIT_PULSE_LEN_MAX           ((uint_fast8_t)(F_INTERRUPTS * ORTEK_START_BIT_PULS
 515:irmp.c        **** #define ORTEK_START_BIT_PAUSE_LEN_MIN           ((uint_fast8_t)(F_INTERRUPTS * ORTEK_START_BIT_PAUS
 516:irmp.c        **** #define ORTEK_START_BIT_PAUSE_LEN_MAX           ((uint_fast8_t)(F_INTERRUPTS * ORTEK_START_BIT_PAUS
 517:irmp.c        **** #define ORTEK_BIT_PULSE_LEN_MIN                 ((uint_fast8_t)(F_INTERRUPTS * ORTEK_BIT_TIME * MIN
 518:irmp.c        **** #define ORTEK_BIT_PULSE_LEN_MAX                 ((uint_fast8_t)(F_INTERRUPTS * ORTEK_BIT_TIME * MAX
 519:irmp.c        **** #define ORTEK_BIT_PAUSE_LEN_MIN                 ((uint_fast8_t)(F_INTERRUPTS * ORTEK_BIT_TIME * MIN
 520:irmp.c        **** #define ORTEK_BIT_PAUSE_LEN_MAX                 ((uint_fast8_t)(F_INTERRUPTS * ORTEK_BIT_TIME * MAX
 521:irmp.c        **** 
 522:irmp.c        **** #define TELEFUNKEN_START_BIT_PULSE_LEN_MIN      ((uint_fast8_t)(F_INTERRUPTS * TELEFUNKEN_START_BIT
 523:irmp.c        **** #define TELEFUNKEN_START_BIT_PULSE_LEN_MAX      ((uint_fast8_t)(F_INTERRUPTS * TELEFUNKEN_START_BIT
 524:irmp.c        **** #define TELEFUNKEN_START_BIT_PAUSE_LEN_MIN      ((uint_fast8_t)(F_INTERRUPTS * (TELEFUNKEN_START_BI
 525:irmp.c        **** #define TELEFUNKEN_START_BIT_PAUSE_LEN_MAX      ((uint_fast8_t)(F_INTERRUPTS * (TELEFUNKEN_START_BI
 526:irmp.c        **** #define TELEFUNKEN_PULSE_LEN_MIN                ((uint_fast8_t)(F_INTERRUPTS * TELEFUNKEN_PULSE_TIM
 527:irmp.c        **** #define TELEFUNKEN_PULSE_LEN_MAX                ((uint_fast8_t)(F_INTERRUPTS * TELEFUNKEN_PULSE_TIM
 528:irmp.c        **** #define TELEFUNKEN_1_PAUSE_LEN_MIN              ((uint_fast8_t)(F_INTERRUPTS * TELEFUNKEN_1_PAUSE_T
 529:irmp.c        **** #define TELEFUNKEN_1_PAUSE_LEN_MAX              ((uint_fast8_t)(F_INTERRUPTS * TELEFUNKEN_1_PAUSE_T
 530:irmp.c        **** #define TELEFUNKEN_0_PAUSE_LEN_MIN              ((uint_fast8_t)(F_INTERRUPTS * TELEFUNKEN_0_PAUSE_T
 531:irmp.c        **** #define TELEFUNKEN_0_PAUSE_LEN_MAX              ((uint_fast8_t)(F_INTERRUPTS * TELEFUNKEN_0_PAUSE_T
 532:irmp.c        **** // autodetect TELEFUNKEN repetition frame within 50 msec:
 533:irmp.c        **** // #define TELEFUNKEN_FRAME_REPEAT_PAUSE_LEN_MAX   (uint_fast16_t)(F_INTERRUPTS * TELEFUNKEN_FRAME_
 534:irmp.c        **** 
 535:irmp.c        **** #define ROOMBA_START_BIT_PULSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_START_BIT_PUL
 536:irmp.c        **** #define ROOMBA_START_BIT_PULSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_START_BIT_PUL
 537:irmp.c        **** #define ROOMBA_START_BIT_PAUSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_START_BIT_PAU
 538:irmp.c        **** #define ROOMBA_START_BIT_PAUSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_START_BIT_PAU
 539:irmp.c        **** #define ROOMBA_1_PAUSE_LEN_EXACT                ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_1_PAUSE_TIME 
 540:irmp.c        **** #define ROOMBA_1_PULSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_1_PULSE_TIME 
 541:irmp.c        **** #define ROOMBA_1_PULSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_1_PULSE_TIME 
 542:irmp.c        **** #define ROOMBA_1_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_1_PAUSE_TIME 
 543:irmp.c        **** #define ROOMBA_1_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_1_PAUSE_TIME 
 544:irmp.c        **** #define ROOMBA_0_PAUSE_LEN                      ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_0_PAUSE_TIME)
 545:irmp.c        **** #define ROOMBA_0_PULSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_0_PULSE_TIME 
 546:irmp.c        **** #define ROOMBA_0_PULSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_0_PULSE_TIME 
 547:irmp.c        **** #define ROOMBA_0_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_0_PAUSE_TIME 
 548:irmp.c        **** #define ROOMBA_0_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * ROOMBA_0_PAUSE_TIME 
 549:irmp.c        **** 
 550:irmp.c        **** #define RCMM32_START_BIT_PULSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * RCMM32_START_BIT_PUL
 551:irmp.c        **** #define RCMM32_START_BIT_PULSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * RCMM32_START_BIT_PUL
 552:irmp.c        **** #define RCMM32_START_BIT_PAUSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * RCMM32_START_BIT_PAU
 553:irmp.c        **** #define RCMM32_START_BIT_PAUSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * RCMM32_START_BIT_PAU
 554:irmp.c        **** #define RCMM32_BIT_PULSE_LEN_MIN                ((uint_fast8_t)(F_INTERRUPTS * RCMM32_PULSE_TIME * 
 555:irmp.c        **** #define RCMM32_BIT_PULSE_LEN_MAX                ((uint_fast8_t)(F_INTERRUPTS * RCMM32_PULSE_TIME * 
 556:irmp.c        **** #define RCMM32_BIT_00_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * RCMM32_00_PAUSE_TIME
 557:irmp.c        **** #define RCMM32_BIT_00_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * RCMM32_00_PAUSE_TIME
 558:irmp.c        **** #define RCMM32_BIT_01_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * RCMM32_01_PAUSE_TIME
 559:irmp.c        **** #define RCMM32_BIT_01_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * RCMM32_01_PAUSE_TIME
 560:irmp.c        **** #define RCMM32_BIT_10_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * RCMM32_10_PAUSE_TIME
 561:irmp.c        **** #define RCMM32_BIT_10_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * RCMM32_10_PAUSE_TIME
 562:irmp.c        **** #define RCMM32_BIT_11_PAUSE_LEN_MIN             ((uint_fast8_t)(F_INTERRUPTS * RCMM32_11_PAUSE_TIME
 563:irmp.c        **** #define RCMM32_BIT_11_PAUSE_LEN_MAX             ((uint_fast8_t)(F_INTERRUPTS * RCMM32_11_PAUSE_TIME
 564:irmp.c        **** 
 565:irmp.c        **** #define PENTAX_START_BIT_PULSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * PENTAX_START_BIT_PUL
 566:irmp.c        **** #define PENTAX_START_BIT_PULSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * PENTAX_START_BIT_PUL
 567:irmp.c        **** #define PENTAX_START_BIT_PAUSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * PENTAX_START_BIT_PAU
 568:irmp.c        **** #define PENTAX_START_BIT_PAUSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * PENTAX_START_BIT_PAU
 569:irmp.c        **** #define PENTAX_1_PAUSE_LEN_EXACT                ((uint_fast8_t)(F_INTERRUPTS * PENTAX_1_PAUSE_TIME 
 570:irmp.c        **** #define PENTAX_PULSE_LEN_MIN                    ((uint_fast8_t)(F_INTERRUPTS * PENTAX_PULSE_TIME * 
 571:irmp.c        **** #define PENTAX_PULSE_LEN_MAX                    ((uint_fast8_t)(F_INTERRUPTS * PENTAX_PULSE_TIME * 
 572:irmp.c        **** #define PENTAX_1_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * PENTAX_1_PAUSE_TIME 
 573:irmp.c        **** #define PENTAX_1_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * PENTAX_1_PAUSE_TIME 
 574:irmp.c        **** #define PENTAX_0_PAUSE_LEN                      ((uint_fast8_t)(F_INTERRUPTS * PENTAX_0_PAUSE_TIME)
 575:irmp.c        **** #define PENTAX_PULSE_LEN_MIN                    ((uint_fast8_t)(F_INTERRUPTS * PENTAX_PULSE_TIME * 
 576:irmp.c        **** #define PENTAX_PULSE_LEN_MAX                    ((uint_fast8_t)(F_INTERRUPTS * PENTAX_PULSE_TIME * 
 577:irmp.c        **** #define PENTAX_0_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * PENTAX_0_PAUSE_TIME 
 578:irmp.c        **** #define PENTAX_0_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * PENTAX_0_PAUSE_TIME 
 579:irmp.c        **** 
 580:irmp.c        **** #define ACP24_START_BIT_PULSE_LEN_MIN           ((uint_fast8_t)(F_INTERRUPTS * ACP24_START_BIT_PULS
 581:irmp.c        **** #define ACP24_START_BIT_PULSE_LEN_MAX           ((uint_fast8_t)(F_INTERRUPTS * ACP24_START_BIT_PULS
 582:irmp.c        **** #define ACP24_START_BIT_PAUSE_LEN_MIN           ((uint_fast8_t)(F_INTERRUPTS * ACP24_START_BIT_PAUS
 583:irmp.c        **** #define ACP24_START_BIT_PAUSE_LEN_MAX           ((uint_fast8_t)(F_INTERRUPTS * ACP24_START_BIT_PAUS
 584:irmp.c        **** #define ACP24_PULSE_LEN_MIN                     ((uint_fast8_t)(F_INTERRUPTS * ACP24_PULSE_TIME * M
 585:irmp.c        **** #define ACP24_PULSE_LEN_MAX                     ((uint_fast8_t)(F_INTERRUPTS * ACP24_PULSE_TIME * M
 586:irmp.c        **** #define ACP24_1_PAUSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * ACP24_1_PAUSE_TIME *
 587:irmp.c        **** #define ACP24_1_PAUSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * ACP24_1_PAUSE_TIME *
 588:irmp.c        **** #define ACP24_0_PAUSE_LEN_MIN                   ((uint_fast8_t)(F_INTERRUPTS * ACP24_0_PAUSE_TIME *
 589:irmp.c        **** #define ACP24_0_PAUSE_LEN_MAX                   ((uint_fast8_t)(F_INTERRUPTS * ACP24_0_PAUSE_TIME *
 590:irmp.c        **** 
 591:irmp.c        **** #define METZ_START_BIT_PULSE_LEN_MIN            ((uint_fast8_t)(F_INTERRUPTS * METZ_START_BIT_PULSE
 592:irmp.c        **** #define METZ_START_BIT_PULSE_LEN_MAX            ((uint_fast8_t)(F_INTERRUPTS * METZ_START_BIT_PULSE
 593:irmp.c        **** #define METZ_START_BIT_PAUSE_LEN_MIN            ((uint_fast8_t)(F_INTERRUPTS * METZ_START_BIT_PAUSE
 594:irmp.c        **** #define METZ_START_BIT_PAUSE_LEN_MAX            ((uint_fast8_t)(F_INTERRUPTS * METZ_START_BIT_PAUSE
 595:irmp.c        **** #define METZ_PULSE_LEN_MIN                      ((uint_fast8_t)(F_INTERRUPTS * METZ_PULSE_TIME * MI
 596:irmp.c        **** #define METZ_PULSE_LEN_MAX                      ((uint_fast8_t)(F_INTERRUPTS * METZ_PULSE_TIME * MA
 597:irmp.c        **** #define METZ_1_PAUSE_LEN_MIN                    ((uint_fast8_t)(F_INTERRUPTS * METZ_1_PAUSE_TIME * 
 598:irmp.c        **** #define METZ_1_PAUSE_LEN_MAX                    ((uint_fast8_t)(F_INTERRUPTS * METZ_1_PAUSE_TIME * 
 599:irmp.c        **** #define METZ_0_PAUSE_LEN_MIN                    ((uint_fast8_t)(F_INTERRUPTS * METZ_0_PAUSE_TIME * 
 600:irmp.c        **** #define METZ_0_PAUSE_LEN_MAX                    ((uint_fast8_t)(F_INTERRUPTS * METZ_0_PAUSE_TIME * 
 601:irmp.c        **** #define METZ_FRAME_REPEAT_PAUSE_LEN_MAX         (uint_fast16_t)(F_INTERRUPTS * METZ_FRAME_REPEAT_PA
 602:irmp.c        **** 
 603:irmp.c        **** #define RADIO1_START_BIT_PULSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * RADIO1_START_BIT_PUL
 604:irmp.c        **** #define RADIO1_START_BIT_PULSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * RADIO1_START_BIT_PUL
 605:irmp.c        **** #define RADIO1_START_BIT_PAUSE_LEN_MIN          ((uint_fast8_t)(F_INTERRUPTS * RADIO1_START_BIT_PAU
 606:irmp.c        **** #define RADIO1_START_BIT_PAUSE_LEN_MAX          ((uint_fast8_t)(F_INTERRUPTS * RADIO1_START_BIT_PAU
 607:irmp.c        **** #define RADIO1_1_PAUSE_LEN_EXACT                ((uint_fast8_t)(F_INTERRUPTS * RADIO1_1_PAUSE_TIME 
 608:irmp.c        **** #define RADIO1_1_PULSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * RADIO1_1_PULSE_TIME 
 609:irmp.c        **** #define RADIO1_1_PULSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * RADIO1_1_PULSE_TIME 
 610:irmp.c        **** #define RADIO1_1_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * RADIO1_1_PAUSE_TIME 
 611:irmp.c        **** #define RADIO1_1_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * RADIO1_1_PAUSE_TIME 
 612:irmp.c        **** #define RADIO1_0_PAUSE_LEN                      ((uint_fast8_t)(F_INTERRUPTS * RADIO1_0_PAUSE_TIME)
 613:irmp.c        **** #define RADIO1_0_PULSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * RADIO1_0_PULSE_TIME 
 614:irmp.c        **** #define RADIO1_0_PULSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * RADIO1_0_PULSE_TIME 
 615:irmp.c        **** #define RADIO1_0_PAUSE_LEN_MIN                  ((uint_fast8_t)(F_INTERRUPTS * RADIO1_0_PAUSE_TIME 
 616:irmp.c        **** #define RADIO1_0_PAUSE_LEN_MAX                  ((uint_fast8_t)(F_INTERRUPTS * RADIO1_0_PAUSE_TIME 
 617:irmp.c        **** 
 618:irmp.c        **** #define AUTO_FRAME_REPETITION_LEN               (uint_fast16_t)(F_INTERRUPTS * AUTO_FRAME_REPETITIO
 619:irmp.c        **** 
 620:irmp.c        **** #ifdef ANALYZE
 621:irmp.c        **** #  define ANALYZE_PUTCHAR(a)                    { if (! silent)             { putchar (a);         
 622:irmp.c        **** #  define ANALYZE_ONLY_NORMAL_PUTCHAR(a)        { if (! silent && !verbose) { putchar (a);         
 623:irmp.c        **** #  define ANALYZE_PRINTF(...)                   { if (verbose)              { printf (__VA_ARGS__);
 624:irmp.c        **** #  define ANALYZE_ONLY_NORMAL_PRINTF(...)       { if (! silent && !verbose) { printf (__VA_ARGS__);
 625:irmp.c        **** #  define ANALYZE_NEWLINE()                     { if (verbose)              { putchar ('\n');      
 626:irmp.c        **** static int                                      silent;
 627:irmp.c        **** static int                                      time_counter;
 628:irmp.c        **** static int                                      verbose;
 629:irmp.c        **** 
 630:irmp.c        **** /*******************************                not every PIC compiler knows variadic macros :-(
 631:irmp.c        **** #else
 632:irmp.c        **** #  define ANALYZE_PUTCHAR(a)
 633:irmp.c        **** #  define ANALYZE_ONLY_NORMAL_PUTCHAR(a)
 634:irmp.c        **** #  define ANALYZE_PRINTF(...)
 635:irmp.c        **** #  define ANALYZE_ONLY_NORMAL_PRINTF(...)
 636:irmp.c        **** #  endif
 637:irmp.c        **** #  define ANALYZE_NEWLINE()
 638:irmp.c        **** *********************************/
 639:irmp.c        **** #endif
 640:irmp.c        **** 
 641:irmp.c        **** #if IRMP_USE_CALLBACK == 1
 642:irmp.c        **** static void                                     (*irmp_callback_ptr) (uint_fast8_t);
 643:irmp.c        **** #endif // IRMP_USE_CALLBACK == 1
 644:irmp.c        **** 
 645:irmp.c        **** #define PARITY_CHECK_OK                         1
 646:irmp.c        **** #define PARITY_CHECK_FAILED                     0
 647:irmp.c        **** 
 648:irmp.c        **** /*-------------------------------------------------------------------------------------------------
 649:irmp.c        ****  *  Protocol names
 650:irmp.c        ****  *-------------------------------------------------------------------------------------------------
 651:irmp.c        ****  */
 652:irmp.c        **** #if defined(UNIX_OR_WINDOWS) || IRMP_PROTOCOL_NAMES == 1
 653:irmp.c        **** static const char proto_unknown[]       PROGMEM = "UNKNOWN";
 654:irmp.c        **** static const char proto_sircs[]         PROGMEM = "SIRCS";
 655:irmp.c        **** static const char proto_nec[]           PROGMEM = "NEC";
 656:irmp.c        **** static const char proto_samsung[]       PROGMEM = "SAMSUNG";
 657:irmp.c        **** static const char proto_matsushita[]    PROGMEM = "MATSUSH";
 658:irmp.c        **** static const char proto_kaseikyo[]      PROGMEM = "KASEIKYO";
 659:irmp.c        **** static const char proto_recs80[]        PROGMEM = "RECS80";
 660:irmp.c        **** static const char proto_rc5[]           PROGMEM = "RC5";
 661:irmp.c        **** static const char proto_denon[]         PROGMEM = "DENON";
 662:irmp.c        **** static const char proto_rc6[]           PROGMEM = "RC6";
 663:irmp.c        **** static const char proto_samsung32[]     PROGMEM = "SAMSG32";
 664:irmp.c        **** static const char proto_apple[]         PROGMEM = "APPLE";
 665:irmp.c        **** static const char proto_recs80ext[]     PROGMEM = "RECS80EX";
 666:irmp.c        **** static const char proto_nubert[]        PROGMEM = "NUBERT";
 667:irmp.c        **** static const char proto_bang_olufsen[]  PROGMEM = "BANG OLU";
 668:irmp.c        **** static const char proto_grundig[]       PROGMEM = "GRUNDIG";
 669:irmp.c        **** static const char proto_nokia[]         PROGMEM = "NOKIA";
 670:irmp.c        **** static const char proto_siemens[]       PROGMEM = "SIEMENS";
 671:irmp.c        **** static const char proto_fdc[]           PROGMEM = "FDC";
 672:irmp.c        **** static const char proto_rccar[]         PROGMEM = "RCCAR";
 673:irmp.c        **** static const char proto_jvc[]           PROGMEM = "JVC";
 674:irmp.c        **** static const char proto_rc6a[]          PROGMEM = "RC6A";
 675:irmp.c        **** static const char proto_nikon[]         PROGMEM = "NIKON";
 676:irmp.c        **** static const char proto_ruwido[]        PROGMEM = "RUWIDO";
 677:irmp.c        **** static const char proto_ir60[]          PROGMEM = "IR60";
 678:irmp.c        **** static const char proto_kathrein[]      PROGMEM = "KATHREIN";
 679:irmp.c        **** static const char proto_netbox[]        PROGMEM = "NETBOX";
 680:irmp.c        **** static const char proto_nec16[]         PROGMEM = "NEC16";
 681:irmp.c        **** static const char proto_nec42[]         PROGMEM = "NEC42";
 682:irmp.c        **** static const char proto_lego[]          PROGMEM = "LEGO";
 683:irmp.c        **** static const char proto_thomson[]       PROGMEM = "THOMSON";
 684:irmp.c        **** static const char proto_bose[]          PROGMEM = "BOSE";
 685:irmp.c        **** static const char proto_a1tvbox[]       PROGMEM = "A1TVBOX";
 686:irmp.c        **** static const char proto_ortek[]         PROGMEM = "ORTEK";
 687:irmp.c        **** static const char proto_telefunken[]    PROGMEM = "TELEFUNKEN";
 688:irmp.c        **** static const char proto_roomba[]        PROGMEM = "ROOMBA";
 689:irmp.c        **** static const char proto_rcmm32[]        PROGMEM = "RCMM32";
 690:irmp.c        **** static const char proto_rcmm24[]        PROGMEM = "RCMM24";
 691:irmp.c        **** static const char proto_rcmm12[]        PROGMEM = "RCMM12";
 692:irmp.c        **** static const char proto_speaker[]       PROGMEM = "SPEAKER";
 693:irmp.c        **** static const char proto_lgair[]         PROGMEM = "LGAIR";
 694:irmp.c        **** static const char proto_samsung48[]     PROGMEM = "SAMSG48";
 695:irmp.c        **** static const char proto_merlin[]        PROGMEM = "MERLIN";
 696:irmp.c        **** static const char proto_pentax[]        PROGMEM = "PENTAX";
 697:irmp.c        **** static const char proto_fan[]           PROGMEM = "FAN";
 698:irmp.c        **** static const char proto_s100[]          PROGMEM = "S100";
 699:irmp.c        **** static const char proto_acp24[]         PROGMEM = "ACP24";
 700:irmp.c        **** static const char proto_technics[]      PROGMEM = "TECHNICS";
 701:irmp.c        **** static const char proto_panasonic[]     PROGMEM = "PANASONIC";
 702:irmp.c        **** static const char proto_mitsu_heavy[]   PROGMEM = "MITSU_HEAVY";
 703:irmp.c        **** static const char proto_vincent[]       PROGMEM = "VINCENT";
 704:irmp.c        **** static const char proto_samsungah[]     PROGMEM = "SAMSUNGAH";
 705:irmp.c        **** static const char proto_irmp16[]        PROGMEM = "IRMP16";
 706:irmp.c        **** static const char proto_gree[]          PROGMEM = "GREE";
 707:irmp.c        **** static const char proto_rcii[]          PROGMEM = "RCII";
 708:irmp.c        **** static const char proto_metz[]          PROGMEM = "METZ";
 709:irmp.c        **** static const char proto_onkyo[]         PROGMEM = "ONKYO";
 710:irmp.c        **** 
 711:irmp.c        **** static const char proto_radio1[]        PROGMEM = "RADIO1";
 712:irmp.c        **** 
 713:irmp.c        **** const char * const
 714:irmp.c        **** irmp_protocol_names[IRMP_N_PROTOCOLS + 1] PROGMEM =
 715:irmp.c        **** {
 716:irmp.c        ****     proto_unknown,
 717:irmp.c        ****     proto_sircs,
 718:irmp.c        ****     proto_nec,
 719:irmp.c        ****     proto_samsung,
 720:irmp.c        ****     proto_matsushita,
 721:irmp.c        ****     proto_kaseikyo,
 722:irmp.c        ****     proto_recs80,
 723:irmp.c        ****     proto_rc5,
 724:irmp.c        ****     proto_denon,
 725:irmp.c        ****     proto_rc6,
 726:irmp.c        ****     proto_samsung32,
 727:irmp.c        ****     proto_apple,
 728:irmp.c        ****     proto_recs80ext,
 729:irmp.c        ****     proto_nubert,
 730:irmp.c        ****     proto_bang_olufsen,
 731:irmp.c        ****     proto_grundig,
 732:irmp.c        ****     proto_nokia,
 733:irmp.c        ****     proto_siemens,
 734:irmp.c        ****     proto_fdc,
 735:irmp.c        ****     proto_rccar,
 736:irmp.c        ****     proto_jvc,
 737:irmp.c        ****     proto_rc6a,
 738:irmp.c        ****     proto_nikon,
 739:irmp.c        ****     proto_ruwido,
 740:irmp.c        ****     proto_ir60,
 741:irmp.c        ****     proto_kathrein,
 742:irmp.c        ****     proto_netbox,
 743:irmp.c        ****     proto_nec16,
 744:irmp.c        ****     proto_nec42,
 745:irmp.c        ****     proto_lego,
 746:irmp.c        ****     proto_thomson,
 747:irmp.c        ****     proto_bose,
 748:irmp.c        ****     proto_a1tvbox,
 749:irmp.c        ****     proto_ortek,
 750:irmp.c        ****     proto_telefunken,
 751:irmp.c        ****     proto_roomba,
 752:irmp.c        ****     proto_rcmm32,
 753:irmp.c        ****     proto_rcmm24,
 754:irmp.c        ****     proto_rcmm12,
 755:irmp.c        ****     proto_speaker,
 756:irmp.c        ****     proto_lgair,
 757:irmp.c        ****     proto_samsung48,
 758:irmp.c        ****     proto_merlin,
 759:irmp.c        ****     proto_pentax,
 760:irmp.c        ****     proto_fan,
 761:irmp.c        ****     proto_s100,
 762:irmp.c        ****     proto_acp24,
 763:irmp.c        ****     proto_technics,
 764:irmp.c        ****     proto_panasonic,
 765:irmp.c        ****     proto_mitsu_heavy,
 766:irmp.c        ****     proto_vincent,
 767:irmp.c        ****     proto_samsungah,
 768:irmp.c        ****     proto_irmp16,
 769:irmp.c        ****     proto_gree,
 770:irmp.c        ****     proto_rcii,
 771:irmp.c        ****     proto_metz,
 772:irmp.c        ****     proto_onkyo,
 773:irmp.c        **** 
 774:irmp.c        ****     proto_radio1
 775:irmp.c        **** };
 776:irmp.c        **** 
 777:irmp.c        **** #endif
 778:irmp.c        **** 
 779:irmp.c        **** /*-------------------------------------------------------------------------------------------------
 780:irmp.c        ****  *  Logging
 781:irmp.c        ****  *-------------------------------------------------------------------------------------------------
 782:irmp.c        ****  */
 783:irmp.c        **** #if IRMP_LOGGING == 1                                                   // logging via UART
 784:irmp.c        **** 
 785:irmp.c        **** #if defined(ARM_STM32F4XX)
 786:irmp.c        **** #  define  STM32_GPIO_CLOCK   RCC_AHB1Periph_GPIOA                      // UART2 on PA2
 787:irmp.c        **** #  define  STM32_UART_CLOCK   RCC_APB1Periph_USART2
 788:irmp.c        **** #  define  STM32_GPIO_PORT    GPIOA
 789:irmp.c        **** #  define  STM32_GPIO_PIN     GPIO_Pin_2
 790:irmp.c        **** #  define  STM32_GPIO_SOURCE  GPIO_PinSource2
 791:irmp.c        **** #  define  STM32_UART_AF      GPIO_AF_USART2
 792:irmp.c        **** #  define  STM32_UART_COM     USART2
 793:irmp.c        **** #  define  STM32_UART_BAUD    115200                                    // 115200 Baud
 794:irmp.c        **** #  include "stm32f4xx_usart.h"
 795:irmp.c        **** #elif defined(ARM_STM32F10X)
 796:irmp.c        **** #  define  STM32_UART_COM     USART3                                    // UART3 on PB10
 797:irmp.c        **** #elif defined(ARDUINO)                                                  // Arduino Serial implement
 798:irmp.c        **** #  if defined(USB_SERIAL)
 799:irmp.c        **** #    include "usb_serial.h"
 800:irmp.c        **** #  else
 801:irmp.c        **** #    error USB_SERIAL not defined in ARDUINO Environment
 802:irmp.c        **** #  endif
 803:irmp.c        **** #elif defined(_CHIBIOS_HAL_)                                            // ChibiOS HAL
 804:irmp.c        **** #  if IRMP_EXT_LOGGING == 1
 805:irmp.c        **** #    error IRMP_EXT_LOGGING not implemented for ChibiOS HAL, use regular logging instead
 806:irmp.c        **** #  endif
 807:irmp.c        **** #else
 808:irmp.c        **** #  if IRMP_EXT_LOGGING == 1                                             // use external logging
 809:irmp.c        **** #    include "irmpextlog.h"
 810:irmp.c        **** #  else                                                                 // normal UART log (IRMP_EX
 811:irmp.c        **** #    define BAUD                                    9600L
 812:irmp.c        **** #  ifndef UNIX_OR_WINDOWS
 813:irmp.c        **** #    include <util/setbaud.h>
 814:irmp.c        **** #  endif
 815:irmp.c        **** 
 816:irmp.c        **** #ifdef UBRR0H
 817:irmp.c        **** 
 818:irmp.c        **** #define UART0_UBRRH                             UBRR0H
 819:irmp.c        **** #define UART0_UBRRL                             UBRR0L
 820:irmp.c        **** #define UART0_UCSRA                             UCSR0A
 821:irmp.c        **** #define UART0_UCSRB                             UCSR0B
 822:irmp.c        **** #define UART0_UCSRC                             UCSR0C
 823:irmp.c        **** #define UART0_UDRE_BIT_VALUE                    (1<<UDRE0)
 824:irmp.c        **** #define UART0_UCSZ1_BIT_VALUE                   (1<<UCSZ01)
 825:irmp.c        **** #define UART0_UCSZ0_BIT_VALUE                   (1<<UCSZ00)
 826:irmp.c        **** #ifdef URSEL0
 827:irmp.c        **** #define UART0_URSEL_BIT_VALUE                   (1<<URSEL0)
 828:irmp.c        **** #else
 829:irmp.c        **** #define UART0_URSEL_BIT_VALUE                   (0)
 830:irmp.c        **** #endif
 831:irmp.c        **** #define UART0_TXEN_BIT_VALUE                    (1<<TXEN0)
 832:irmp.c        **** #define UART0_UDR                               UDR0
 833:irmp.c        **** #define UART0_U2X                               U2X0
 834:irmp.c        **** 
 835:irmp.c        **** #else
 836:irmp.c        **** 
 837:irmp.c        **** #define UART0_UBRRH                             UBRRH
 838:irmp.c        **** #define UART0_UBRRL                             UBRRL
 839:irmp.c        **** #define UART0_UCSRA                             UCSRA
 840:irmp.c        **** #define UART0_UCSRB                             UCSRB
 841:irmp.c        **** #define UART0_UCSRC                             UCSRC
 842:irmp.c        **** #define UART0_UDRE_BIT_VALUE                    (1<<UDRE)
 843:irmp.c        **** #define UART0_UCSZ1_BIT_VALUE                   (1<<UCSZ1)
 844:irmp.c        **** #define UART0_UCSZ0_BIT_VALUE                   (1<<UCSZ0)
 845:irmp.c        **** #ifdef URSEL
 846:irmp.c        **** #define UART0_URSEL_BIT_VALUE                   (1<<URSEL)
 847:irmp.c        **** #else
 848:irmp.c        **** #define UART0_URSEL_BIT_VALUE                   (0)
 849:irmp.c        **** #endif
 850:irmp.c        **** #define UART0_TXEN_BIT_VALUE                    (1<<TXEN)
 851:irmp.c        **** #define UART0_UDR                               UDR
 852:irmp.c        **** #define UART0_U2X                               U2X
 853:irmp.c        **** 
 854:irmp.c        **** #endif //UBRR0H
 855:irmp.c        **** #endif //IRMP_EXT_LOGGING
 856:irmp.c        **** #endif //ARM_STM32F4XX
 857:irmp.c        **** 
 858:irmp.c        **** /*-------------------------------------------------------------------------------------------------
 859:irmp.c        ****  *  Initialize  UART
 860:irmp.c        ****  *  @details  Initializes UART
 861:irmp.c        ****  *-------------------------------------------------------------------------------------------------
 862:irmp.c        ****  */
 863:irmp.c        **** void
 864:irmp.c        **** irmp_uart_init (void)
 865:irmp.c        **** {
 866:irmp.c        **** #ifndef UNIX_OR_WINDOWS
 867:irmp.c        **** #if defined(ARM_STM32F4XX)
 868:irmp.c        ****     GPIO_InitTypeDef GPIO_InitStructure;
 869:irmp.c        ****     USART_InitTypeDef USART_InitStructure;
 870:irmp.c        **** 
 871:irmp.c        ****     // Clock enable vom TX Pin
 872:irmp.c        ****     RCC_AHB1PeriphClockCmd(STM32_GPIO_CLOCK, ENABLE);
 873:irmp.c        **** 
 874:irmp.c        ****     // Clock enable der UART
 875:irmp.c        ****     RCC_APB1PeriphClockCmd(STM32_UART_CLOCK, ENABLE);
 876:irmp.c        **** 
 877:irmp.c        ****     // UART Alternative-Funktion mit dem IO-Pin verbinden
 878:irmp.c        ****     GPIO_PinAFConfig(STM32_GPIO_PORT,STM32_GPIO_SOURCE,STM32_UART_AF);
 879:irmp.c        **** 
 880:irmp.c        ****     // UART als Alternative-Funktion mit PushPull
 881:irmp.c        ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 882:irmp.c        ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 883:irmp.c        ****     GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 884:irmp.c        ****     GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 885:irmp.c        **** 
 886:irmp.c        ****     // TX-Pin
 887:irmp.c        ****     GPIO_InitStructure.GPIO_Pin = STM32_GPIO_PIN;
 888:irmp.c        ****     GPIO_Init(STM32_GPIO_PORT, &GPIO_InitStructure);
 889:irmp.c        **** 
 890:irmp.c        ****     // Oversampling
 891:irmp.c        ****     USART_OverSampling8Cmd(STM32_UART_COM, ENABLE);
 892:irmp.c        **** 
 893:irmp.c        ****     // init baud rate, 8 data bits, 1 stop bit, no parity, no RTS+CTS
 894:irmp.c        ****     USART_InitStructure.USART_BaudRate = STM32_UART_BAUD;
 895:irmp.c        ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 896:irmp.c        ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;
 897:irmp.c        ****     USART_InitStructure.USART_Parity = USART_Parity_No;
 898:irmp.c        ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 899:irmp.c        ****     USART_InitStructure.USART_Mode = USART_Mode_Tx;
 900:irmp.c        ****     USART_Init(STM32_UART_COM, &USART_InitStructure);
 901:irmp.c        **** 
 902:irmp.c        ****     // UART enable
 903:irmp.c        ****     USART_Cmd(STM32_UART_COM, ENABLE);
 904:irmp.c        **** 
 905:irmp.c        **** #elif defined(ARM_STM32F10X)
 906:irmp.c        ****     GPIO_InitTypeDef GPIO_InitStructure;
 907:irmp.c        ****     USART_InitTypeDef USART_InitStructure;
 908:irmp.c        **** 
 909:irmp.c        ****     // Clock enable vom TX Pin
 910:irmp.c        ****     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // UART3 an PB10
 911:irmp.c        **** 
 912:irmp.c        ****     // Clock enable der UART
 913:irmp.c        ****     RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
 914:irmp.c        **** 
 915:irmp.c        ****     // UART als Alternative-Funktion mit PushPull
 916:irmp.c        ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 917:irmp.c        ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 918:irmp.c        **** 
 919:irmp.c        ****     // TX-Pin
 920:irmp.c        ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 921:irmp.c        ****     GPIO_Init(GPIOB, &GPIO_InitStructure);
 922:irmp.c        **** 
 923:irmp.c        ****     // Oversampling
 924:irmp.c        ****     USART_OverSampling8Cmd(STM32_UART_COM, ENABLE);
 925:irmp.c        **** 
 926:irmp.c        ****     // init baud rate, 8 data bits, 1 stop bit, no parity, no RTS+CTS
 927:irmp.c        ****     USART_InitStructure.USART_BaudRate = 115200;
 928:irmp.c        ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 929:irmp.c        ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;
 930:irmp.c        ****     USART_InitStructure.USART_Parity = USART_Parity_No;
 931:irmp.c        ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 932:irmp.c        ****     USART_InitStructure.USART_Mode = USART_Mode_Tx;
 933:irmp.c        ****     USART_Init(STM32_UART_COM, &USART_InitStructure);
 934:irmp.c        **** 
 935:irmp.c        ****     // UART enable
 936:irmp.c        ****     USART_Cmd(STM32_UART_COM, ENABLE);
 937:irmp.c        **** 
 938:irmp.c        **** #elif defined(ARDUINO)
 939:irmp.c        ****     // we use the Arduino Serial Imlementation
 940:irmp.c        ****     // you have to call Serial.begin(SER_BAUD); in Arduino setup() function
 941:irmp.c        **** 
 942:irmp.c        **** #elif defined (__AVR_XMEGA__)
 943:irmp.c        **** 
 944:irmp.c        ****     PMIC.CTRL |= PMIC_HILVLEN_bm;
 945:irmp.c        **** 
 946:irmp.c        ****     USARTC1.BAUDCTRLB = 0;
 947:irmp.c        ****     USARTC1.BAUDCTRLA = F_CPU / 153600 - 1;
 948:irmp.c        ****     USARTC1.CTRLA = USART_RXCINTLVL_HI_gc;                                                         
 949:irmp.c        ****     USARTC1.CTRLB = USART_TXEN_bm | USART_RXEN_bm;                                                 
 950:irmp.c        ****     USARTC1.CTRLC = USART_CHSIZE_8BIT_gc;                                                          
 951:irmp.c        ****     PORTC.DIR |= (1<<7);                                                                           
 952:irmp.c        ****     PORTC.DIR &= ~(1<<6);
 953:irmp.c        **** 
 954:irmp.c        **** #elif defined (_CHIBIOS_HAL_)
 955:irmp.c        ****     // we use the SD interface for logging, no need to init that here
 956:irmp.c        **** 
 957:irmp.c        **** #else
 958:irmp.c        **** 
 959:irmp.c        **** #if (IRMP_EXT_LOGGING == 0)                                                                        
 960:irmp.c        ****     UART0_UBRRH = UBRRH_VALUE;                                                                     
 961:irmp.c        ****     UART0_UBRRL = UBRRL_VALUE;
 962:irmp.c        **** 
 963:irmp.c        **** #if USE_2X
 964:irmp.c        ****     UART0_UCSRA |= (1<<UART0_U2X);
 965:irmp.c        **** #else
 966:irmp.c        ****     UART0_UCSRA &= ~(1<<UART0_U2X);
 967:irmp.c        **** #endif
 968:irmp.c        **** 
 969:irmp.c        ****     UART0_UCSRC = UART0_UCSZ1_BIT_VALUE | UART0_UCSZ0_BIT_VALUE | UART0_URSEL_BIT_VALUE;
 970:irmp.c        ****     UART0_UCSRB |= UART0_TXEN_BIT_VALUE;                                                           
 971:irmp.c        **** #else                                                                                              
 972:irmp.c        ****     initextlog();
 973:irmp.c        **** #endif //IRMP_EXT_LOGGING
 974:irmp.c        **** #endif //ARM_STM32F4XX
 975:irmp.c        **** #endif // UNIX_OR_WINDOWS
 976:irmp.c        **** }
 977:irmp.c        **** 
 978:irmp.c        **** /*-------------------------------------------------------------------------------------------------
 979:irmp.c        ****  *  Send character
 980:irmp.c        ****  *  @details  Sends character
 981:irmp.c        ****  *  @param    ch character to be transmitted
 982:irmp.c        ****  *-------------------------------------------------------------------------------------------------
 983:irmp.c        ****  */
 984:irmp.c        **** void
 985:irmp.c        **** irmp_uart_putc (unsigned char ch)
 986:irmp.c        **** {
 987:irmp.c        **** #ifndef UNIX_OR_WINDOWS
 988:irmp.c        **** #if defined(ARM_STM32F4XX) || defined(ARM_STM32F10X)
 989:irmp.c        ****     // warten bis altes Byte gesendet wurde
 990:irmp.c        ****     while (USART_GetFlagStatus(STM32_UART_COM, USART_FLAG_TXE) == RESET)
 991:irmp.c        ****     {
 992:irmp.c        ****         ;
 993:irmp.c        ****     }
 994:irmp.c        **** 
 995:irmp.c        ****     USART_SendData(STM32_UART_COM, ch);
 996:irmp.c        **** 
 997:irmp.c        ****     if (ch == '\n')
 998:irmp.c        ****     {
 999:irmp.c        ****         while (USART_GetFlagStatus(STM32_UART_COM, USART_FLAG_TXE) == RESET);
1000:irmp.c        ****         USART_SendData(STM32_UART_COM, '\r');
1001:irmp.c        ****     }
1002:irmp.c        **** 
1003:irmp.c        **** #elif defined(ARDUINO)
1004:irmp.c        ****     // we use the Arduino Serial Imlementation
1005:irmp.c        ****     usb_serial_putchar(ch);
1006:irmp.c        **** 
1007:irmp.c        **** #elif defined(_CHIBIOS_HAL_)
1008:irmp.c        ****     // use the SD interface from HAL, log to IRMP_LOGGING_SD which is defined in irmpconfig.h
1009:irmp.c        ****     sdWriteI(&IRMP_LOGGING_SD,&ch,1);      // we are called from interrupt context, so use the ...I
1010:irmp.c        **** 
1011:irmp.c        **** #else
1012:irmp.c        **** #if (IRMP_EXT_LOGGING == 0)
1013:irmp.c        **** 
1014:irmp.c        **** #  if defined (__AVR_XMEGA__)
1015:irmp.c        ****     while (!(USARTC1.STATUS & USART_DREIF_bm))
1016:irmp.c        ****     {
1017:irmp.c        ****         ;
1018:irmp.c        ****     }
1019:irmp.c        **** 
1020:irmp.c        ****     USARTC1.DATA = ch;
1021:irmp.c        **** 
1022:irmp.c        **** #  else // AVR_MEGA
1023:irmp.c        ****     while (!(UART0_UCSRA & UART0_UDRE_BIT_VALUE))
1024:irmp.c        ****     {
1025:irmp.c        ****         ;
1026:irmp.c        ****     }
1027:irmp.c        **** 
1028:irmp.c        ****     UART0_UDR = ch;
1029:irmp.c        **** 
1030:irmp.c        **** #  endif // __AVR_XMEGA__
1031:irmp.c        **** 
1032:irmp.c        **** #else
1033:irmp.c        **** 
1034:irmp.c        ****     sendextlog(ch);                                                         // use external log
1035:irmp.c        **** 
1036:irmp.c        **** #endif // IRMP_EXT_LOGGING
1037:irmp.c        **** #endif // ARM_STM32F4XX
1038:irmp.c        **** #else
1039:irmp.c        ****     fputc (ch, stderr);
1040:irmp.c        **** #endif // UNIX_OR_WINDOWS
1041:irmp.c        **** }
1042:irmp.c        **** 
1043:irmp.c        **** /*-------------------------------------------------------------------------------------------------
1044:irmp.c        ****  *  Log IR signal
1045:irmp.c        ****  *-------------------------------------------------------------------------------------------------
1046:irmp.c        ****  */
1047:irmp.c        **** 
1048:irmp.c        **** #define STARTCYCLES                       2                                 // min count of zeros b
1049:irmp.c        **** #define ENDBITS                        1000                                 // number of sequenced 
1050:irmp.c        **** #define DATALEN                         700                                 // log buffer size
1051:irmp.c        **** 
1052:irmp.c        **** static void
1053:irmp.c        **** irmp_log (uint_fast8_t val)
1054:irmp.c        **** {
1055:irmp.c        ****     static uint8_t          buf[DATALEN];                                   // logging buffer
1056:irmp.c        ****     static uint_fast16_t    buf_idx;                                        // index
1057:irmp.c        ****     static uint_fast8_t     startcycles;                                    // current number of st
1058:irmp.c        ****     static uint_fast16_t    cnt;                                            // counts sequenced hig
1059:irmp.c        ****     static uint_fast8_t     last_val = 1;
1060:irmp.c        **** 
1061:irmp.c        ****     if (! val && (startcycles < STARTCYCLES) && !buf_idx)                   // prevent that single 
1062:irmp.c        ****     {
1063:irmp.c        ****         startcycles++;
1064:irmp.c        ****     }
1065:irmp.c        ****     else
1066:irmp.c        ****     {
1067:irmp.c        ****         startcycles = 0;
1068:irmp.c        **** 
1069:irmp.c        ****         if (! val || buf_idx != 0)                                          // start or continue lo
1070:irmp.c        ****         {
1071:irmp.c        ****             if (last_val == val)
1072:irmp.c        ****             {
1073:irmp.c        ****                 cnt++;
1074:irmp.c        **** 
1075:irmp.c        ****                 if (val && cnt > ENDBITS)                                   // if high received the
1076:irmp.c        ****                 {                                                           // if stop condition is
1077:irmp.c        ****                     uint_fast8_t     i8;
1078:irmp.c        ****                     uint_fast16_t    i;
1079:irmp.c        ****                     uint_fast16_t    j;
1080:irmp.c        ****                     uint_fast8_t     v = '1';
1081:irmp.c        ****                     uint_fast16_t    d;
1082:irmp.c        **** 
1083:irmp.c        ****                     for (i8 = 0; i8 < STARTCYCLES; i8++)
1084:irmp.c        ****                     {
1085:irmp.c        ****                         irmp_uart_putc ('0');                               // the ignored starting
1086:irmp.c        ****                     }
1087:irmp.c        **** 
1088:irmp.c        ****                     for (i = 0; i < buf_idx; i++)
1089:irmp.c        ****                     {
1090:irmp.c        ****                         d = buf[i];
1091:irmp.c        **** 
1092:irmp.c        ****                         if (d == 0xff)
1093:irmp.c        ****                         {
1094:irmp.c        ****                             i++;
1095:irmp.c        ****                             d = buf[i];
1096:irmp.c        ****                             i++;
1097:irmp.c        ****                             d |= ((uint_fast16_t) buf[i] << 8);
1098:irmp.c        ****                         }
1099:irmp.c        **** 
1100:irmp.c        ****                         for (j = 0; j < d; j++)
1101:irmp.c        ****                         {
1102:irmp.c        ****                             irmp_uart_putc (v);
1103:irmp.c        ****                         }
1104:irmp.c        **** 
1105:irmp.c        ****                         v = (v == '1') ? '0' : '1';
1106:irmp.c        ****                     }
1107:irmp.c        **** 
1108:irmp.c        ****                     for (i8 = 0; i8 < 20; i8++)
1109:irmp.c        ****                     {
1110:irmp.c        ****                         irmp_uart_putc ('1');
1111:irmp.c        ****                     }
1112:irmp.c        **** 
1113:irmp.c        ****                     irmp_uart_putc ('\n');
1114:irmp.c        ****                     buf_idx = 0;
1115:irmp.c        ****                     last_val = 1;
1116:irmp.c        ****                     cnt = 0;
1117:irmp.c        ****                 }
1118:irmp.c        ****             }
1119:irmp.c        ****             else if (buf_idx < DATALEN - 3)
1120:irmp.c        ****             {
1121:irmp.c        ****                 if (cnt >= 0xff)
1122:irmp.c        ****                 {
1123:irmp.c        ****                     buf[buf_idx++]  = 0xff;
1124:irmp.c        ****                     buf[buf_idx++]  = (cnt & 0xff);
1125:irmp.c        ****                     buf[buf_idx]    = (cnt >> 8);
1126:irmp.c        ****                 }
1127:irmp.c        ****                 else
1128:irmp.c        ****                 {
1129:irmp.c        ****                     buf[buf_idx] = cnt;
1130:irmp.c        ****                 }
1131:irmp.c        **** 
1132:irmp.c        ****                 buf_idx++;
1133:irmp.c        ****                 cnt = 1;
1134:irmp.c        ****                 last_val = val;
1135:irmp.c        ****             }
1136:irmp.c        ****         }
1137:irmp.c        ****     }
1138:irmp.c        **** }
1139:irmp.c        **** 
1140:irmp.c        **** #else
1141:irmp.c        **** #define irmp_log(val)
1142:irmp.c        **** #endif //IRMP_LOGGING
1143:irmp.c        **** 
1144:irmp.c        **** typedef struct
1145:irmp.c        **** {
1146:irmp.c        ****     uint_fast8_t    protocol;                                                // ir protocol
1147:irmp.c        ****     uint_fast8_t    pulse_1_len_min;                                         // minimum length of p
1148:irmp.c        ****     uint_fast8_t    pulse_1_len_max;                                         // maximum length of p
1149:irmp.c        ****     uint_fast8_t    pause_1_len_min;                                         // minimum length of p
1150:irmp.c        ****     uint_fast8_t    pause_1_len_max;                                         // maximum length of p
1151:irmp.c        ****     uint_fast8_t    pulse_0_len_min;                                         // minimum length of p
1152:irmp.c        ****     uint_fast8_t    pulse_0_len_max;                                         // maximum length of p
1153:irmp.c        ****     uint_fast8_t    pause_0_len_min;                                         // minimum length of p
1154:irmp.c        ****     uint_fast8_t    pause_0_len_max;                                         // maximum length of p
1155:irmp.c        ****     uint_fast8_t    address_offset;                                          // address offset
1156:irmp.c        ****     uint_fast8_t    address_end;                                             // end of address
1157:irmp.c        ****     uint_fast8_t    command_offset;                                          // command offset
1158:irmp.c        ****     uint_fast8_t    command_end;                                             // end of command
1159:irmp.c        ****     uint_fast8_t    complete_len;                                            // complete length of 
1160:irmp.c        ****     uint_fast8_t    stop_bit;                                                // flag: frame has sto
1161:irmp.c        ****     uint_fast8_t    lsb_first;                                               // flag: LSB first
1162:irmp.c        ****     uint_fast8_t    flags;                                                   // some flags
1163:irmp.c        **** } IRMP_PARAMETER;
1164:irmp.c        **** 
1165:irmp.c        **** #if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
1166:irmp.c        **** 
1167:irmp.c        **** static const PROGMEM IRMP_PARAMETER sircs_param =
1168:irmp.c        **** {
1169:irmp.c        ****     IRMP_SIRCS_PROTOCOL,                                                // protocol:        ir prot
1170:irmp.c        ****     SIRCS_1_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum
1171:irmp.c        ****     SIRCS_1_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum
1172:irmp.c        ****     SIRCS_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
1173:irmp.c        ****     SIRCS_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
1174:irmp.c        ****     SIRCS_0_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum
1175:irmp.c        ****     SIRCS_0_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum
1176:irmp.c        ****     SIRCS_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
1177:irmp.c        ****     SIRCS_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
1178:irmp.c        ****     SIRCS_ADDRESS_OFFSET,                                               // address_offset:  address
1179:irmp.c        ****     SIRCS_ADDRESS_OFFSET + SIRCS_ADDRESS_LEN,                           // address_end:     end of 
1180:irmp.c        ****     SIRCS_COMMAND_OFFSET,                                               // command_offset:  command
1181:irmp.c        ****     SIRCS_COMMAND_OFFSET + SIRCS_COMMAND_LEN,                           // command_end:     end of 
1182:irmp.c        ****     SIRCS_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1183:irmp.c        ****     SIRCS_STOP_BIT,                                                     // stop_bit:        flag: f
1184:irmp.c        ****     SIRCS_LSB,                                                          // lsb_first:       flag: L
1185:irmp.c        ****     SIRCS_FLAGS                                                         // flags:           some fl
1186:irmp.c        **** };
1187:irmp.c        **** 
1188:irmp.c        **** #endif
1189:irmp.c        **** 
1190:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
1191:irmp.c        **** 
1192:irmp.c        **** static const PROGMEM IRMP_PARAMETER nec_param =
1193:irmp.c        **** {
1194:irmp.c        ****     IRMP_NEC_PROTOCOL,                                                  // protocol:        ir prot
1195:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum
1196:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum
1197:irmp.c        ****     NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
1198:irmp.c        ****     NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
1199:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum
1200:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum
1201:irmp.c        ****     NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
1202:irmp.c        ****     NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
1203:irmp.c        ****     NEC_ADDRESS_OFFSET,                                                 // address_offset:  address
1204:irmp.c        ****     NEC_ADDRESS_OFFSET + NEC_ADDRESS_LEN,                               // address_end:     end of 
1205:irmp.c        ****     NEC_COMMAND_OFFSET,                                                 // command_offset:  command
1206:irmp.c        ****     NEC_COMMAND_OFFSET + NEC_COMMAND_LEN,                               // command_end:     end of 
1207:irmp.c        ****     NEC_COMPLETE_DATA_LEN,                                              // complete_len:    complet
1208:irmp.c        ****     NEC_STOP_BIT,                                                       // stop_bit:        flag: f
1209:irmp.c        ****     NEC_LSB,                                                            // lsb_first:       flag: L
1210:irmp.c        ****     NEC_FLAGS                                                           // flags:           some fl
1211:irmp.c        **** };
1212:irmp.c        **** 
1213:irmp.c        **** static const PROGMEM IRMP_PARAMETER nec_rep_param =
1214:irmp.c        **** {
1215:irmp.c        ****     IRMP_NEC_PROTOCOL,                                                  // protocol:        ir prot
1216:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum
1217:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum
1218:irmp.c        ****     NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
1219:irmp.c        ****     NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
1220:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum
1221:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum
1222:irmp.c        ****     NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
1223:irmp.c        ****     NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
1224:irmp.c        ****     0,                                                                  // address_offset:  address
1225:irmp.c        ****     0,                                                                  // address_end:     end of 
1226:irmp.c        ****     0,                                                                  // command_offset:  command
1227:irmp.c        ****     0,                                                                  // command_end:     end of 
1228:irmp.c        ****     0,                                                                  // complete_len:    complet
1229:irmp.c        ****     NEC_STOP_BIT,                                                       // stop_bit:        flag: f
1230:irmp.c        ****     NEC_LSB,                                                            // lsb_first:       flag: L
1231:irmp.c        ****     NEC_FLAGS                                                           // flags:           some fl
1232:irmp.c        **** };
1233:irmp.c        **** 
1234:irmp.c        **** #endif
1235:irmp.c        **** 
1236:irmp.c        **** #if IRMP_SUPPORT_NEC42_PROTOCOL == 1
1237:irmp.c        **** 
1238:irmp.c        **** static const PROGMEM IRMP_PARAMETER nec42_param =
1239:irmp.c        **** {
1240:irmp.c        ****     IRMP_NEC42_PROTOCOL,                                                // protocol:        ir prot
1241:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum
1242:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum
1243:irmp.c        ****     NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
1244:irmp.c        ****     NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
1245:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum
1246:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum
1247:irmp.c        ****     NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
1248:irmp.c        ****     NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
1249:irmp.c        ****     NEC42_ADDRESS_OFFSET,                                               // address_offset:  address
1250:irmp.c        ****     NEC42_ADDRESS_OFFSET + NEC42_ADDRESS_LEN,                           // address_end:     end of 
1251:irmp.c        ****     NEC42_COMMAND_OFFSET,                                               // command_offset:  command
1252:irmp.c        ****     NEC42_COMMAND_OFFSET + NEC42_COMMAND_LEN,                           // command_end:     end of 
1253:irmp.c        ****     NEC42_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1254:irmp.c        ****     NEC_STOP_BIT,                                                       // stop_bit:        flag: f
1255:irmp.c        ****     NEC_LSB,                                                            // lsb_first:       flag: L
1256:irmp.c        ****     NEC_FLAGS                                                           // flags:           some fl
1257:irmp.c        **** };
1258:irmp.c        **** 
1259:irmp.c        **** #endif
1260:irmp.c        **** 
1261:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
1262:irmp.c        **** 
1263:irmp.c        **** static const PROGMEM IRMP_PARAMETER lgair_param =
1264:irmp.c        **** {
1265:irmp.c        ****     IRMP_LGAIR_PROTOCOL,                                                // protocol:        ir prot
1266:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum
1267:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum
1268:irmp.c        ****     NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
1269:irmp.c        ****     NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
1270:irmp.c        ****     NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum
1271:irmp.c        ****     NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum
1272:irmp.c        ****     NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
1273:irmp.c        ****     NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
1274:irmp.c        ****     LGAIR_ADDRESS_OFFSET,                                               // address_offset:  address
1275:irmp.c        ****     LGAIR_ADDRESS_OFFSET + LGAIR_ADDRESS_LEN,                           // address_end:     end of 
1276:irmp.c        ****     LGAIR_COMMAND_OFFSET,                                               // command_offset:  command
1277:irmp.c        ****     LGAIR_COMMAND_OFFSET + LGAIR_COMMAND_LEN,                           // command_end:     end of 
1278:irmp.c        ****     LGAIR_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1279:irmp.c        ****     NEC_STOP_BIT,                                                       // stop_bit:        flag: f
1280:irmp.c        ****     NEC_LSB,                                                            // lsb_first:       flag: L
1281:irmp.c        ****     NEC_FLAGS                                                           // flags:           some fl
1282:irmp.c        **** };
1283:irmp.c        **** 
1284:irmp.c        **** #endif
1285:irmp.c        **** 
1286:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
1287:irmp.c        **** 
1288:irmp.c        **** static const PROGMEM IRMP_PARAMETER samsung_param =
1289:irmp.c        **** {
1290:irmp.c        ****     IRMP_SAMSUNG_PROTOCOL,                                              // protocol:        ir prot
1291:irmp.c        ****     SAMSUNG_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum
1292:irmp.c        ****     SAMSUNG_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum
1293:irmp.c        ****     SAMSUNG_1_PAUSE_LEN_MIN,                                            // pause_1_len_min: minimum
1294:irmp.c        ****     SAMSUNG_1_PAUSE_LEN_MAX,                                            // pause_1_len_max: maximum
1295:irmp.c        ****     SAMSUNG_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum
1296:irmp.c        ****     SAMSUNG_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum
1297:irmp.c        ****     SAMSUNG_0_PAUSE_LEN_MIN,                                            // pause_0_len_min: minimum
1298:irmp.c        ****     SAMSUNG_0_PAUSE_LEN_MAX,                                            // pause_0_len_max: maximum
1299:irmp.c        ****     SAMSUNG_ADDRESS_OFFSET,                                             // address_offset:  address
1300:irmp.c        ****     SAMSUNG_ADDRESS_OFFSET + SAMSUNG_ADDRESS_LEN,                       // address_end:     end of 
1301:irmp.c        ****     SAMSUNG_COMMAND_OFFSET,                                             // command_offset:  command
1302:irmp.c        ****     SAMSUNG_COMMAND_OFFSET + SAMSUNG_COMMAND_LEN,                       // command_end:     end of 
1303:irmp.c        ****     SAMSUNG_COMPLETE_DATA_LEN,                                          // complete_len:    complet
1304:irmp.c        ****     SAMSUNG_STOP_BIT,                                                   // stop_bit:        flag: f
1305:irmp.c        ****     SAMSUNG_LSB,                                                        // lsb_first:       flag: L
1306:irmp.c        ****     SAMSUNG_FLAGS                                                       // flags:           some fl
1307:irmp.c        **** };
1308:irmp.c        **** 
1309:irmp.c        **** #endif
1310:irmp.c        **** 
1311:irmp.c        **** #if IRMP_SUPPORT_SAMSUNGAH_PROTOCOL == 1
1312:irmp.c        **** 
1313:irmp.c        **** static const PROGMEM IRMP_PARAMETER samsungah_param =
1314:irmp.c        **** {
1315:irmp.c        ****     IRMP_SAMSUNGAH_PROTOCOL,                                            // protocol:        ir prot
1316:irmp.c        ****     SAMSUNGAH_PULSE_LEN_MIN,                                            // pulse_1_len_min: minimum
1317:irmp.c        ****     SAMSUNGAH_PULSE_LEN_MAX,                                            // pulse_1_len_max: maximum
1318:irmp.c        ****     SAMSUNGAH_1_PAUSE_LEN_MIN,                                          // pause_1_len_min: minimum
1319:irmp.c        ****     SAMSUNGAH_1_PAUSE_LEN_MAX,                                          // pause_1_len_max: maximum
1320:irmp.c        ****     SAMSUNGAH_PULSE_LEN_MIN,                                            // pulse_0_len_min: minimum
1321:irmp.c        ****     SAMSUNGAH_PULSE_LEN_MAX,                                            // pulse_0_len_max: maximum
1322:irmp.c        ****     SAMSUNGAH_0_PAUSE_LEN_MIN,                                          // pause_0_len_min: minimum
1323:irmp.c        ****     SAMSUNGAH_0_PAUSE_LEN_MAX,                                          // pause_0_len_max: maximum
1324:irmp.c        ****     SAMSUNGAH_ADDRESS_OFFSET,                                           // address_offset:  address
1325:irmp.c        ****     SAMSUNGAH_ADDRESS_OFFSET + SAMSUNGAH_ADDRESS_LEN,                   // address_end:     end of 
1326:irmp.c        ****     SAMSUNGAH_COMMAND_OFFSET,                                           // command_offset:  command
1327:irmp.c        ****     SAMSUNGAH_COMMAND_OFFSET + SAMSUNGAH_COMMAND_LEN,                   // command_end:     end of 
1328:irmp.c        ****     SAMSUNGAH_COMPLETE_DATA_LEN,                                        // complete_len:    complet
1329:irmp.c        ****     SAMSUNGAH_STOP_BIT,                                                 // stop_bit:        flag: f
1330:irmp.c        ****     SAMSUNGAH_LSB,                                                      // lsb_first:       flag: L
1331:irmp.c        ****     SAMSUNGAH_FLAGS                                                     // flags:           some fl
1332:irmp.c        **** };
1333:irmp.c        **** 
1334:irmp.c        **** #endif
1335:irmp.c        **** 
1336:irmp.c        **** #if IRMP_SUPPORT_TELEFUNKEN_PROTOCOL == 1
1337:irmp.c        **** 
1338:irmp.c        **** static const PROGMEM IRMP_PARAMETER telefunken_param =
1339:irmp.c        **** {
1340:irmp.c        ****     IRMP_TELEFUNKEN_PROTOCOL,                                           // protocol:        ir prot
1341:irmp.c        ****     TELEFUNKEN_PULSE_LEN_MIN,                                           // pulse_1_len_min: minimum
1342:irmp.c        ****     TELEFUNKEN_PULSE_LEN_MAX,                                           // pulse_1_len_max: maximum
1343:irmp.c        ****     TELEFUNKEN_1_PAUSE_LEN_MIN,                                         // pause_1_len_min: minimum
1344:irmp.c        ****     TELEFUNKEN_1_PAUSE_LEN_MAX,                                         // pause_1_len_max: maximum
1345:irmp.c        ****     TELEFUNKEN_PULSE_LEN_MIN,                                           // pulse_0_len_min: minimum
1346:irmp.c        ****     TELEFUNKEN_PULSE_LEN_MAX,                                           // pulse_0_len_max: maximum
1347:irmp.c        ****     TELEFUNKEN_0_PAUSE_LEN_MIN,                                         // pause_0_len_min: minimum
1348:irmp.c        ****     TELEFUNKEN_0_PAUSE_LEN_MAX,                                         // pause_0_len_max: maximum
1349:irmp.c        ****     TELEFUNKEN_ADDRESS_OFFSET,                                          // address_offset:  address
1350:irmp.c        ****     TELEFUNKEN_ADDRESS_OFFSET + TELEFUNKEN_ADDRESS_LEN,                 // address_end:     end of 
1351:irmp.c        ****     TELEFUNKEN_COMMAND_OFFSET,                                          // command_offset:  command
1352:irmp.c        ****     TELEFUNKEN_COMMAND_OFFSET + TELEFUNKEN_COMMAND_LEN,                 // command_end:     end of 
1353:irmp.c        ****     TELEFUNKEN_COMPLETE_DATA_LEN,                                       // complete_len:    complet
1354:irmp.c        ****     TELEFUNKEN_STOP_BIT,                                                // stop_bit:        flag: f
1355:irmp.c        ****     TELEFUNKEN_LSB,                                                     // lsb_first:       flag: L
1356:irmp.c        ****     TELEFUNKEN_FLAGS                                                    // flags:           some fl
1357:irmp.c        **** };
1358:irmp.c        **** 
1359:irmp.c        **** #endif
1360:irmp.c        **** 
1361:irmp.c        **** #if IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
1362:irmp.c        **** 
1363:irmp.c        **** static const PROGMEM IRMP_PARAMETER matsushita_param =
1364:irmp.c        **** {
1365:irmp.c        ****     IRMP_MATSUSHITA_PROTOCOL,                                           // protocol:        ir prot
1366:irmp.c        ****     MATSUSHITA_PULSE_LEN_MIN,                                           // pulse_1_len_min: minimum
1367:irmp.c        ****     MATSUSHITA_PULSE_LEN_MAX,                                           // pulse_1_len_max: maximum
1368:irmp.c        ****     MATSUSHITA_1_PAUSE_LEN_MIN,                                         // pause_1_len_min: minimum
1369:irmp.c        ****     MATSUSHITA_1_PAUSE_LEN_MAX,                                         // pause_1_len_max: maximum
1370:irmp.c        ****     MATSUSHITA_PULSE_LEN_MIN,                                           // pulse_0_len_min: minimum
1371:irmp.c        ****     MATSUSHITA_PULSE_LEN_MAX,                                           // pulse_0_len_max: maximum
1372:irmp.c        ****     MATSUSHITA_0_PAUSE_LEN_MIN,                                         // pause_0_len_min: minimum
1373:irmp.c        ****     MATSUSHITA_0_PAUSE_LEN_MAX,                                         // pause_0_len_max: maximum
1374:irmp.c        ****     MATSUSHITA_ADDRESS_OFFSET,                                          // address_offset:  address
1375:irmp.c        ****     MATSUSHITA_ADDRESS_OFFSET + MATSUSHITA_ADDRESS_LEN,                 // address_end:     end of 
1376:irmp.c        ****     MATSUSHITA_COMMAND_OFFSET,                                          // command_offset:  command
1377:irmp.c        ****     MATSUSHITA_COMMAND_OFFSET + MATSUSHITA_COMMAND_LEN,                 // command_end:     end of 
1378:irmp.c        ****     MATSUSHITA_COMPLETE_DATA_LEN,                                       // complete_len:    complet
1379:irmp.c        ****     MATSUSHITA_STOP_BIT,                                                // stop_bit:        flag: f
1380:irmp.c        ****     MATSUSHITA_LSB,                                                     // lsb_first:       flag: L
1381:irmp.c        ****     MATSUSHITA_FLAGS                                                    // flags:           some fl
1382:irmp.c        **** };
1383:irmp.c        **** 
1384:irmp.c        **** #endif
1385:irmp.c        **** 
1386:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
1387:irmp.c        **** 
1388:irmp.c        **** static const PROGMEM IRMP_PARAMETER kaseikyo_param =
1389:irmp.c        **** {
1390:irmp.c        ****     IRMP_KASEIKYO_PROTOCOL,                                             // protocol:        ir prot
1391:irmp.c        ****     KASEIKYO_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum
1392:irmp.c        ****     KASEIKYO_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum
1393:irmp.c        ****     KASEIKYO_1_PAUSE_LEN_MIN,                                           // pause_1_len_min: minimum
1394:irmp.c        ****     KASEIKYO_1_PAUSE_LEN_MAX,                                           // pause_1_len_max: maximum
1395:irmp.c        ****     KASEIKYO_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum
1396:irmp.c        ****     KASEIKYO_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum
1397:irmp.c        ****     KASEIKYO_0_PAUSE_LEN_MIN,                                           // pause_0_len_min: minimum
1398:irmp.c        ****     KASEIKYO_0_PAUSE_LEN_MAX,                                           // pause_0_len_max: maximum
1399:irmp.c        ****     KASEIKYO_ADDRESS_OFFSET,                                            // address_offset:  address
1400:irmp.c        ****     KASEIKYO_ADDRESS_OFFSET + KASEIKYO_ADDRESS_LEN,                     // address_end:     end of 
1401:irmp.c        ****     KASEIKYO_COMMAND_OFFSET,                                            // command_offset:  command
1402:irmp.c        ****     KASEIKYO_COMMAND_OFFSET + KASEIKYO_COMMAND_LEN,                     // command_end:     end of 
1403:irmp.c        ****     KASEIKYO_COMPLETE_DATA_LEN,                                         // complete_len:    complet
1404:irmp.c        ****     KASEIKYO_STOP_BIT,                                                  // stop_bit:        flag: f
1405:irmp.c        ****     KASEIKYO_LSB,                                                       // lsb_first:       flag: L
1406:irmp.c        ****     KASEIKYO_FLAGS                                                      // flags:           some fl
1407:irmp.c        **** };
1408:irmp.c        **** 
1409:irmp.c        **** #endif
1410:irmp.c        **** 
1411:irmp.c        **** #if IRMP_SUPPORT_PANASONIC_PROTOCOL == 1
1412:irmp.c        **** 
1413:irmp.c        **** static const PROGMEM IRMP_PARAMETER panasonic_param =
1414:irmp.c        **** {
1415:irmp.c        ****     IRMP_PANASONIC_PROTOCOL,                                            // protocol:        ir prot
1416:irmp.c        ****     PANASONIC_PULSE_LEN_MIN,                                            // pulse_1_len_min: minimum
1417:irmp.c        ****     PANASONIC_PULSE_LEN_MAX,                                            // pulse_1_len_max: maximum
1418:irmp.c        ****     PANASONIC_1_PAUSE_LEN_MIN,                                          // pause_1_len_min: minimum
1419:irmp.c        ****     PANASONIC_1_PAUSE_LEN_MAX,                                          // pause_1_len_max: maximum
1420:irmp.c        ****     PANASONIC_PULSE_LEN_MIN,                                            // pulse_0_len_min: minimum
1421:irmp.c        ****     PANASONIC_PULSE_LEN_MAX,                                            // pulse_0_len_max: maximum
1422:irmp.c        ****     PANASONIC_0_PAUSE_LEN_MIN,                                          // pause_0_len_min: minimum
1423:irmp.c        ****     PANASONIC_0_PAUSE_LEN_MAX,                                          // pause_0_len_max: maximum
1424:irmp.c        ****     PANASONIC_ADDRESS_OFFSET,                                           // address_offset:  address
1425:irmp.c        ****     PANASONIC_ADDRESS_OFFSET + PANASONIC_ADDRESS_LEN,                   // address_end:     end of 
1426:irmp.c        ****     PANASONIC_COMMAND_OFFSET,                                           // command_offset:  command
1427:irmp.c        ****     PANASONIC_COMMAND_OFFSET + PANASONIC_COMMAND_LEN,                   // command_end:     end of 
1428:irmp.c        ****     PANASONIC_COMPLETE_DATA_LEN,                                        // complete_len:    complet
1429:irmp.c        ****     PANASONIC_STOP_BIT,                                                 // stop_bit:        flag: f
1430:irmp.c        ****     PANASONIC_LSB,                                                      // lsb_first:       flag: L
1431:irmp.c        ****     PANASONIC_FLAGS                                                     // flags:           some fl
1432:irmp.c        **** };
1433:irmp.c        **** 
1434:irmp.c        **** #endif
1435:irmp.c        **** 
1436:irmp.c        **** #if IRMP_SUPPORT_MITSU_HEAVY_PROTOCOL == 1
1437:irmp.c        **** 
1438:irmp.c        **** static const PROGMEM IRMP_PARAMETER mitsu_heavy_param =
1439:irmp.c        **** {
1440:irmp.c        ****     IRMP_MITSU_HEAVY_PROTOCOL,                                          // protocol:        ir prot
1441:irmp.c        ****     MITSU_HEAVY_PULSE_LEN_MIN,                                          // pulse_1_len_min: minimum
1442:irmp.c        ****     MITSU_HEAVY_PULSE_LEN_MAX,                                          // pulse_1_len_max: maximum
1443:irmp.c        ****     MITSU_HEAVY_1_PAUSE_LEN_MIN,                                        // pause_1_len_min: minimum
1444:irmp.c        ****     MITSU_HEAVY_1_PAUSE_LEN_MAX,                                        // pause_1_len_max: maximum
1445:irmp.c        ****     MITSU_HEAVY_PULSE_LEN_MIN,                                          // pulse_0_len_min: minimum
1446:irmp.c        ****     MITSU_HEAVY_PULSE_LEN_MAX,                                          // pulse_0_len_max: maximum
1447:irmp.c        ****     MITSU_HEAVY_0_PAUSE_LEN_MIN,                                        // pause_0_len_min: minimum
1448:irmp.c        ****     MITSU_HEAVY_0_PAUSE_LEN_MAX,                                        // pause_0_len_max: maximum
1449:irmp.c        ****     MITSU_HEAVY_ADDRESS_OFFSET,                                         // address_offset:  address
1450:irmp.c        ****     MITSU_HEAVY_ADDRESS_OFFSET + MITSU_HEAVY_ADDRESS_LEN,               // address_end:     end of 
1451:irmp.c        ****     MITSU_HEAVY_COMMAND_OFFSET,                                         // command_offset:  command
1452:irmp.c        ****     MITSU_HEAVY_COMMAND_OFFSET + MITSU_HEAVY_COMMAND_LEN,               // command_end:     end of 
1453:irmp.c        ****     MITSU_HEAVY_COMPLETE_DATA_LEN,                                      // complete_len:    complet
1454:irmp.c        ****     MITSU_HEAVY_STOP_BIT,                                               // stop_bit:        flag: f
1455:irmp.c        ****     MITSU_HEAVY_LSB,                                                    // lsb_first:       flag: L
1456:irmp.c        ****     MITSU_HEAVY_FLAGS                                                   // flags:           some fl
1457:irmp.c        **** };
1458:irmp.c        **** 
1459:irmp.c        **** #endif
1460:irmp.c        **** 
1461:irmp.c        **** #if IRMP_SUPPORT_VINCENT_PROTOCOL == 1
1462:irmp.c        **** 
1463:irmp.c        **** static const PROGMEM IRMP_PARAMETER vincent_param =
1464:irmp.c        **** {
1465:irmp.c        ****     IRMP_VINCENT_PROTOCOL,                                              // protocol:        ir prot
1466:irmp.c        ****     VINCENT_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum
1467:irmp.c        ****     VINCENT_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum
1468:irmp.c        ****     VINCENT_1_PAUSE_LEN_MIN,                                            // pause_1_len_min: minimum
1469:irmp.c        ****     VINCENT_1_PAUSE_LEN_MAX,                                            // pause_1_len_max: maximum
1470:irmp.c        ****     VINCENT_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum
1471:irmp.c        ****     VINCENT_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum
1472:irmp.c        ****     VINCENT_0_PAUSE_LEN_MIN,                                            // pause_0_len_min: minimum
1473:irmp.c        ****     VINCENT_0_PAUSE_LEN_MAX,                                            // pause_0_len_max: maximum
1474:irmp.c        ****     VINCENT_ADDRESS_OFFSET,                                             // address_offset:  address
1475:irmp.c        ****     VINCENT_ADDRESS_OFFSET + VINCENT_ADDRESS_LEN,                       // address_end:     end of 
1476:irmp.c        ****     VINCENT_COMMAND_OFFSET,                                             // command_offset:  command
1477:irmp.c        ****     VINCENT_COMMAND_OFFSET + VINCENT_COMMAND_LEN,                       // command_end:     end of 
1478:irmp.c        ****     VINCENT_COMPLETE_DATA_LEN,                                          // complete_len:    complet
1479:irmp.c        ****     VINCENT_STOP_BIT,                                                   // stop_bit:        flag: f
1480:irmp.c        ****     VINCENT_LSB,                                                        // lsb_first:       flag: L
1481:irmp.c        ****     VINCENT_FLAGS                                                       // flags:           some fl
1482:irmp.c        **** };
1483:irmp.c        **** 
1484:irmp.c        **** #endif
1485:irmp.c        **** 
1486:irmp.c        **** #if IRMP_SUPPORT_RECS80_PROTOCOL == 1
1487:irmp.c        **** 
1488:irmp.c        **** static const PROGMEM IRMP_PARAMETER recs80_param =
1489:irmp.c        **** {
1490:irmp.c        ****     IRMP_RECS80_PROTOCOL,                                               // protocol:        ir prot
1491:irmp.c        ****     RECS80_PULSE_LEN_MIN,                                               // pulse_1_len_min: minimum
1492:irmp.c        ****     RECS80_PULSE_LEN_MAX,                                               // pulse_1_len_max: maximum
1493:irmp.c        ****     RECS80_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum
1494:irmp.c        ****     RECS80_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum
1495:irmp.c        ****     RECS80_PULSE_LEN_MIN,                                               // pulse_0_len_min: minimum
1496:irmp.c        ****     RECS80_PULSE_LEN_MAX,                                               // pulse_0_len_max: maximum
1497:irmp.c        ****     RECS80_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum
1498:irmp.c        ****     RECS80_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum
1499:irmp.c        ****     RECS80_ADDRESS_OFFSET,                                              // address_offset:  address
1500:irmp.c        ****     RECS80_ADDRESS_OFFSET + RECS80_ADDRESS_LEN,                         // address_end:     end of 
1501:irmp.c        ****     RECS80_COMMAND_OFFSET,                                              // command_offset:  command
1502:irmp.c        ****     RECS80_COMMAND_OFFSET + RECS80_COMMAND_LEN,                         // command_end:     end of 
1503:irmp.c        ****     RECS80_COMPLETE_DATA_LEN,                                           // complete_len:    complet
1504:irmp.c        ****     RECS80_STOP_BIT,                                                    // stop_bit:        flag: f
1505:irmp.c        ****     RECS80_LSB,                                                         // lsb_first:       flag: L
1506:irmp.c        ****     RECS80_FLAGS                                                        // flags:           some fl
1507:irmp.c        **** };
1508:irmp.c        **** 
1509:irmp.c        **** #endif
1510:irmp.c        **** 
1511:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1
1512:irmp.c        **** 
1513:irmp.c        **** static const PROGMEM IRMP_PARAMETER rc5_param =
1514:irmp.c        **** {
1515:irmp.c        ****     IRMP_RC5_PROTOCOL,                                                  // protocol:        ir prot
1516:irmp.c        ****     RC5_BIT_LEN_MIN,                                                    // pulse_1_len_min: here: m
1517:irmp.c        ****     RC5_BIT_LEN_MAX,                                                    // pulse_1_len_max: here: m
1518:irmp.c        ****     RC5_BIT_LEN_MIN,                                                    // pause_1_len_min: here: m
1519:irmp.c        ****     RC5_BIT_LEN_MAX,                                                    // pause_1_len_max: here: m
1520:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
1521:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
1522:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1523:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1524:irmp.c        ****     RC5_ADDRESS_OFFSET,                                                 // address_offset:  address
1525:irmp.c        ****     RC5_ADDRESS_OFFSET + RC5_ADDRESS_LEN,                               // address_end:     end of 
1526:irmp.c        ****     RC5_COMMAND_OFFSET,                                                 // command_offset:  command
1527:irmp.c        ****     RC5_COMMAND_OFFSET + RC5_COMMAND_LEN,                               // command_end:     end of 
1528:irmp.c        ****     RC5_COMPLETE_DATA_LEN,                                              // complete_len:    complet
1529:irmp.c        ****     RC5_STOP_BIT,                                                       // stop_bit:        flag: f
1530:irmp.c        ****     RC5_LSB,                                                            // lsb_first:       flag: L
1531:irmp.c        ****     RC5_FLAGS                                                           // flags:           some fl
1532:irmp.c        **** };
1533:irmp.c        **** 
1534:irmp.c        **** #endif
1535:irmp.c        **** 
1536:irmp.c        **** #if IRMP_SUPPORT_RCII_PROTOCOL == 1
1537:irmp.c        **** 
1538:irmp.c        **** static const PROGMEM IRMP_PARAMETER rcii_param =
1539:irmp.c        **** {
1540:irmp.c        ****     IRMP_RCII_PROTOCOL,                                                 // protocol:        ir prot
1541:irmp.c        ****     RCII_BIT_LEN_MIN,                                                   // pulse_1_len_min: here: m
1542:irmp.c        ****     RCII_BIT_LEN_MAX,                                                   // pulse_1_len_max: here: m
1543:irmp.c        ****     RCII_BIT_LEN_MIN,                                                   // pause_1_len_min: here: m
1544:irmp.c        ****     RCII_BIT_LEN_MAX,                                                   // pause_1_len_max: here: m
1545:irmp.c        ****     RCII_BIT_LEN_MIN,                                                                  // pulse_0_l
1546:irmp.c        ****     RCII_BIT_LEN_MAX,                                                                  // pulse_0_l
1547:irmp.c        ****     RCII_BIT_LEN_MIN,                                                                  // pause_0_l
1548:irmp.c        ****     RCII_BIT_LEN_MAX,                                                                  // pause_0_l
1549:irmp.c        ****     RCII_ADDRESS_OFFSET,                                                // address_offset:  address
1550:irmp.c        ****     RCII_ADDRESS_OFFSET + RCII_ADDRESS_LEN,                             // address_end:     end of 
1551:irmp.c        ****     RCII_COMMAND_OFFSET,                                                // command_offset:  command
1552:irmp.c        ****     RCII_COMMAND_OFFSET + RCII_COMMAND_LEN,                             // command_end:     end of 
1553:irmp.c        ****     RCII_COMPLETE_DATA_LEN,                                             // complete_len:    complet
1554:irmp.c        ****     RCII_STOP_BIT,                                                      // stop_bit:        flag: f
1555:irmp.c        ****     RCII_LSB,                                                           // lsb_first:       flag: L
1556:irmp.c        ****     RCII_FLAGS                                                          // flags:           some fl
1557:irmp.c        **** };
1558:irmp.c        **** 
1559:irmp.c        **** #endif
1560:irmp.c        **** 
1561:irmp.c        **** #if IRMP_SUPPORT_S100_PROTOCOL == 1
1562:irmp.c        **** 
1563:irmp.c        **** static const PROGMEM IRMP_PARAMETER s100_param =
1564:irmp.c        **** {
1565:irmp.c        ****     IRMP_S100_PROTOCOL,                                                 // protocol:        ir prot
1566:irmp.c        ****     S100_BIT_LEN_MIN,                                                   // pulse_1_len_min: here: m
1567:irmp.c        ****     S100_BIT_LEN_MAX,                                                   // pulse_1_len_max: here: m
1568:irmp.c        ****     S100_BIT_LEN_MIN,                                                   // pause_1_len_min: here: m
1569:irmp.c        ****     S100_BIT_LEN_MAX,                                                   // pause_1_len_max: here: m
1570:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
1571:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
1572:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1573:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1574:irmp.c        ****     S100_ADDRESS_OFFSET,                                                // address_offset:  address
1575:irmp.c        ****     S100_ADDRESS_OFFSET + S100_ADDRESS_LEN,                             // address_end:     end of 
1576:irmp.c        ****     S100_COMMAND_OFFSET,                                                // command_offset:  command
1577:irmp.c        ****     S100_COMMAND_OFFSET + S100_COMMAND_LEN,                             // command_end:     end of 
1578:irmp.c        ****     S100_COMPLETE_DATA_LEN,                                             // complete_len:    complet
1579:irmp.c        ****     S100_STOP_BIT,                                                      // stop_bit:        flag: f
1580:irmp.c        ****     S100_LSB,                                                           // lsb_first:       flag: L
1581:irmp.c        ****     S100_FLAGS                                                          // flags:           some fl
1582:irmp.c        **** };
1583:irmp.c        **** 
1584:irmp.c        **** #endif
1585:irmp.c        **** 
1586:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
1587:irmp.c        **** 
1588:irmp.c        **** static const PROGMEM IRMP_PARAMETER denon_param =
1589:irmp.c        **** {
1590:irmp.c        ****     IRMP_DENON_PROTOCOL,                                                // protocol:        ir prot
1591:irmp.c        ****     DENON_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum
1592:irmp.c        ****     DENON_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum
1593:irmp.c        ****     DENON_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum
1594:irmp.c        ****     DENON_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum
1595:irmp.c        ****     DENON_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum
1596:irmp.c        ****     DENON_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum
1597:irmp.c        ****     DENON_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum
1598:irmp.c        ****     DENON_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum
1599:irmp.c        ****     DENON_ADDRESS_OFFSET,                                               // address_offset:  address
1600:irmp.c        ****     DENON_ADDRESS_OFFSET + DENON_ADDRESS_LEN,                           // address_end:     end of 
1601:irmp.c        ****     DENON_COMMAND_OFFSET,                                               // command_offset:  command
1602:irmp.c        ****     DENON_COMMAND_OFFSET + DENON_COMMAND_LEN,                           // command_end:     end of 
1603:irmp.c        ****     DENON_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1604:irmp.c        ****     DENON_STOP_BIT,                                                     // stop_bit:        flag: f
1605:irmp.c        ****     DENON_LSB,                                                          // lsb_first:       flag: L
1606:irmp.c        ****     DENON_FLAGS                                                         // flags:           some fl
1607:irmp.c        **** };
1608:irmp.c        **** 
1609:irmp.c        **** #endif
1610:irmp.c        **** 
1611:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
1612:irmp.c        **** 
1613:irmp.c        **** static const PROGMEM IRMP_PARAMETER rc6_param =
1614:irmp.c        **** {
1615:irmp.c        ****     IRMP_RC6_PROTOCOL,                                                  // protocol:        ir prot
1616:irmp.c        **** 
1617:irmp.c        ****     RC6_BIT_PULSE_LEN_MIN,                                              // pulse_1_len_min: here: m
1618:irmp.c        ****     RC6_BIT_PULSE_LEN_MAX,                                              // pulse_1_len_max: here: m
1619:irmp.c        ****     RC6_BIT_PAUSE_LEN_MIN,                                              // pause_1_len_min: here: m
1620:irmp.c        ****     RC6_BIT_PAUSE_LEN_MAX,                                              // pause_1_len_max: here: m
1621:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
1622:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
1623:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1624:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1625:irmp.c        ****     RC6_ADDRESS_OFFSET,                                                 // address_offset:  address
1626:irmp.c        ****     RC6_ADDRESS_OFFSET + RC6_ADDRESS_LEN,                               // address_end:     end of 
1627:irmp.c        ****     RC6_COMMAND_OFFSET,                                                 // command_offset:  command
1628:irmp.c        ****     RC6_COMMAND_OFFSET + RC6_COMMAND_LEN,                               // command_end:     end of 
1629:irmp.c        ****     RC6_COMPLETE_DATA_LEN_SHORT,                                        // complete_len:    complet
1630:irmp.c        ****     RC6_STOP_BIT,                                                       // stop_bit:        flag: f
1631:irmp.c        ****     RC6_LSB,                                                            // lsb_first:       flag: L
1632:irmp.c        ****     RC6_FLAGS                                                           // flags:           some fl
1633:irmp.c        **** };
1634:irmp.c        **** 
1635:irmp.c        **** #endif
1636:irmp.c        **** 
1637:irmp.c        **** #if IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
1638:irmp.c        **** 
1639:irmp.c        **** static const PROGMEM IRMP_PARAMETER recs80ext_param =
1640:irmp.c        **** {
1641:irmp.c        ****     IRMP_RECS80EXT_PROTOCOL,                                            // protocol:        ir prot
1642:irmp.c        ****     RECS80EXT_PULSE_LEN_MIN,                                            // pulse_1_len_min: minimum
1643:irmp.c        ****     RECS80EXT_PULSE_LEN_MAX,                                            // pulse_1_len_max: maximum
1644:irmp.c        ****     RECS80EXT_1_PAUSE_LEN_MIN,                                          // pause_1_len_min: minimum
1645:irmp.c        ****     RECS80EXT_1_PAUSE_LEN_MAX,                                          // pause_1_len_max: maximum
1646:irmp.c        ****     RECS80EXT_PULSE_LEN_MIN,                                            // pulse_0_len_min: minimum
1647:irmp.c        ****     RECS80EXT_PULSE_LEN_MAX,                                            // pulse_0_len_max: maximum
1648:irmp.c        ****     RECS80EXT_0_PAUSE_LEN_MIN,                                          // pause_0_len_min: minimum
1649:irmp.c        ****     RECS80EXT_0_PAUSE_LEN_MAX,                                          // pause_0_len_max: maximum
1650:irmp.c        ****     RECS80EXT_ADDRESS_OFFSET,                                           // address_offset:  address
1651:irmp.c        ****     RECS80EXT_ADDRESS_OFFSET + RECS80EXT_ADDRESS_LEN,                   // address_end:     end of 
1652:irmp.c        ****     RECS80EXT_COMMAND_OFFSET,                                           // command_offset:  command
1653:irmp.c        ****     RECS80EXT_COMMAND_OFFSET + RECS80EXT_COMMAND_LEN,                   // command_end:     end of 
1654:irmp.c        ****     RECS80EXT_COMPLETE_DATA_LEN,                                        // complete_len:    complet
1655:irmp.c        ****     RECS80EXT_STOP_BIT,                                                 // stop_bit:        flag: f
1656:irmp.c        ****     RECS80EXT_LSB,                                                      // lsb_first:       flag: L
1657:irmp.c        ****     RECS80EXT_FLAGS                                                     // flags:           some fl
1658:irmp.c        **** };
1659:irmp.c        **** 
1660:irmp.c        **** #endif
1661:irmp.c        **** 
1662:irmp.c        **** #if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
1663:irmp.c        **** 
1664:irmp.c        **** static const PROGMEM IRMP_PARAMETER nubert_param =
1665:irmp.c        **** {
1666:irmp.c        ****     IRMP_NUBERT_PROTOCOL,                                               // protocol:        ir prot
1667:irmp.c        ****     NUBERT_1_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum
1668:irmp.c        ****     NUBERT_1_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum
1669:irmp.c        ****     NUBERT_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum
1670:irmp.c        ****     NUBERT_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum
1671:irmp.c        ****     NUBERT_0_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum
1672:irmp.c        ****     NUBERT_0_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum
1673:irmp.c        ****     NUBERT_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum
1674:irmp.c        ****     NUBERT_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum
1675:irmp.c        ****     NUBERT_ADDRESS_OFFSET,                                              // address_offset:  address
1676:irmp.c        ****     NUBERT_ADDRESS_OFFSET + NUBERT_ADDRESS_LEN,                         // address_end:     end of 
1677:irmp.c        ****     NUBERT_COMMAND_OFFSET,                                              // command_offset:  command
1678:irmp.c        ****     NUBERT_COMMAND_OFFSET + NUBERT_COMMAND_LEN,                         // command_end:     end of 
1679:irmp.c        ****     NUBERT_COMPLETE_DATA_LEN,                                           // complete_len:    complet
1680:irmp.c        ****     NUBERT_STOP_BIT,                                                    // stop_bit:        flag: f
1681:irmp.c        ****     NUBERT_LSB,                                                         // lsb_first:       flag: L
1682:irmp.c        ****     NUBERT_FLAGS                                                        // flags:           some fl
1683:irmp.c        **** };
1684:irmp.c        **** 
1685:irmp.c        **** #endif
1686:irmp.c        **** 
1687:irmp.c        **** #if IRMP_SUPPORT_FAN_PROTOCOL == 1
1688:irmp.c        **** 
1689:irmp.c        **** static const PROGMEM IRMP_PARAMETER fan_param =
1690:irmp.c        **** {
1691:irmp.c        ****     IRMP_FAN_PROTOCOL,                                                  // protocol:        ir prot
1692:irmp.c        ****     FAN_1_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum
1693:irmp.c        ****     FAN_1_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum
1694:irmp.c        ****     FAN_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
1695:irmp.c        ****     FAN_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
1696:irmp.c        ****     FAN_0_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum
1697:irmp.c        ****     FAN_0_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum
1698:irmp.c        ****     FAN_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
1699:irmp.c        ****     FAN_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
1700:irmp.c        ****     FAN_ADDRESS_OFFSET,                                                 // address_offset:  address
1701:irmp.c        ****     FAN_ADDRESS_OFFSET + FAN_ADDRESS_LEN,                               // address_end:     end of 
1702:irmp.c        ****     FAN_COMMAND_OFFSET,                                                 // command_offset:  command
1703:irmp.c        ****     FAN_COMMAND_OFFSET + FAN_COMMAND_LEN,                               // command_end:     end of 
1704:irmp.c        ****     FAN_COMPLETE_DATA_LEN,                                              // complete_len:    complet
1705:irmp.c        ****     FAN_STOP_BIT,                                                       // stop_bit:        flag: f
1706:irmp.c        ****     FAN_LSB,                                                            // lsb_first:       flag: L
1707:irmp.c        ****     FAN_FLAGS                                                           // flags:           some fl
1708:irmp.c        **** };
1709:irmp.c        **** 
1710:irmp.c        **** #endif
1711:irmp.c        **** 
1712:irmp.c        **** #if IRMP_SUPPORT_SPEAKER_PROTOCOL == 1
1713:irmp.c        **** 
1714:irmp.c        **** static const PROGMEM IRMP_PARAMETER speaker_param =
1715:irmp.c        **** {
1716:irmp.c        ****     IRMP_SPEAKER_PROTOCOL,                                              // protocol:        ir prot
1717:irmp.c        ****     SPEAKER_1_PULSE_LEN_MIN,                                            // pulse_1_len_min: minimum
1718:irmp.c        ****     SPEAKER_1_PULSE_LEN_MAX,                                            // pulse_1_len_max: maximum
1719:irmp.c        ****     SPEAKER_1_PAUSE_LEN_MIN,                                            // pause_1_len_min: minimum
1720:irmp.c        ****     SPEAKER_1_PAUSE_LEN_MAX,                                            // pause_1_len_max: maximum
1721:irmp.c        ****     SPEAKER_0_PULSE_LEN_MIN,                                            // pulse_0_len_min: minimum
1722:irmp.c        ****     SPEAKER_0_PULSE_LEN_MAX,                                            // pulse_0_len_max: maximum
1723:irmp.c        ****     SPEAKER_0_PAUSE_LEN_MIN,                                            // pause_0_len_min: minimum
1724:irmp.c        ****     SPEAKER_0_PAUSE_LEN_MAX,                                            // pause_0_len_max: maximum
1725:irmp.c        ****     SPEAKER_ADDRESS_OFFSET,                                             // address_offset:  address
1726:irmp.c        ****     SPEAKER_ADDRESS_OFFSET + SPEAKER_ADDRESS_LEN,                       // address_end:     end of 
1727:irmp.c        ****     SPEAKER_COMMAND_OFFSET,                                             // command_offset:  command
1728:irmp.c        ****     SPEAKER_COMMAND_OFFSET + SPEAKER_COMMAND_LEN,                       // command_end:     end of 
1729:irmp.c        ****     SPEAKER_COMPLETE_DATA_LEN,                                          // complete_len:    complet
1730:irmp.c        ****     SPEAKER_STOP_BIT,                                                   // stop_bit:        flag: f
1731:irmp.c        ****     SPEAKER_LSB,                                                        // lsb_first:       flag: L
1732:irmp.c        ****     SPEAKER_FLAGS                                                       // flags:           some fl
1733:irmp.c        **** };
1734:irmp.c        **** 
1735:irmp.c        **** #endif
1736:irmp.c        **** 
1737:irmp.c        **** #if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
1738:irmp.c        **** 
1739:irmp.c        **** static const PROGMEM IRMP_PARAMETER bang_olufsen_param =
1740:irmp.c        **** {
1741:irmp.c        ****     IRMP_BANG_OLUFSEN_PROTOCOL,                                         // protocol:        ir prot
1742:irmp.c        ****     BANG_OLUFSEN_PULSE_LEN_MIN,                                         // pulse_1_len_min: minimum
1743:irmp.c        ****     BANG_OLUFSEN_PULSE_LEN_MAX,                                         // pulse_1_len_max: maximum
1744:irmp.c        ****     BANG_OLUFSEN_1_PAUSE_LEN_MIN,                                       // pause_1_len_min: minimum
1745:irmp.c        ****     BANG_OLUFSEN_1_PAUSE_LEN_MAX,                                       // pause_1_len_max: maximum
1746:irmp.c        ****     BANG_OLUFSEN_PULSE_LEN_MIN,                                         // pulse_0_len_min: minimum
1747:irmp.c        ****     BANG_OLUFSEN_PULSE_LEN_MAX,                                         // pulse_0_len_max: maximum
1748:irmp.c        ****     BANG_OLUFSEN_0_PAUSE_LEN_MIN,                                       // pause_0_len_min: minimum
1749:irmp.c        ****     BANG_OLUFSEN_0_PAUSE_LEN_MAX,                                       // pause_0_len_max: maximum
1750:irmp.c        ****     BANG_OLUFSEN_ADDRESS_OFFSET,                                        // address_offset:  address
1751:irmp.c        ****     BANG_OLUFSEN_ADDRESS_OFFSET + BANG_OLUFSEN_ADDRESS_LEN,             // address_end:     end of 
1752:irmp.c        ****     BANG_OLUFSEN_COMMAND_OFFSET,                                        // command_offset:  command
1753:irmp.c        ****     BANG_OLUFSEN_COMMAND_OFFSET + BANG_OLUFSEN_COMMAND_LEN,             // command_end:     end of 
1754:irmp.c        ****     BANG_OLUFSEN_COMPLETE_DATA_LEN,                                     // complete_len:    complet
1755:irmp.c        ****     BANG_OLUFSEN_STOP_BIT,                                              // stop_bit:        flag: f
1756:irmp.c        ****     BANG_OLUFSEN_LSB,                                                   // lsb_first:       flag: L
1757:irmp.c        ****     BANG_OLUFSEN_FLAGS                                                  // flags:           some fl
1758:irmp.c        **** };
1759:irmp.c        **** 
1760:irmp.c        **** #endif
1761:irmp.c        **** 
1762:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
1763:irmp.c        **** 
1764:irmp.c        **** static uint_fast8_t first_bit;
1765:irmp.c        **** 
1766:irmp.c        **** static const PROGMEM IRMP_PARAMETER grundig_param =
1767:irmp.c        **** {
1768:irmp.c        ****     IRMP_GRUNDIG_PROTOCOL,                                              // protocol:        ir prot
1769:irmp.c        **** 
1770:irmp.c        ****     GRUNDIG_NOKIA_IR60_BIT_LEN_MIN,                                     // pulse_1_len_min: here: m
1771:irmp.c        ****     GRUNDIG_NOKIA_IR60_BIT_LEN_MAX,                                     // pulse_1_len_max: here: m
1772:irmp.c        ****     GRUNDIG_NOKIA_IR60_BIT_LEN_MIN,                                     // pause_1_len_min: here: m
1773:irmp.c        ****     GRUNDIG_NOKIA_IR60_BIT_LEN_MAX,                                     // pause_1_len_max: here: m
1774:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
1775:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
1776:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1777:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1778:irmp.c        ****     GRUNDIG_ADDRESS_OFFSET,                                             // address_offset:  address
1779:irmp.c        ****     GRUNDIG_ADDRESS_OFFSET + GRUNDIG_ADDRESS_LEN,                       // address_end:     end of 
1780:irmp.c        ****     GRUNDIG_COMMAND_OFFSET,                                             // command_offset:  command
1781:irmp.c        ****     GRUNDIG_COMMAND_OFFSET + GRUNDIG_COMMAND_LEN + 1,                   // command_end:     end of 
1782:irmp.c        ****     NOKIA_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1783:irmp.c        ****     GRUNDIG_NOKIA_IR60_STOP_BIT,                                        // stop_bit:        flag: f
1784:irmp.c        ****     GRUNDIG_NOKIA_IR60_LSB,                                             // lsb_first:       flag: L
1785:irmp.c        ****     GRUNDIG_NOKIA_IR60_FLAGS                                            // flags:           some fl
1786:irmp.c        **** };
1787:irmp.c        **** 
1788:irmp.c        **** #endif
1789:irmp.c        **** 
1790:irmp.c        **** #if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
1791:irmp.c        **** 
1792:irmp.c        **** static const PROGMEM IRMP_PARAMETER ruwido_param =
1793:irmp.c        **** {
1794:irmp.c        ****     IRMP_RUWIDO_PROTOCOL,                                               // protocol:        ir prot
1795:irmp.c        ****     SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN,                                // pulse_1_len_min: here: m
1796:irmp.c        ****     SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX,                                // pulse_1_len_max: here: m
1797:irmp.c        ****     SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN,                                // pause_1_len_min: here: m
1798:irmp.c        ****     SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX,                                // pause_1_len_max: here: m
1799:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
1800:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
1801:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
1802:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
1803:irmp.c        ****     RUWIDO_ADDRESS_OFFSET,                                              // address_offset:  address
1804:irmp.c        ****     RUWIDO_ADDRESS_OFFSET + RUWIDO_ADDRESS_LEN,                         // address_end:     end of 
1805:irmp.c        ****     RUWIDO_COMMAND_OFFSET,                                              // command_offset:  command
1806:irmp.c        ****     RUWIDO_COMMAND_OFFSET + RUWIDO_COMMAND_LEN,                         // command_end:     end of 
1807:irmp.c        ****     SIEMENS_COMPLETE_DATA_LEN,                                          // complete_len:    complet
1808:irmp.c        ****     SIEMENS_OR_RUWIDO_STOP_BIT,                                         // stop_bit:        flag: f
1809:irmp.c        ****     SIEMENS_OR_RUWIDO_LSB,                                              // lsb_first:       flag: L
1810:irmp.c        ****     SIEMENS_OR_RUWIDO_FLAGS                                             // flags:           some fl
1811:irmp.c        **** };
1812:irmp.c        **** 
1813:irmp.c        **** #endif
1814:irmp.c        **** 
1815:irmp.c        **** #if IRMP_SUPPORT_FDC_PROTOCOL == 1
1816:irmp.c        **** 
1817:irmp.c        **** static const PROGMEM IRMP_PARAMETER fdc_param =
1818:irmp.c        **** {
1819:irmp.c        ****     IRMP_FDC_PROTOCOL,                                                  // protocol:        ir prot
1820:irmp.c        ****     FDC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum
1821:irmp.c        ****     FDC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum
1822:irmp.c        ****     FDC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum
1823:irmp.c        ****     FDC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum
1824:irmp.c        ****     FDC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum
1825:irmp.c        ****     FDC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum
1826:irmp.c        ****     FDC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum
1827:irmp.c        ****     FDC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum
1828:irmp.c        ****     FDC_ADDRESS_OFFSET,                                                 // address_offset:  address
1829:irmp.c        ****     FDC_ADDRESS_OFFSET + FDC_ADDRESS_LEN,                               // address_end:     end of 
1830:irmp.c        ****     FDC_COMMAND_OFFSET,                                                 // command_offset:  command
1831:irmp.c        ****     FDC_COMMAND_OFFSET + FDC_COMMAND_LEN,                               // command_end:     end of 
1832:irmp.c        ****     FDC_COMPLETE_DATA_LEN,                                              // complete_len:    complet
1833:irmp.c        ****     FDC_STOP_BIT,                                                       // stop_bit:        flag: f
1834:irmp.c        ****     FDC_LSB,                                                            // lsb_first:       flag: L
1835:irmp.c        ****     FDC_FLAGS                                                           // flags:           some fl
1836:irmp.c        **** };
1837:irmp.c        **** 
1838:irmp.c        **** #endif
1839:irmp.c        **** 
1840:irmp.c        **** #if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
1841:irmp.c        **** 
1842:irmp.c        **** static const PROGMEM IRMP_PARAMETER rccar_param =
1843:irmp.c        **** {
1844:irmp.c        ****     IRMP_RCCAR_PROTOCOL,                                                // protocol:        ir prot
1845:irmp.c        ****     RCCAR_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum
1846:irmp.c        ****     RCCAR_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum
1847:irmp.c        ****     RCCAR_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum
1848:irmp.c        ****     RCCAR_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum
1849:irmp.c        ****     RCCAR_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum
1850:irmp.c        ****     RCCAR_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum
1851:irmp.c        ****     RCCAR_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum
1852:irmp.c        ****     RCCAR_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum
1853:irmp.c        ****     RCCAR_ADDRESS_OFFSET,                                               // address_offset:  address
1854:irmp.c        ****     RCCAR_ADDRESS_OFFSET + RCCAR_ADDRESS_LEN,                           // address_end:     end of 
1855:irmp.c        ****     RCCAR_COMMAND_OFFSET,                                               // command_offset:  command
1856:irmp.c        ****     RCCAR_COMMAND_OFFSET + RCCAR_COMMAND_LEN,                           // command_end:     end of 
1857:irmp.c        ****     RCCAR_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1858:irmp.c        ****     RCCAR_STOP_BIT,                                                     // stop_bit:        flag: f
1859:irmp.c        ****     RCCAR_LSB,                                                          // lsb_first:       flag: L
1860:irmp.c        ****     RCCAR_FLAGS                                                         // flags:           some fl
1861:irmp.c        **** };
1862:irmp.c        **** 
1863:irmp.c        **** #endif
1864:irmp.c        **** 
1865:irmp.c        **** #if IRMP_SUPPORT_NIKON_PROTOCOL == 1
1866:irmp.c        **** 
1867:irmp.c        **** static const PROGMEM IRMP_PARAMETER nikon_param =
1868:irmp.c        **** {
1869:irmp.c        ****     IRMP_NIKON_PROTOCOL,                                                // protocol:        ir prot
1870:irmp.c        ****     NIKON_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum
1871:irmp.c        ****     NIKON_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum
1872:irmp.c        ****     NIKON_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum
1873:irmp.c        ****     NIKON_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum
1874:irmp.c        ****     NIKON_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum
1875:irmp.c        ****     NIKON_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum
1876:irmp.c        ****     NIKON_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum
1877:irmp.c        ****     NIKON_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum
1878:irmp.c        ****     NIKON_ADDRESS_OFFSET,                                               // address_offset:  address
1879:irmp.c        ****     NIKON_ADDRESS_OFFSET + NIKON_ADDRESS_LEN,                           // address_end:     end of 
1880:irmp.c        ****     NIKON_COMMAND_OFFSET,                                               // command_offset:  command
1881:irmp.c        ****     NIKON_COMMAND_OFFSET + NIKON_COMMAND_LEN,                           // command_end:     end of 
1882:irmp.c        ****     NIKON_COMPLETE_DATA_LEN,                                            // complete_len:    complet
1883:irmp.c        ****     NIKON_STOP_BIT,                                                     // stop_bit:        flag: f
1884:irmp.c        ****     NIKON_LSB,                                                          // lsb_first:       flag: L
1885:irmp.c        ****     NIKON_FLAGS                                                         // flags:           some fl
1886:irmp.c        **** };
1887:irmp.c        **** 
1888:irmp.c        **** #endif
1889:irmp.c        **** 
1890:irmp.c        **** #if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
1891:irmp.c        **** 
1892:irmp.c        **** static const PROGMEM IRMP_PARAMETER kathrein_param =
1893:irmp.c        **** {
1894:irmp.c        ****     IRMP_KATHREIN_PROTOCOL,                                             // protocol:        ir prot
1895:irmp.c        ****     KATHREIN_1_PULSE_LEN_MIN,                                           // pulse_1_len_min: minimum
1896:irmp.c        ****     KATHREIN_1_PULSE_LEN_MAX,                                           // pulse_1_len_max: maximum
1897:irmp.c        ****     KATHREIN_1_PAUSE_LEN_MIN,                                           // pause_1_len_min: minimum
1898:irmp.c        ****     KATHREIN_1_PAUSE_LEN_MAX,                                           // pause_1_len_max: maximum
1899:irmp.c        ****     KATHREIN_0_PULSE_LEN_MIN,                                           // pulse_0_len_min: minimum
1900:irmp.c        ****     KATHREIN_0_PULSE_LEN_MAX,                                           // pulse_0_len_max: maximum
1901:irmp.c        ****     KATHREIN_0_PAUSE_LEN_MIN,                                           // pause_0_len_min: minimum
1902:irmp.c        ****     KATHREIN_0_PAUSE_LEN_MAX,                                           // pause_0_len_max: maximum
1903:irmp.c        ****     KATHREIN_ADDRESS_OFFSET,                                            // address_offset:  address
1904:irmp.c        ****     KATHREIN_ADDRESS_OFFSET + KATHREIN_ADDRESS_LEN,                     // address_end:     end of 
1905:irmp.c        ****     KATHREIN_COMMAND_OFFSET,                                            // command_offset:  command
1906:irmp.c        ****     KATHREIN_COMMAND_OFFSET + KATHREIN_COMMAND_LEN,                     // command_end:     end of 
1907:irmp.c        ****     KATHREIN_COMPLETE_DATA_LEN,                                         // complete_len:    complet
1908:irmp.c        ****     KATHREIN_STOP_BIT,                                                  // stop_bit:        flag: f
1909:irmp.c        ****     KATHREIN_LSB,                                                       // lsb_first:       flag: L
1910:irmp.c        ****     KATHREIN_FLAGS                                                      // flags:           some fl
1911:irmp.c        **** };
1912:irmp.c        **** 
1913:irmp.c        **** #endif
1914:irmp.c        **** 
1915:irmp.c        **** #if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
1916:irmp.c        **** 
1917:irmp.c        **** static const PROGMEM IRMP_PARAMETER netbox_param =
1918:irmp.c        **** {
1919:irmp.c        ****     IRMP_NETBOX_PROTOCOL,                                               // protocol:        ir prot
1920:irmp.c        ****     NETBOX_PULSE_LEN,                                                   // pulse_1_len_min: minimum
1921:irmp.c        ****     NETBOX_PULSE_REST_LEN,                                              // pulse_1_len_max: maximum
1922:irmp.c        ****     NETBOX_PAUSE_LEN,                                                   // pause_1_len_min: minimum
1923:irmp.c        ****     NETBOX_PAUSE_REST_LEN,                                              // pause_1_len_max: maximum
1924:irmp.c        ****     NETBOX_PULSE_LEN,                                                   // pulse_0_len_min: minimum
1925:irmp.c        ****     NETBOX_PULSE_REST_LEN,                                              // pulse_0_len_max: maximum
1926:irmp.c        ****     NETBOX_PAUSE_LEN,                                                   // pause_0_len_min: minimum
1927:irmp.c        ****     NETBOX_PAUSE_REST_LEN,                                              // pause_0_len_max: maximum
1928:irmp.c        ****     NETBOX_ADDRESS_OFFSET,                                              // address_offset:  address
1929:irmp.c        ****     NETBOX_ADDRESS_OFFSET + NETBOX_ADDRESS_LEN,                         // address_end:     end of 
1930:irmp.c        ****     NETBOX_COMMAND_OFFSET,                                              // command_offset:  command
1931:irmp.c        ****     NETBOX_COMMAND_OFFSET + NETBOX_COMMAND_LEN,                         // command_end:     end of 
1932:irmp.c        ****     NETBOX_COMPLETE_DATA_LEN,                                           // complete_len:    complet
1933:irmp.c        ****     NETBOX_STOP_BIT,                                                    // stop_bit:        flag: f
1934:irmp.c        ****     NETBOX_LSB,                                                         // lsb_first:       flag: L
1935:irmp.c        ****     NETBOX_FLAGS                                                        // flags:           some fl
1936:irmp.c        **** };
1937:irmp.c        **** 
1938:irmp.c        **** #endif
1939:irmp.c        **** 
1940:irmp.c        **** #if IRMP_SUPPORT_LEGO_PROTOCOL == 1
1941:irmp.c        **** 
1942:irmp.c        **** static const PROGMEM IRMP_PARAMETER lego_param =
1943:irmp.c        **** {
1944:irmp.c        ****     IRMP_LEGO_PROTOCOL,                                                 // protocol:        ir prot
1945:irmp.c        ****     LEGO_PULSE_LEN_MIN,                                                 // pulse_1_len_min: minimum
1946:irmp.c        ****     LEGO_PULSE_LEN_MAX,                                                 // pulse_1_len_max: maximum
1947:irmp.c        ****     LEGO_1_PAUSE_LEN_MIN,                                               // pause_1_len_min: minimum
1948:irmp.c        ****     LEGO_1_PAUSE_LEN_MAX,                                               // pause_1_len_max: maximum
1949:irmp.c        ****     LEGO_PULSE_LEN_MIN,                                                 // pulse_0_len_min: minimum
1950:irmp.c        ****     LEGO_PULSE_LEN_MAX,                                                 // pulse_0_len_max: maximum
1951:irmp.c        ****     LEGO_0_PAUSE_LEN_MIN,                                               // pause_0_len_min: minimum
1952:irmp.c        ****     LEGO_0_PAUSE_LEN_MAX,                                               // pause_0_len_max: maximum
1953:irmp.c        ****     LEGO_ADDRESS_OFFSET,                                                // address_offset:  address
1954:irmp.c        ****     LEGO_ADDRESS_OFFSET + LEGO_ADDRESS_LEN,                             // address_end:     end of 
1955:irmp.c        ****     LEGO_COMMAND_OFFSET,                                                // command_offset:  command
1956:irmp.c        ****     LEGO_COMMAND_OFFSET + LEGO_COMMAND_LEN,                             // command_end:     end of 
1957:irmp.c        ****     LEGO_COMPLETE_DATA_LEN,                                             // complete_len:    complet
1958:irmp.c        ****     LEGO_STOP_BIT,                                                      // stop_bit:        flag: f
1959:irmp.c        ****     LEGO_LSB,                                                           // lsb_first:       flag: L
1960:irmp.c        ****     LEGO_FLAGS                                                          // flags:           some fl
1961:irmp.c        **** };
1962:irmp.c        **** 
1963:irmp.c        **** #endif
1964:irmp.c        **** 
1965:irmp.c        **** #if IRMP_SUPPORT_IRMP16_PROTOCOL == 1
1966:irmp.c        **** 
1967:irmp.c        **** static const PROGMEM IRMP_PARAMETER irmp16_param =
1968:irmp.c        **** {
1969:irmp.c        ****     IRMP_IRMP16_PROTOCOL,                                               // protocol:        ir prot
1970:irmp.c        ****     IRMP16_PULSE_LEN_MIN,                                               // pulse_1_len_min: minimum
1971:irmp.c        ****     IRMP16_PULSE_LEN_MAX,                                               // pulse_1_len_max: maximum
1972:irmp.c        ****     IRMP16_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum
1973:irmp.c        ****     IRMP16_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum
1974:irmp.c        ****     IRMP16_PULSE_LEN_MIN,                                               // pulse_0_len_min: minimum
1975:irmp.c        ****     IRMP16_PULSE_LEN_MAX,                                               // pulse_0_len_max: maximum
1976:irmp.c        ****     IRMP16_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum
1977:irmp.c        ****     IRMP16_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum
1978:irmp.c        ****     IRMP16_ADDRESS_OFFSET,                                              // address_offset:  address
1979:irmp.c        ****     IRMP16_ADDRESS_OFFSET + IRMP16_ADDRESS_LEN,                         // address_end:     end of 
1980:irmp.c        ****     IRMP16_COMMAND_OFFSET,                                              // command_offset:  command
1981:irmp.c        ****     IRMP16_COMMAND_OFFSET + IRMP16_COMMAND_LEN,                         // command_end:     end of 
1982:irmp.c        ****     IRMP16_COMPLETE_DATA_LEN,                                           // complete_len:    complet
1983:irmp.c        ****     IRMP16_STOP_BIT,                                                    // stop_bit:        flag: f
1984:irmp.c        ****     IRMP16_LSB,                                                         // lsb_first:       flag: L
1985:irmp.c        ****     IRMP16_FLAGS                                                        // flags:           some fl
1986:irmp.c        **** };
1987:irmp.c        **** 
1988:irmp.c        **** #endif
1989:irmp.c        **** 
1990:irmp.c        **** #if IRMP_SUPPORT_GREE_PROTOCOL == 1
1991:irmp.c        **** 
1992:irmp.c        **** static const PROGMEM IRMP_PARAMETER gree_param =
1993:irmp.c        **** {
1994:irmp.c        ****     IRMP_GREE_PROTOCOL,                                               // protocol:        ir protoc
1995:irmp.c        ****     GREE_PULSE_LEN_MIN,                                               // pulse_1_len_min: minimum l
1996:irmp.c        ****     GREE_PULSE_LEN_MAX,                                               // pulse_1_len_max: maximum l
1997:irmp.c        ****     GREE_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum l
1998:irmp.c        ****     GREE_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum l
1999:irmp.c        ****     GREE_PULSE_LEN_MIN,                                               // pulse_0_len_min: minimum l
2000:irmp.c        ****     GREE_PULSE_LEN_MAX,                                               // pulse_0_len_max: maximum l
2001:irmp.c        ****     GREE_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum l
2002:irmp.c        ****     GREE_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum l
2003:irmp.c        ****     GREE_ADDRESS_OFFSET,                                              // address_offset:  address o
2004:irmp.c        ****     GREE_ADDRESS_OFFSET + GREE_ADDRESS_LEN,                         // address_end:     end of addr
2005:irmp.c        ****     GREE_COMMAND_OFFSET,                                              // command_offset:  command o
2006:irmp.c        ****     GREE_COMMAND_OFFSET + GREE_COMMAND_LEN,                         // command_end:     end of comm
2007:irmp.c        ****     GREE_COMPLETE_DATA_LEN,                                           // complete_len:    complete 
2008:irmp.c        ****     GREE_STOP_BIT,                                                    // stop_bit:        flag: fra
2009:irmp.c        ****     GREE_LSB,                                                         // lsb_first:       flag: LSB
2010:irmp.c        ****     GREE_FLAGS                                                        // flags:           some flag
2011:irmp.c        **** };
2012:irmp.c        **** 
2013:irmp.c        **** #endif
2014:irmp.c        **** 
2015:irmp.c        **** #if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
2016:irmp.c        **** 
2017:irmp.c        **** static const PROGMEM IRMP_PARAMETER thomson_param =
2018:irmp.c        **** {
2019:irmp.c        ****     IRMP_THOMSON_PROTOCOL,                                              // protocol:        ir prot
2020:irmp.c        ****     THOMSON_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum
2021:irmp.c        ****     THOMSON_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum
2022:irmp.c        ****     THOMSON_1_PAUSE_LEN_MIN,                                            // pause_1_len_min: minimum
2023:irmp.c        ****     THOMSON_1_PAUSE_LEN_MAX,                                            // pause_1_len_max: maximum
2024:irmp.c        ****     THOMSON_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum
2025:irmp.c        ****     THOMSON_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum
2026:irmp.c        ****     THOMSON_0_PAUSE_LEN_MIN,                                            // pause_0_len_min: minimum
2027:irmp.c        ****     THOMSON_0_PAUSE_LEN_MAX,                                            // pause_0_len_max: maximum
2028:irmp.c        ****     THOMSON_ADDRESS_OFFSET,                                             // address_offset:  address
2029:irmp.c        ****     THOMSON_ADDRESS_OFFSET + THOMSON_ADDRESS_LEN,                       // address_end:     end of 
2030:irmp.c        ****     THOMSON_COMMAND_OFFSET,                                             // command_offset:  command
2031:irmp.c        ****     THOMSON_COMMAND_OFFSET + THOMSON_COMMAND_LEN,                       // command_end:     end of 
2032:irmp.c        ****     THOMSON_COMPLETE_DATA_LEN,                                          // complete_len:    complet
2033:irmp.c        ****     THOMSON_STOP_BIT,                                                   // stop_bit:        flag: f
2034:irmp.c        ****     THOMSON_LSB,                                                        // lsb_first:       flag: L
2035:irmp.c        ****     THOMSON_FLAGS                                                       // flags:           some fl
2036:irmp.c        **** };
2037:irmp.c        **** 
2038:irmp.c        **** #endif
2039:irmp.c        **** 
2040:irmp.c        **** #if IRMP_SUPPORT_BOSE_PROTOCOL == 1
2041:irmp.c        **** 
2042:irmp.c        **** static const PROGMEM IRMP_PARAMETER bose_param =
2043:irmp.c        **** {
2044:irmp.c        ****     IRMP_BOSE_PROTOCOL,                                                 // protocol:        ir prot
2045:irmp.c        ****     BOSE_PULSE_LEN_MIN,                                                 // pulse_1_len_min: minimum
2046:irmp.c        ****     BOSE_PULSE_LEN_MAX,                                                 // pulse_1_len_max: maximum
2047:irmp.c        ****     BOSE_1_PAUSE_LEN_MIN,                                               // pause_1_len_min: minimum
2048:irmp.c        ****     BOSE_1_PAUSE_LEN_MAX,                                               // pause_1_len_max: maximum
2049:irmp.c        ****     BOSE_PULSE_LEN_MIN,                                                 // pulse_0_len_min: minimum
2050:irmp.c        ****     BOSE_PULSE_LEN_MAX,                                                 // pulse_0_len_max: maximum
2051:irmp.c        ****     BOSE_0_PAUSE_LEN_MIN,                                               // pause_0_len_min: minimum
2052:irmp.c        ****     BOSE_0_PAUSE_LEN_MAX,                                               // pause_0_len_max: maximum
2053:irmp.c        ****     BOSE_ADDRESS_OFFSET,                                                // address_offset:  address
2054:irmp.c        ****     BOSE_ADDRESS_OFFSET + BOSE_ADDRESS_LEN,                             // address_end:     end of 
2055:irmp.c        ****     BOSE_COMMAND_OFFSET,                                                // command_offset:  command
2056:irmp.c        ****     BOSE_COMMAND_OFFSET + BOSE_COMMAND_LEN,                             // command_end:     end of 
2057:irmp.c        ****     BOSE_COMPLETE_DATA_LEN,                                             // complete_len:    complet
2058:irmp.c        ****     BOSE_STOP_BIT,                                                      // stop_bit:        flag: f
2059:irmp.c        ****     BOSE_LSB,                                                           // lsb_first:       flag: L
2060:irmp.c        ****     BOSE_FLAGS                                                          // flags:           some fl
2061:irmp.c        **** };
2062:irmp.c        **** 
2063:irmp.c        **** #endif
2064:irmp.c        **** 
2065:irmp.c        **** #if IRMP_SUPPORT_A1TVBOX_PROTOCOL == 1
2066:irmp.c        **** 
2067:irmp.c        **** static const PROGMEM IRMP_PARAMETER a1tvbox_param =
2068:irmp.c        **** {
2069:irmp.c        ****     IRMP_A1TVBOX_PROTOCOL,                                              // protocol:        ir prot
2070:irmp.c        **** 
2071:irmp.c        ****     A1TVBOX_BIT_PULSE_LEN_MIN,                                          // pulse_1_len_min: here: m
2072:irmp.c        ****     A1TVBOX_BIT_PULSE_LEN_MAX,                                          // pulse_1_len_max: here: m
2073:irmp.c        ****     A1TVBOX_BIT_PAUSE_LEN_MIN,                                          // pause_1_len_min: here: m
2074:irmp.c        ****     A1TVBOX_BIT_PAUSE_LEN_MAX,                                          // pause_1_len_max: here: m
2075:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
2076:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
2077:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
2078:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
2079:irmp.c        ****     A1TVBOX_ADDRESS_OFFSET,                                             // address_offset:  address
2080:irmp.c        ****     A1TVBOX_ADDRESS_OFFSET + A1TVBOX_ADDRESS_LEN,                       // address_end:     end of 
2081:irmp.c        ****     A1TVBOX_COMMAND_OFFSET,                                             // command_offset:  command
2082:irmp.c        ****     A1TVBOX_COMMAND_OFFSET + A1TVBOX_COMMAND_LEN,                       // command_end:     end of 
2083:irmp.c        ****     A1TVBOX_COMPLETE_DATA_LEN,                                          // complete_len:    complet
2084:irmp.c        ****     A1TVBOX_STOP_BIT,                                                   // stop_bit:        flag: f
2085:irmp.c        ****     A1TVBOX_LSB,                                                        // lsb_first:       flag: L
2086:irmp.c        ****     A1TVBOX_FLAGS                                                       // flags:           some fl
2087:irmp.c        **** };
2088:irmp.c        **** 
2089:irmp.c        **** #endif
2090:irmp.c        **** 
2091:irmp.c        **** #if IRMP_SUPPORT_MERLIN_PROTOCOL == 1
2092:irmp.c        **** 
2093:irmp.c        **** static const PROGMEM IRMP_PARAMETER merlin_param =
2094:irmp.c        **** {
2095:irmp.c        ****     IRMP_MERLIN_PROTOCOL,                                               // protocol:        ir prot
2096:irmp.c        **** 
2097:irmp.c        ****     MERLIN_BIT_PULSE_LEN_MIN,                                           // pulse_1_len_min: here: m
2098:irmp.c        ****     MERLIN_BIT_PULSE_LEN_MAX,                                           // pulse_1_len_max: here: m
2099:irmp.c        ****     MERLIN_BIT_PAUSE_LEN_MIN,                                           // pause_1_len_min: here: m
2100:irmp.c        ****     MERLIN_BIT_PAUSE_LEN_MAX,                                           // pause_1_len_max: here: m
2101:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
2102:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
2103:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
2104:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
2105:irmp.c        ****     MERLIN_ADDRESS_OFFSET,                                              // address_offset:  address
2106:irmp.c        ****     MERLIN_ADDRESS_OFFSET + MERLIN_ADDRESS_LEN,                         // address_end:     end of 
2107:irmp.c        ****     MERLIN_COMMAND_OFFSET,                                              // command_offset:  command
2108:irmp.c        ****     MERLIN_COMMAND_OFFSET + MERLIN_COMMAND_LEN,                         // command_end:     end of 
2109:irmp.c        ****     MERLIN_COMPLETE_DATA_LEN,                                           // complete_len:    complet
2110:irmp.c        ****     MERLIN_STOP_BIT,                                                    // stop_bit:        flag: f
2111:irmp.c        ****     MERLIN_LSB,                                                         // lsb_first:       flag: L
2112:irmp.c        ****     MERLIN_FLAGS                                                        // flags:           some fl
2113:irmp.c        **** };
2114:irmp.c        **** 
2115:irmp.c        **** #endif
2116:irmp.c        **** 
2117:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
2118:irmp.c        **** 
2119:irmp.c        **** static const PROGMEM IRMP_PARAMETER ortek_param =
2120:irmp.c        **** {
2121:irmp.c        ****     IRMP_ORTEK_PROTOCOL,                                                // protocol:        ir prot
2122:irmp.c        **** 
2123:irmp.c        ****     ORTEK_BIT_PULSE_LEN_MIN,                                            // pulse_1_len_min: here: m
2124:irmp.c        ****     ORTEK_BIT_PULSE_LEN_MAX,                                            // pulse_1_len_max: here: m
2125:irmp.c        ****     ORTEK_BIT_PAUSE_LEN_MIN,                                            // pause_1_len_min: here: m
2126:irmp.c        ****     ORTEK_BIT_PAUSE_LEN_MAX,                                            // pause_1_len_max: here: m
2127:irmp.c        ****     0,                                                                  // pulse_0_len_min: here: n
2128:irmp.c        ****     0,                                                                  // pulse_0_len_max: here: n
2129:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
2130:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
2131:irmp.c        ****     ORTEK_ADDRESS_OFFSET,                                               // address_offset:  address
2132:irmp.c        ****     ORTEK_ADDRESS_OFFSET + ORTEK_ADDRESS_LEN,                           // address_end:     end of 
2133:irmp.c        ****     ORTEK_COMMAND_OFFSET,                                               // command_offset:  command
2134:irmp.c        ****     ORTEK_COMMAND_OFFSET + ORTEK_COMMAND_LEN,                           // command_end:     end of 
2135:irmp.c        ****     ORTEK_COMPLETE_DATA_LEN,                                            // complete_len:    complet
2136:irmp.c        ****     ORTEK_STOP_BIT,                                                     // stop_bit:        flag: f
2137:irmp.c        ****     ORTEK_LSB,                                                          // lsb_first:       flag: L
2138:irmp.c        ****     ORTEK_FLAGS                                                         // flags:           some fl
2139:irmp.c        **** };
2140:irmp.c        **** 
2141:irmp.c        **** #endif
2142:irmp.c        **** 
2143:irmp.c        **** #if IRMP_SUPPORT_ROOMBA_PROTOCOL == 1
2144:irmp.c        **** 
2145:irmp.c        **** static const PROGMEM IRMP_PARAMETER roomba_param =
2146:irmp.c        **** {
2147:irmp.c        ****     IRMP_ROOMBA_PROTOCOL,                                               // protocol:        ir prot
2148:irmp.c        ****     ROOMBA_1_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum
2149:irmp.c        ****     ROOMBA_1_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum
2150:irmp.c        ****     ROOMBA_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum
2151:irmp.c        ****     ROOMBA_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum
2152:irmp.c        ****     ROOMBA_0_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum
2153:irmp.c        ****     ROOMBA_0_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum
2154:irmp.c        ****     ROOMBA_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum
2155:irmp.c        ****     ROOMBA_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum
2156:irmp.c        ****     ROOMBA_ADDRESS_OFFSET,                                              // address_offset:  address
2157:irmp.c        ****     ROOMBA_ADDRESS_OFFSET + ROOMBA_ADDRESS_LEN,                         // address_end:     end of 
2158:irmp.c        ****     ROOMBA_COMMAND_OFFSET,                                              // command_offset:  command
2159:irmp.c        ****     ROOMBA_COMMAND_OFFSET + ROOMBA_COMMAND_LEN,                         // command_end:     end of 
2160:irmp.c        ****     ROOMBA_COMPLETE_DATA_LEN,                                           // complete_len:    complet
2161:irmp.c        ****     ROOMBA_STOP_BIT,                                                    // stop_bit:        flag: f
2162:irmp.c        ****     ROOMBA_LSB,                                                         // lsb_first:       flag: L
2163:irmp.c        ****     ROOMBA_FLAGS                                                        // flags:           some fl
2164:irmp.c        **** };
2165:irmp.c        **** 
2166:irmp.c        **** #endif
2167:irmp.c        **** 
2168:irmp.c        **** #if IRMP_SUPPORT_RCMM_PROTOCOL == 1
2169:irmp.c        **** 
2170:irmp.c        **** static const PROGMEM IRMP_PARAMETER rcmm_param =
2171:irmp.c        **** {
2172:irmp.c        ****     IRMP_RCMM32_PROTOCOL,                                               // protocol:        ir prot
2173:irmp.c        **** 
2174:irmp.c        ****     RCMM32_BIT_PULSE_LEN_MIN,                                           // pulse_1_len_min: here: m
2175:irmp.c        ****     RCMM32_BIT_PULSE_LEN_MAX,                                           // pulse_1_len_max: here: m
2176:irmp.c        ****     0,                                                                  // pause_1_len_min: here: m
2177:irmp.c        ****     0,                                                                  // pause_1_len_max: here: m
2178:irmp.c        ****     RCMM32_BIT_PULSE_LEN_MIN,                                           // pulse_0_len_min: here: n
2179:irmp.c        ****     RCMM32_BIT_PULSE_LEN_MAX,                                           // pulse_0_len_max: here: n
2180:irmp.c        ****     0,                                                                  // pause_0_len_min: here: n
2181:irmp.c        ****     0,                                                                  // pause_0_len_max: here: n
2182:irmp.c        ****     RCMM32_ADDRESS_OFFSET,                                              // address_offset:  address
2183:irmp.c        ****     RCMM32_ADDRESS_OFFSET + RCMM32_ADDRESS_LEN,                         // address_end:     end of 
2184:irmp.c        ****     RCMM32_COMMAND_OFFSET,                                              // command_offset:  command
2185:irmp.c        ****     RCMM32_COMMAND_OFFSET + RCMM32_COMMAND_LEN,                         // command_end:     end of 
2186:irmp.c        ****     RCMM32_COMPLETE_DATA_LEN,                                           // complete_len:    complet
2187:irmp.c        ****     RCMM32_STOP_BIT,                                                    // stop_bit:        flag: f
2188:irmp.c        ****     RCMM32_LSB,                                                         // lsb_first:       flag: L
2189:irmp.c        ****     RCMM32_FLAGS                                                        // flags:           some fl
2190:irmp.c        **** };
2191:irmp.c        **** 
2192:irmp.c        **** #endif
2193:irmp.c        **** 
2194:irmp.c        **** #if IRMP_SUPPORT_PENTAX_PROTOCOL == 1
2195:irmp.c        **** 
2196:irmp.c        **** static const PROGMEM IRMP_PARAMETER pentax_param =
2197:irmp.c        **** {
2198:irmp.c        ****     IRMP_PENTAX_PROTOCOL,                                               // protocol:        ir prot
2199:irmp.c        ****     PENTAX_PULSE_LEN_MIN,                                               // pulse_1_len_min: minimum
2200:irmp.c        ****     PENTAX_PULSE_LEN_MAX,                                               // pulse_1_len_max: maximum
2201:irmp.c        ****     PENTAX_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum
2202:irmp.c        ****     PENTAX_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum
2203:irmp.c        ****     PENTAX_PULSE_LEN_MIN,                                               // pulse_0_len_min: minimum
2204:irmp.c        ****     PENTAX_PULSE_LEN_MAX,                                               // pulse_0_len_max: maximum
2205:irmp.c        ****     PENTAX_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum
2206:irmp.c        ****     PENTAX_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum
2207:irmp.c        ****     PENTAX_ADDRESS_OFFSET,                                              // address_offset:  address
2208:irmp.c        ****     PENTAX_ADDRESS_OFFSET + PENTAX_ADDRESS_LEN,                         // address_end:     end of 
2209:irmp.c        ****     PENTAX_COMMAND_OFFSET,                                              // command_offset:  command
2210:irmp.c        ****     PENTAX_COMMAND_OFFSET + PENTAX_COMMAND_LEN,                         // command_end:     end of 
2211:irmp.c        ****     PENTAX_COMPLETE_DATA_LEN,                                           // complete_len:    complet
2212:irmp.c        ****     PENTAX_STOP_BIT,                                                    // stop_bit:        flag: f
2213:irmp.c        ****     PENTAX_LSB,                                                         // lsb_first:       flag: L
2214:irmp.c        ****     PENTAX_FLAGS                                                        // flags:           some fl
2215:irmp.c        **** };
2216:irmp.c        **** 
2217:irmp.c        **** #endif
2218:irmp.c        **** 
2219:irmp.c        **** #if IRMP_SUPPORT_ACP24_PROTOCOL == 1
2220:irmp.c        **** 
2221:irmp.c        **** static const PROGMEM IRMP_PARAMETER acp24_param =
2222:irmp.c        **** {
2223:irmp.c        ****     IRMP_ACP24_PROTOCOL,                                                // protocol:        ir prot
2224:irmp.c        ****     ACP24_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum
2225:irmp.c        ****     ACP24_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum
2226:irmp.c        ****     ACP24_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum
2227:irmp.c        ****     ACP24_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum
2228:irmp.c        ****     ACP24_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum
2229:irmp.c        ****     ACP24_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum
2230:irmp.c        ****     ACP24_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum
2231:irmp.c        ****     ACP24_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum
2232:irmp.c        ****     ACP24_ADDRESS_OFFSET,                                               // address_offset:  address
2233:irmp.c        ****     ACP24_ADDRESS_OFFSET + ACP24_ADDRESS_LEN,                           // address_end:     end of 
2234:irmp.c        ****     ACP24_COMMAND_OFFSET,                                               // command_offset:  command
2235:irmp.c        ****     ACP24_COMMAND_OFFSET + ACP24_COMMAND_LEN,                           // command_end:     end of 
2236:irmp.c        ****     ACP24_COMPLETE_DATA_LEN,                                            // complete_len:    complet
2237:irmp.c        ****     ACP24_STOP_BIT,                                                     // stop_bit:        flag: f
2238:irmp.c        ****     ACP24_LSB,                                                          // lsb_first:       flag: L
2239:irmp.c        ****     ACP24_FLAGS                                                         // flags:           some fl
2240:irmp.c        **** };
2241:irmp.c        **** 
2242:irmp.c        **** #endif
2243:irmp.c        **** 
2244:irmp.c        **** #if IRMP_SUPPORT_METZ_PROTOCOL == 1
2245:irmp.c        **** 
2246:irmp.c        **** static const PROGMEM IRMP_PARAMETER metz_param =
2247:irmp.c        **** {
2248:irmp.c        ****     IRMP_METZ_PROTOCOL,                                                 // protocol:        ir prot
2249:irmp.c        ****     METZ_PULSE_LEN_MIN,                                                 // pulse_1_len_min: minimum
2250:irmp.c        ****     METZ_PULSE_LEN_MAX,                                                 // pulse_1_len_max: maximum
2251:irmp.c        ****     METZ_1_PAUSE_LEN_MIN,                                               // pause_1_len_min: minimum
2252:irmp.c        ****     METZ_1_PAUSE_LEN_MAX,                                               // pause_1_len_max: maximum
2253:irmp.c        ****     METZ_PULSE_LEN_MIN,                                                 // pulse_0_len_min: minimum
2254:irmp.c        ****     METZ_PULSE_LEN_MAX,                                                 // pulse_0_len_max: maximum
2255:irmp.c        ****     METZ_0_PAUSE_LEN_MIN,                                               // pause_0_len_min: minimum
2256:irmp.c        ****     METZ_0_PAUSE_LEN_MAX,                                               // pause_0_len_max: maximum
2257:irmp.c        ****     METZ_ADDRESS_OFFSET,                                                // address_offset:  address
2258:irmp.c        ****     METZ_ADDRESS_OFFSET + METZ_ADDRESS_LEN,                             // address_end:     end of 
2259:irmp.c        ****     METZ_COMMAND_OFFSET,                                                // command_offset:  command
2260:irmp.c        ****     METZ_COMMAND_OFFSET + METZ_COMMAND_LEN,                             // command_end:     end of 
2261:irmp.c        ****     METZ_COMPLETE_DATA_LEN,                                             // complete_len:    complet
2262:irmp.c        ****     METZ_STOP_BIT,                                                      // stop_bit:        flag: f
2263:irmp.c        ****     METZ_LSB,                                                           // lsb_first:       flag: L
2264:irmp.c        ****     METZ_FLAGS                                                          // flags:           some fl
2265:irmp.c        **** };
2266:irmp.c        **** 
2267:irmp.c        **** #endif
2268:irmp.c        **** 
2269:irmp.c        **** #if IRMP_SUPPORT_RADIO1_PROTOCOL == 1
2270:irmp.c        **** 
2271:irmp.c        **** static const PROGMEM IRMP_PARAMETER radio1_param =
2272:irmp.c        **** {
2273:irmp.c        ****     IRMP_RADIO1_PROTOCOL,                                               // protocol:        ir prot
2274:irmp.c        **** 
2275:irmp.c        ****     RADIO1_1_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum
2276:irmp.c        ****     RADIO1_1_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum
2277:irmp.c        ****     RADIO1_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum
2278:irmp.c        ****     RADIO1_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum
2279:irmp.c        ****     RADIO1_0_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum
2280:irmp.c        ****     RADIO1_0_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum
2281:irmp.c        ****     RADIO1_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum
2282:irmp.c        ****     RADIO1_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum
2283:irmp.c        ****     RADIO1_ADDRESS_OFFSET,                                              // address_offset:  address
2284:irmp.c        ****     RADIO1_ADDRESS_OFFSET + RADIO1_ADDRESS_LEN,                         // address_end:     end of 
2285:irmp.c        ****     RADIO1_COMMAND_OFFSET,                                              // command_offset:  command
2286:irmp.c        ****     RADIO1_COMMAND_OFFSET + RADIO1_COMMAND_LEN,                         // command_end:     end of 
2287:irmp.c        ****     RADIO1_COMPLETE_DATA_LEN,                                           // complete_len:    complet
2288:irmp.c        ****     RADIO1_STOP_BIT,                                                    // stop_bit:        flag: f
2289:irmp.c        ****     RADIO1_LSB,                                                         // lsb_first:       flag: L
2290:irmp.c        ****     RADIO1_FLAGS                                                        // flags:           some fl
2291:irmp.c        **** };
2292:irmp.c        **** 
2293:irmp.c        **** #endif
2294:irmp.c        **** 
2295:irmp.c        **** static uint_fast8_t                             irmp_bit;                   // current bit position
2296:irmp.c        **** static IRMP_PARAMETER                           irmp_param;
2297:irmp.c        **** 
2298:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
2299:irmp.c        **** static IRMP_PARAMETER                           irmp_param2;
2300:irmp.c        **** #endif
2301:irmp.c        **** 
2302:irmp.c        **** static volatile uint_fast8_t                    irmp_ir_detected = FALSE;
2303:irmp.c        **** static volatile uint_fast8_t                    irmp_protocol;
2304:irmp.c        **** static volatile uint_fast16_t                   irmp_address;
2305:irmp.c        **** #if IRMP_32_BIT == 1
2306:irmp.c        **** static volatile uint_fast32_t                   irmp_command;
2307:irmp.c        **** #else
2308:irmp.c        **** static volatile uint_fast16_t                   irmp_command;
2309:irmp.c        **** #endif
2310:irmp.c        **** static volatile uint_fast16_t                   irmp_id;                // only used for SAMSUNG pr
2311:irmp.c        **** static volatile uint_fast8_t                    irmp_flags;
2312:irmp.c        **** // static volatile uint_fast8_t                 irmp_busy_flag;
2313:irmp.c        **** 
2314:irmp.c        **** #if defined(__MBED__)
2315:irmp.c        **** // DigitalIn inputPin(IRMP_PIN, PullUp);                                // this requires mbed.h and
2316:irmp.c        **** gpio_t                                          gpioIRin;               // use low level c function
2317:irmp.c        **** #endif
2318:irmp.c        **** 
2319:irmp.c        **** 
2320:irmp.c        **** #ifdef ANALYZE
2321:irmp.c        **** #define input(x)                                (x)
2322:irmp.c        **** static uint_fast8_t                             IRMP_PIN;
2323:irmp.c        **** static uint_fast8_t                             radio;
2324:irmp.c        **** #endif
2325:irmp.c        **** 
2326:irmp.c        **** /*-------------------------------------------------------------------------------------------------
2327:irmp.c        ****  *  Initialize IRMP decoder
2328:irmp.c        ****  *  @details  Configures IRMP input pin
2329:irmp.c        ****  *-------------------------------------------------------------------------------------------------
2330:irmp.c        ****  */
2331:irmp.c        **** #ifndef ANALYZE
2332:irmp.c        **** void
2333:irmp.c        **** irmp_init (void)
2334:irmp.c        **** {
2335:irmp.c        **** #if defined(PIC_CCS) || defined(PIC_C18)                                // PIC: do nothing
2336:irmp.c        **** #elif defined (ARM_STM32_HAL)                                           // STM32 with Hal Library: 
2337:irmp.c        **** #elif defined (ARM_STM32)                                               // STM32
2338:irmp.c        ****     GPIO_InitTypeDef     GPIO_InitStructure;
2339:irmp.c        **** 
2340:irmp.c        ****     /* GPIOx clock enable */
2341:irmp.c        **** #  if defined (ARM_STM32L1XX)
2342:irmp.c        ****     RCC_AHBPeriphClockCmd(IRMP_PORT_RCC, ENABLE);
2343:irmp.c        **** #  elif defined (ARM_STM32F10X)
2344:irmp.c        ****     RCC_APB2PeriphClockCmd(IRMP_PORT_RCC, ENABLE);
2345:irmp.c        **** #  elif defined (ARM_STM32F4XX)
2346:irmp.c        ****     RCC_AHB1PeriphClockCmd(IRMP_PORT_RCC, ENABLE);
2347:irmp.c        **** #  endif
2348:irmp.c        **** 
2349:irmp.c        ****     /* GPIO Configuration */
2350:irmp.c        ****     GPIO_InitStructure.GPIO_Pin = IRMP_BIT;
2351:irmp.c        **** #  if defined (ARM_STM32L1XX) || defined (ARM_STM32F4XX)
2352:irmp.c        ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
2353:irmp.c        ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
2354:irmp.c        ****     GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
2355:irmp.c        ****     GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
2356:irmp.c        **** #  elif defined (ARM_STM32F10X)
2357:irmp.c        ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
2358:irmp.c        ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
2359:irmp.c        **** #  endif
2360:irmp.c        ****     GPIO_Init(IRMP_PORT, &GPIO_InitStructure);
2361:irmp.c        **** 
2362:irmp.c        **** #elif defined(STELLARIS_ARM_CORTEX_M4)
2363:irmp.c        ****     // Enable the GPIO port
2364:irmp.c        ****     ROM_SysCtlPeripheralEnable(IRMP_PORT_PERIPH);
2365:irmp.c        **** 
2366:irmp.c        ****     // Set as an input
2367:irmp.c        ****     ROM_GPIODirModeSet(IRMP_PORT_BASE, IRMP_PORT_PIN, GPIO_DIR_MODE_IN);
2368:irmp.c        ****     ROM_GPIOPadConfigSet(IRMP_PORT_BASE, IRMP_PORT_PIN, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);
2369:irmp.c        **** 
2370:irmp.c        **** #elif defined(__SDCC_stm8)                                              // STM8
2371:irmp.c        ****     IRMP_GPIO_STRUCT->DDR &= ~(1<<IRMP_BIT);                            // pin is input
2372:irmp.c        ****     IRMP_GPIO_STRUCT->CR1 |= (1<<IRMP_BIT);                             // activate pullup
2373:irmp.c        **** 
2374:irmp.c        **** #elif defined (TEENSY_ARM_CORTEX_M4)                                    // TEENSY
2375:irmp.c        ****     pinMode(IRMP_PIN, INPUT);
2376:irmp.c        **** 
2377:irmp.c        **** #elif defined(__xtensa__)                                               // ESP8266
2378:irmp.c        ****     pinMode(IRMP_BIT_NUMBER, INPUT);
2379:irmp.c        ****                                                                         // select pin function
2380:irmp.c        **** #  if (IRMP_BIT_NUMBER == 12)
2381:irmp.c        ****     PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U, FUNC_GPIO12);
2382:irmp.c        **** //  doesn't work for me:
2383:irmp.c        **** //  # elif (IRMP_BIT_NUMBER == 13)
2384:irmp.c        **** //  PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTCK_U , FUNC_GPIO13);
2385:irmp.c        **** #  else
2386:irmp.c        **** #   warning Please add PIN_FUNC_SELECT when necessary.
2387:irmp.c        **** #  endif
2388:irmp.c        ****     GPIO_DIS_OUTPUT(IRMP_BIT_NUMBER);
2389:irmp.c        **** 
2390:irmp.c        **** #elif defined(__MBED__)
2391:irmp.c        ****     gpio_init_in_ex(&gpioIRin, IRMP_PIN, IRMP_PINMODE);                 // initialize input for IR 
2392:irmp.c        **** 
2393:irmp.c        **** #elif defined(_CHIBIOS_HAL_)
2394:irmp.c        ****     // ChibiOS HAL automatically initializes all pins according to the board config file, no need t
2395:irmp.c        **** 
2396:irmp.c        **** #else                                                                   // AVR
2397:irmp.c        ****     IRMP_PORT &= ~(1<<IRMP_BIT);                                        // deactivate pullup
2398:irmp.c        ****     IRMP_DDR &= ~(1<<IRMP_BIT);                                         // set pin to input
2399:irmp.c        **** #endif
2400:irmp.c        **** 
2401:irmp.c        **** #if IRMP_LOGGING == 1
2402:irmp.c        ****     irmp_uart_init ();
2403:irmp.c        **** #endif
2404:irmp.c        **** }
2405:irmp.c        **** #endif
2406:irmp.c        **** /*-------------------------------------------------------------------------------------------------
2407:irmp.c        ****  *  Get IRMP data
2408:irmp.c        ****  *  @details  gets decoded IRMP data
2409:irmp.c        ****  *  @param    pointer in order to store IRMP data
2410:irmp.c        ****  *  @return    TRUE: successful, FALSE: failed
2411:irmp.c        ****  *-------------------------------------------------------------------------------------------------
2412:irmp.c        ****  */
2413:irmp.c        **** uint_fast8_t
2414:irmp.c        **** irmp_get_data (IRMP_DATA * irmp_data_p)
2415:irmp.c        **** {
2416:irmp.c        ****     uint_fast8_t   rtc = FALSE;
2417:irmp.c        **** #if IRMP_SUPPORT_MERLIN_PROTOCOL == 1
2418:irmp.c        ****     uint_fast8_t   cmd_len = 0;
2419:irmp.c        **** #endif
2420:irmp.c        **** 
2421:irmp.c        ****     if (irmp_ir_detected)
2422:irmp.c        ****     {
2423:irmp.c        ****         switch (irmp_protocol)
2424:irmp.c        ****         {
2425:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
2426:irmp.c        ****             case IRMP_SAMSUNG_PROTOCOL:
2427:irmp.c        ****                 if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
2428:irmp.c        ****                 {
2429:irmp.c        ****                     irmp_command &= 0xff;
2430:irmp.c        ****                     irmp_command |= irmp_id << 8;
2431:irmp.c        ****                     rtc = TRUE;
2432:irmp.c        ****                 }
2433:irmp.c        ****                 break;
2434:irmp.c        **** 
2435:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG48_PROTOCOL == 1
2436:irmp.c        ****             case IRMP_SAMSUNG48_PROTOCOL:
2437:irmp.c        ****                 irmp_command = (irmp_command & 0x00FF) | ((irmp_id & 0x00FF) << 8);
2438:irmp.c        ****                 rtc = TRUE;
2439:irmp.c        ****                 break;
2440:irmp.c        **** #endif
2441:irmp.c        **** #endif
2442:irmp.c        **** 
2443:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
2444:irmp.c        ****             case IRMP_NEC_PROTOCOL:
2445:irmp.c        ****                 if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
2446:irmp.c        ****                 {
2447:irmp.c        ****                     irmp_command &= 0xff;
2448:irmp.c        ****                     rtc = TRUE;
2449:irmp.c        ****                 }
2450:irmp.c        ****                 else if (irmp_address == 0x87EE)
2451:irmp.c        ****                 {
2452:irmp.c        **** #ifdef ANALYZE
2453:irmp.c        ****                     ANALYZE_PRINTF ("Switching to APPLE protocol\n");
2454:irmp.c        **** #endif // ANALYZE
2455:irmp.c        ****                     irmp_protocol = IRMP_APPLE_PROTOCOL;
2456:irmp.c        ****                     irmp_address = (irmp_command & 0xFF00) >> 8;
2457:irmp.c        ****                     irmp_command &= 0x00FF;
2458:irmp.c        ****                     rtc = TRUE;
2459:irmp.c        ****                 }
2460:irmp.c        ****                 else
2461:irmp.c        ****                 {
2462:irmp.c        **** #ifdef ANALYZE
2463:irmp.c        ****                     ANALYZE_PRINTF ("Switching to ONKYO protocol\n");
2464:irmp.c        **** #endif // ANALYZE
2465:irmp.c        ****                     irmp_protocol = IRMP_ONKYO_PROTOCOL;
2466:irmp.c        ****                     rtc = TRUE;
2467:irmp.c        ****                 }
2468:irmp.c        ****                 break;
2469:irmp.c        **** #endif
2470:irmp.c        **** 
2471:irmp.c        **** 
2472:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
2473:irmp.c        ****             case IRMP_VINCENT_PROTOCOL:
2474:irmp.c        ****                 if ((irmp_command >> 8) == (irmp_command & 0x00FF))
2475:irmp.c        ****                 {
2476:irmp.c        ****                     irmp_command &= 0xff;
2477:irmp.c        ****                     rtc = TRUE;
2478:irmp.c        ****                 }
2479:irmp.c        ****                 break;
2480:irmp.c        **** #endif
2481:irmp.c        **** 
2482:irmp.c        **** #if IRMP_SUPPORT_BOSE_PROTOCOL == 1
2483:irmp.c        ****             case IRMP_BOSE_PROTOCOL:
2484:irmp.c        ****                 if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
2485:irmp.c        ****                 {
2486:irmp.c        ****                     irmp_command &= 0xff;
2487:irmp.c        ****                     rtc = TRUE;
2488:irmp.c        ****                 }
2489:irmp.c        ****                 break;
2490:irmp.c        **** #endif
2491:irmp.c        **** 
2492:irmp.c        **** #if IRMP_SUPPORT_MERLIN_PROTOCOL == 1
2493:irmp.c        ****             case IRMP_MERLIN_PROTOCOL:
2494:irmp.c        ****                 if (irmp_bit == 10)
2495:irmp.c        ****                 {
2496:irmp.c        ****                     rtc = TRUE;
2497:irmp.c        ****                 }
2498:irmp.c        ****                 else if (irmp_bit >= 19 && ((irmp_bit - 3) % 8 == 0))
2499:irmp.c        ****                 {
2500:irmp.c        ****                     if (((irmp_command >> 1) & 1) != (irmp_command & 1))
2501:irmp.c        ****                     {
2502:irmp.c        ****                         irmp_command >>= 1;
2503:irmp.c        ****                         irmp_command |= ((irmp_address & 1) << (irmp_bit - 12));
2504:irmp.c        ****                         irmp_address >>= 1;
2505:irmp.c        ****                         cmd_len = (irmp_bit - 11) >> 3;
2506:irmp.c        ****                         rtc = TRUE;
2507:irmp.c        ****                     }
2508:irmp.c        ****                 }
2509:irmp.c        ****                 break;
2510:irmp.c        **** #endif
2511:irmp.c        **** 
2512:irmp.c        **** #if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
2513:irmp.c        ****             case IRMP_SIEMENS_PROTOCOL:
2514:irmp.c        ****             case IRMP_RUWIDO_PROTOCOL:
2515:irmp.c        ****                 if (((irmp_command >> 1) & 0x0001) == (~irmp_command & 0x0001))
2516:irmp.c        ****                 {
2517:irmp.c        ****                     irmp_command >>= 1;
2518:irmp.c        ****                     rtc = TRUE;
2519:irmp.c        ****                 }
2520:irmp.c        ****                 break;
2521:irmp.c        **** #endif
2522:irmp.c        **** #if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
2523:irmp.c        ****             case IRMP_KATHREIN_PROTOCOL:
2524:irmp.c        ****                 if (irmp_command != 0x0000)
2525:irmp.c        ****                 {
2526:irmp.c        ****                     rtc = TRUE;
2527:irmp.c        ****                 }
2528:irmp.c        ****                 break;
2529:irmp.c        **** #endif
2530:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1
2531:irmp.c        ****             case IRMP_RC5_PROTOCOL:
2532:irmp.c        ****                 irmp_address &= ~0x20;                              // clear toggle bit
2533:irmp.c        ****                 rtc = TRUE;
2534:irmp.c        ****                 break;
2535:irmp.c        **** #endif
2536:irmp.c        **** #if IRMP_SUPPORT_S100_PROTOCOL == 1
2537:irmp.c        ****             case IRMP_S100_PROTOCOL:
2538:irmp.c        ****                 irmp_address &= ~0x20;                              // clear toggle bit
2539:irmp.c        ****                 rtc = TRUE;
2540:irmp.c        ****                 break;
2541:irmp.c        **** #endif
2542:irmp.c        **** #if IRMP_SUPPORT_IR60_PROTOCOL == 1
2543:irmp.c        ****             case IRMP_IR60_PROTOCOL:
2544:irmp.c        ****                 if (irmp_command != 0x007d)                         // 0x007d (== 62<<1 + 1) is sta
2545:irmp.c        ****                 {
2546:irmp.c        ****                     rtc = TRUE;
2547:irmp.c        ****                 }
2548:irmp.c        ****                 else
2549:irmp.c        ****                 {
2550:irmp.c        **** #ifdef ANALYZE
2551:irmp.c        ****                     ANALYZE_PRINTF("Info IR60: got start instruction frame\n");
2552:irmp.c        **** #endif // ANALYZE
2553:irmp.c        ****                 }
2554:irmp.c        ****                 break;
2555:irmp.c        **** #endif
2556:irmp.c        **** #if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
2557:irmp.c        ****             case IRMP_RCCAR_PROTOCOL:
2558:irmp.c        ****                 // frame in irmp_data:
2559:irmp.c        ****                 // Bit 12 11 10 9  8  7  6  5  4  3  2  1  0
2560:irmp.c        ****                 //     V  D7 D6 D5 D4 D3 D2 D1 D0 A1 A0 C1 C0   //         10 9  8  7  6  5  4  3  
2561:irmp.c        ****                 irmp_address = (irmp_command & 0x000C) >> 2;    // addr:   0  0  0  0  0  0  0  0  
2562:irmp.c        ****                 irmp_command = ((irmp_command & 0x1000) >> 2) | // V-Bit:  V  0  0  0  0  0  0  0  
2563:irmp.c        ****                                ((irmp_command & 0x0003) << 8) | // C-Bits: 0  C1 C0 0  0  0  0  0  
2564:irmp.c        ****                                ((irmp_command & 0x0FF0) >> 4);  // D-Bits:          D7 D6 D5 D4 D3 
2565:irmp.c        ****                 rtc = TRUE;                                     // Summe:  V  C1 C0 D7 D6 D5 D4 D3 
2566:irmp.c        ****                 break;
2567:irmp.c        **** #endif
2568:irmp.c        **** 
2569:irmp.c        **** #if IRMP_SUPPORT_NETBOX_PROTOCOL == 1                           // squeeze code to 8 bit, upper bit
2570:irmp.c        ****             case IRMP_NETBOX_PROTOCOL:
2571:irmp.c        ****                 if (irmp_command & 0x1000)                      // last bit set?
2572:irmp.c        ****                 {
2573:irmp.c        ****                     if ((irmp_command & 0x1f) == 0x15)          // key pressed: 101 01 (LSB)
2574:irmp.c        ****                     {
2575:irmp.c        ****                         irmp_command >>= 5;
2576:irmp.c        ****                         irmp_command &= 0x7F;
2577:irmp.c        ****                         rtc = TRUE;
2578:irmp.c        ****                     }
2579:irmp.c        ****                     else if ((irmp_command & 0x1f) == 0x10)     // key released: 000 01 (LSB)
2580:irmp.c        ****                     {
2581:irmp.c        ****                         irmp_command >>= 5;
2582:irmp.c        ****                         irmp_command |= 0x80;
2583:irmp.c        ****                         rtc = TRUE;
2584:irmp.c        ****                     }
2585:irmp.c        ****                     else
2586:irmp.c        ****                     {
2587:irmp.c        **** #ifdef ANALYZE
2588:irmp.c        ****                         ANALYZE_PRINTF("error NETBOX: bit6/7 must be 0/1\n");
2589:irmp.c        **** #endif // ANALYZE
2590:irmp.c        ****                     }
2591:irmp.c        ****                 }
2592:irmp.c        ****                 else
2593:irmp.c        ****                 {
2594:irmp.c        **** #ifdef ANALYZE
2595:irmp.c        ****                     ANALYZE_PRINTF("error NETBOX: last bit not set\n");
2596:irmp.c        **** #endif // ANALYZE
2597:irmp.c        ****                 }
2598:irmp.c        ****                 break;
2599:irmp.c        **** #endif
2600:irmp.c        **** #if IRMP_SUPPORT_LEGO_PROTOCOL == 1
2601:irmp.c        ****             case IRMP_LEGO_PROTOCOL:
2602:irmp.c        ****             {
2603:irmp.c        ****                 uint_fast8_t crc = 0x0F ^ ((irmp_command & 0xF000) >> 12) ^ ((irmp_command & 0x0F00
2604:irmp.c        **** 
2605:irmp.c        ****                 if ((irmp_command & 0x000F) == crc)
2606:irmp.c        ****                 {
2607:irmp.c        ****                     irmp_command >>= 4;
2608:irmp.c        ****                     rtc = TRUE;
2609:irmp.c        ****                 }
2610:irmp.c        ****                 else
2611:irmp.c        ****                 {
2612:irmp.c        **** #ifdef ANALYZE
2613:irmp.c        ****                     ANALYZE_PRINTF ("CRC error in LEGO protocol\n");
2614:irmp.c        **** #endif // ANALYZE
2615:irmp.c        ****                     // rtc = TRUE;                              // don't accept codes with CRC erro
2616:irmp.c        ****                 }
2617:irmp.c        ****                 break;
2618:irmp.c        ****             }
2619:irmp.c        **** #endif
2620:irmp.c        **** 
2621:irmp.c        **** #if IRMP_SUPPORT_METZ_PROTOCOL == 1
2622:irmp.c        ****             case IRMP_METZ_PROTOCOL:
2623:irmp.c        ****                 irmp_address &= ~0x40;                              // clear toggle bit
2624:irmp.c        ****                 if (((~irmp_address) & 0x07) == (irmp_address >> 3) && ((~irmp_command) & 0x3f) == 
2625:irmp.c        ****                 {
2626:irmp.c        ****                     irmp_address >>= 3;
2627:irmp.c        ****                     irmp_command >>= 6;
2628:irmp.c        ****                     rtc = TRUE;
2629:irmp.c        ****                 }
2630:irmp.c        ****                 break;
2631:irmp.c        **** #endif
2632:irmp.c        ****             default:
2633:irmp.c        ****             {
2634:irmp.c        ****                 rtc = TRUE;
2635:irmp.c        ****                 break;
2636:irmp.c        ****             }
2637:irmp.c        ****         }
2638:irmp.c        **** 
2639:irmp.c        ****         if (rtc)
2640:irmp.c        ****         {
2641:irmp.c        ****             irmp_data_p->protocol = irmp_protocol;
2642:irmp.c        ****             irmp_data_p->address  = irmp_address;
2643:irmp.c        ****             irmp_data_p->command  = irmp_command;
2644:irmp.c        ****             irmp_data_p->flags    = irmp_flags;
2645:irmp.c        **** #if IRMP_SUPPORT_MERLIN_PROTOCOL == 1
2646:irmp.c        ****             irmp_data_p->flags   |= cmd_len;
2647:irmp.c        **** #endif
2648:irmp.c        ****         }
2649:irmp.c        ****         else
2650:irmp.c        ****         {
2651:irmp.c        ****             irmp_protocol = IRMP_UNKNOWN_PROTOCOL;
2652:irmp.c        ****         }
2653:irmp.c        **** 
2654:irmp.c        ****         irmp_command  = 0;                                      // don't reset irmp_protocol here, 
2655:irmp.c        ****         irmp_address  = 0;
2656:irmp.c        ****         irmp_flags    = 0;
2657:irmp.c        **** 
2658:irmp.c        ****         irmp_ir_detected = FALSE;
2659:irmp.c        ****     }
2660:irmp.c        **** 
2661:irmp.c        ****     return rtc;
2662:irmp.c        **** }
2663:irmp.c        **** 
2664:irmp.c        **** #if IRMP_USE_CALLBACK == 1
2665:irmp.c        **** void
2666:irmp.c        **** irmp_set_callback_ptr (void (*cb)(uint_fast8_t))
2667:irmp.c        **** {
2668:irmp.c        ****     irmp_callback_ptr = cb;
2669:irmp.c        **** }
2670:irmp.c        **** #endif // IRMP_USE_CALLBACK == 1
2671:irmp.c        **** 
2672:irmp.c        **** // these statics must not be volatile, because they are only used by irmp_store_bit(), which is cal
2673:irmp.c        **** static uint_fast16_t irmp_tmp_address;                                      // ir address
2674:irmp.c        **** #if IRMP_32_BIT == 1
2675:irmp.c        **** static uint_fast32_t irmp_tmp_command;                                      // ir command
2676:irmp.c        **** #else
2677:irmp.c        **** static uint_fast16_t irmp_tmp_command;                                      // ir command
2678:irmp.c        **** #endif
2679:irmp.c        **** 
2680:irmp.c        **** #if (IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOC
2681:irmp.c        **** static uint_fast16_t irmp_tmp_address2;                                     // ir address
2682:irmp.c        **** static uint_fast16_t irmp_tmp_command2;                                     // ir command
2683:irmp.c        **** #endif
2684:irmp.c        **** 
2685:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
2686:irmp.c        **** static uint_fast16_t irmp_lgair_address;                                    // ir address
2687:irmp.c        **** static uint_fast16_t irmp_lgair_command;                                    // ir command
2688:irmp.c        **** #endif
2689:irmp.c        **** 
2690:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
2691:irmp.c        **** static uint_fast16_t irmp_tmp_id;                                           // ir id (only SAMSUNG)
2692:irmp.c        **** #endif
2693:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
2694:irmp.c        **** static uint8_t      xor_check[6];                                           // check kaseikyo "pari
2695:irmp.c        **** static uint_fast8_t genre2;                                                 // save genre2 bits her
2696:irmp.c        **** #endif
2697:irmp.c        **** 
2698:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
2699:irmp.c        **** static uint_fast8_t  parity;                                                // number of '1' of the
2700:irmp.c        **** #endif
2701:irmp.c        **** 
2702:irmp.c        **** #if IRMP_SUPPORT_MITSU_HEAVY_PROTOCOL == 1
2703:irmp.c        **** static uint_fast8_t  check;                                                 // number of '1' of the
2704:irmp.c        **** static uint_fast8_t  mitsu_parity;                                          // number of '1' of the
2705:irmp.c        **** #endif
2706:irmp.c        **** 
2707:irmp.c        **** /*-------------------------------------------------------------------------------------------------
2708:irmp.c        ****  *  store bit
2709:irmp.c        ****  *  @details  store bit in temp address or temp command
2710:irmp.c        ****  *  @param    value to store: 0 or 1
2711:irmp.c        ****  *-------------------------------------------------------------------------------------------------
2712:irmp.c        ****  */
2713:irmp.c        **** // verhindert, dass irmp_store_bit() inline compiliert wird:
2714:irmp.c        **** // static void irmp_store_bit (uint_fast8_t) __attribute__ ((noinline));
2715:irmp.c        **** 
2716:irmp.c        **** static void
2717:irmp.c        **** irmp_store_bit (uint_fast8_t value)
2718:irmp.c        **** {
 132               	.LM0:
 133               	.LFBB1:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 138 0000 982F      		mov r25,r24
2719:irmp.c        **** #if IRMP_SUPPORT_ACP24_PROTOCOL == 1
2720:irmp.c        ****     if (irmp_param.protocol == IRMP_ACP24_PROTOCOL)                                                
2721:irmp.c        ****     {
2722:irmp.c        ****         if (value)
2723:irmp.c        ****         {
2724:irmp.c        ****             // ACP24-Frame:
2725:irmp.c        ****             //           1         2         3         4         5         6
2726:irmp.c        ****             // 0123456789012345678901234567890123456789012345678901234567890123456789
2727:irmp.c        ****             // N VVMMM    ? ???    t vmA x                 y                     TTTT
2728:irmp.c        ****             //
2729:irmp.c        ****             // irmp_data_p->command:
2730:irmp.c        ****             //
2731:irmp.c        ****             //         5432109876543210
2732:irmp.c        ****             //         NAVVvMMMmtxyTTTT
2733:irmp.c        **** 
2734:irmp.c        ****             switch (irmp_bit)
2735:irmp.c        ****             {
2736:irmp.c        ****                 case  0: irmp_tmp_command |= (1<<15); break;                                       
2737:irmp.c        ****                 case  2: irmp_tmp_command |= (1<<13); break;                                       
2738:irmp.c        ****                 case  3: irmp_tmp_command |= (1<<12); break;                                       
2739:irmp.c        ****                 case  4: irmp_tmp_command |= (1<<10); break;                                       
2740:irmp.c        ****                 case  5: irmp_tmp_command |= (1<< 9); break;                                       
2741:irmp.c        ****                 case  6: irmp_tmp_command |= (1<< 8); break;                                       
2742:irmp.c        ****                 case 20: irmp_tmp_command |= (1<< 6); break;                                       
2743:irmp.c        ****                 case 22: irmp_tmp_command |= (1<<11); break;                                       
2744:irmp.c        ****                 case 23: irmp_tmp_command |= (1<< 7); break;                                       
2745:irmp.c        ****                 case 24: irmp_tmp_command |= (1<<14); break;                                       
2746:irmp.c        ****                 case 26: irmp_tmp_command |= (1<< 5); break;                                       
2747:irmp.c        ****                 case 44: irmp_tmp_command |= (1<< 4); break;                                       
2748:irmp.c        ****                 case 66: irmp_tmp_command |= (1<< 3); break;                                       
2749:irmp.c        ****                 case 67: irmp_tmp_command |= (1<< 2); break;                                       
2750:irmp.c        ****                 case 68: irmp_tmp_command |= (1<< 1); break;                                       
2751:irmp.c        ****                 case 69: irmp_tmp_command |= (1<< 0); break;                                       
2752:irmp.c        ****             }
2753:irmp.c        ****         }
2754:irmp.c        ****     }
2755:irmp.c        ****     else
2756:irmp.c        **** #endif // IRMP_SUPPORT_ACP24_PROTOCOL
2757:irmp.c        **** 
2758:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
2759:irmp.c        ****     if (irmp_param.protocol == IRMP_ORTEK_PROTOCOL)
2760:irmp.c        ****     {
2761:irmp.c        ****         if (irmp_bit < 14)
2762:irmp.c        ****         {
2763:irmp.c        ****             if (value)
2764:irmp.c        ****             {
2765:irmp.c        ****                 parity++;
2766:irmp.c        ****             }
2767:irmp.c        ****         }
2768:irmp.c        ****         else if (irmp_bit == 14)
2769:irmp.c        ****         {
2770:irmp.c        ****             if (value)                                                                             
2771:irmp.c        ****             {
2772:irmp.c        ****                 if (parity & 0x01)
2773:irmp.c        ****                 {
2774:irmp.c        ****                     parity = PARITY_CHECK_FAILED;
2775:irmp.c        ****                 }
2776:irmp.c        ****                 else
2777:irmp.c        ****                 {
2778:irmp.c        ****                     parity = PARITY_CHECK_OK;
2779:irmp.c        ****                 }
2780:irmp.c        ****             }
2781:irmp.c        ****             else
2782:irmp.c        ****             {
2783:irmp.c        ****                 if (parity & 0x01)                                                                 
2784:irmp.c        ****                 {
2785:irmp.c        ****                     parity = PARITY_CHECK_OK;
2786:irmp.c        ****                 }
2787:irmp.c        ****                 else
2788:irmp.c        ****                 {
2789:irmp.c        ****                     parity = PARITY_CHECK_FAILED;
2790:irmp.c        ****                 }
2791:irmp.c        ****             }
2792:irmp.c        ****         }
2793:irmp.c        ****     }
2794:irmp.c        ****     else
2795:irmp.c        **** #endif
2796:irmp.c        ****     {
2797:irmp.c        ****         ;
2798:irmp.c        ****     }
2799:irmp.c        **** 
2800:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
2801:irmp.c        ****     if (irmp_bit == 0 && irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL)
2802:irmp.c        ****     {
2803:irmp.c        ****         first_bit = value;
2804:irmp.c        ****     }
2805:irmp.c        ****     else
2806:irmp.c        **** #endif
2807:irmp.c        **** 
2808:irmp.c        ****     if (irmp_bit >= irmp_param.address_offset && irmp_bit < irmp_param.address_end)
 140               	.LM1:
 141 0002 3091 0000 		lds r19,irmp_param+9
 143               	.LM2:
 144 0006 2091 0000 		lds r18,irmp_bit
 146               	.LM3:
 147 000a 2317      		cp r18,r19
 148 000c 00F0      		brlo .L2
 150               	.LM4:
 151 000e 8091 0000 		lds r24,irmp_param+10
 152 0012 2817      		cp r18,r24
 153 0014 00F4      		brsh .L2
 154 0016 4091 0000 		lds r20,irmp_tmp_address
 155 001a 5091 0000 		lds r21,irmp_tmp_address+1
 156 001e 892F      		mov r24,r25
 157 0020 90E0      		ldi r25,0
2809:irmp.c        ****     {
2810:irmp.c        ****         if (irmp_param.lsb_first)
 159               	.LM5:
 160 0022 6091 0000 		lds r22,irmp_param+15
 161 0026 6623      		tst r22
 162 0028 01F0      		breq .L3
2811:irmp.c        ****         {
2812:irmp.c        ****             irmp_tmp_address |= (((uint_fast16_t) (value)) << (irmp_bit - irmp_param.address_offset
 164               	.LM6:
 165 002a E22F      		mov r30,r18
 166 002c E31B      		sub r30,r19
 167 002e FF0B      		sbc r31,r31
 169               	.LM7:
 170 0030 00C0      		rjmp 2f
 171               		1:
 172 0032 880F      		lsl r24
 173 0034 991F      		rol r25
 174               		2:
 175 0036 EA95      		dec r30
 176 0038 02F4      		brpl 1b
 177               	.L6:
2813:irmp.c        ****         }
2814:irmp.c        ****         else
2815:irmp.c        ****         {
2816:irmp.c        ****             irmp_tmp_address <<= 1;
2817:irmp.c        ****             irmp_tmp_address |= value;
 179               	.LM8:
 180 003a 842B      		or r24,r20
 181 003c 952B      		or r25,r21
 182 003e 9093 0000 		sts irmp_tmp_address+1,r25
 183 0042 8093 0000 		sts irmp_tmp_address,r24
 184               	.L4:
2818:irmp.c        ****         }
2819:irmp.c        ****     }
2820:irmp.c        ****     else if (irmp_bit >= irmp_param.command_offset && irmp_bit < irmp_param.command_end)
2821:irmp.c        ****     {
2822:irmp.c        ****         if (irmp_param.lsb_first)
2823:irmp.c        ****         {
2824:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG48_PROTOCOL == 1
2825:irmp.c        ****             if (irmp_param.protocol == IRMP_SAMSUNG48_PROTOCOL && irmp_bit >= 32)
2826:irmp.c        ****             {
2827:irmp.c        ****                 irmp_tmp_id |= (((uint_fast16_t) (value)) << (irmp_bit - 32));   // CV wants cast
2828:irmp.c        ****             }
2829:irmp.c        ****             else
2830:irmp.c        **** #endif
2831:irmp.c        ****             {
2832:irmp.c        ****                 irmp_tmp_command |= (((uint_fast16_t) (value)) << (irmp_bit - irmp_param.command_of
2833:irmp.c        ****             }
2834:irmp.c        ****         }
2835:irmp.c        ****         else
2836:irmp.c        ****         {
2837:irmp.c        ****             irmp_tmp_command <<= 1;
2838:irmp.c        ****             irmp_tmp_command |= value;
2839:irmp.c        ****         }
2840:irmp.c        ****     }
2841:irmp.c        **** 
2842:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
2843:irmp.c        ****     if (irmp_param.protocol == IRMP_NEC_PROTOCOL || irmp_param.protocol == IRMP_NEC42_PROTOCOL)
2844:irmp.c        ****     {
2845:irmp.c        ****         if (irmp_bit < 8)
2846:irmp.c        ****         {
2847:irmp.c        ****             irmp_lgair_address <<= 1;                                                              
2848:irmp.c        ****             irmp_lgair_address |= value;
2849:irmp.c        ****         }
2850:irmp.c        ****         else if (irmp_bit < 24)
2851:irmp.c        ****         {
2852:irmp.c        ****             irmp_lgair_command <<= 1;                                                              
2853:irmp.c        ****             irmp_lgair_command |= value;
2854:irmp.c        ****         }
2855:irmp.c        ****     }
2856:irmp.c        ****     // NO else!
2857:irmp.c        **** #endif
2858:irmp.c        **** 
2859:irmp.c        **** #if IRMP_SUPPORT_NEC42_PROTOCOL == 1
2860:irmp.c        ****     if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && irmp_bit >= 13 && irmp_bit < 26)
2861:irmp.c        ****     {
2862:irmp.c        ****         irmp_tmp_address2 |= (((uint_fast16_t) (value)) << (irmp_bit - 13));                       
2863:irmp.c        ****     }
2864:irmp.c        ****     else
2865:irmp.c        **** #endif
2866:irmp.c        **** 
2867:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
2868:irmp.c        ****     if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit >= SAMSUNG_ID_OFFSET && irmp_bit <
2869:irmp.c        ****     {
2870:irmp.c        ****         irmp_tmp_id |= (((uint_fast16_t) (value)) << (irmp_bit - SAMSUNG_ID_OFFSET));              
2871:irmp.c        ****     }
2872:irmp.c        ****     else
2873:irmp.c        **** #endif
2874:irmp.c        **** 
2875:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
2876:irmp.c        ****     if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL)
2877:irmp.c        ****     {
2878:irmp.c        ****         if (irmp_bit >= 20 && irmp_bit < 24)
2879:irmp.c        ****         {
2880:irmp.c        ****             irmp_tmp_command |= (((uint_fast16_t) (value)) << (irmp_bit - 8));      // store 4 syst
2881:irmp.c        ****         }
2882:irmp.c        ****         else if (irmp_bit >= 24 && irmp_bit < 28)
2883:irmp.c        ****         {
2884:irmp.c        ****             genre2 |= (((uint_fast8_t) (value)) << (irmp_bit - 20));                // store 4 syst
2885:irmp.c        ****         }
2886:irmp.c        **** 
2887:irmp.c        ****         if (irmp_bit < KASEIKYO_COMPLETE_DATA_LEN)
2888:irmp.c        ****         {
2889:irmp.c        ****             if (value)
2890:irmp.c        ****             {
2891:irmp.c        ****                 xor_check[irmp_bit / 8] |= 1 << (irmp_bit % 8);
2892:irmp.c        ****             }
2893:irmp.c        ****             else
2894:irmp.c        ****             {
2895:irmp.c        ****                 xor_check[irmp_bit / 8] &= ~(1 << (irmp_bit % 8));
2896:irmp.c        ****             }
2897:irmp.c        ****         }
2898:irmp.c        ****     }
2899:irmp.c        ****     else
2900:irmp.c        **** #endif
2901:irmp.c        **** 
2902:irmp.c        **** #if IRMP_SUPPORT_MITSU_HEAVY_PROTOCOL == 1
2903:irmp.c        ****     if (irmp_param.protocol == IRMP_MITSU_HEAVY_PROTOCOL)                           // squeeze 64 b
2904:irmp.c        ****     {
2905:irmp.c        ****         if (irmp_bit == 72 )
2906:irmp.c        ****         {                                                                           // irmp_tmp_add
2907:irmp.c        ****             mitsu_parity = PARITY_CHECK_OK;
2908:irmp.c        **** 
2909:irmp.c        ****             check = irmp_tmp_address >> 8;                                          // inverted upp
2910:irmp.c        ****             check = ~ check;
2911:irmp.c        **** 
2912:irmp.c        ****             if (check == (irmp_tmp_address & 0xFF))
2913:irmp.c        ****             {                                                                       // ok:
2914:irmp.c        ****                 irmp_tmp_address <<= 8;                                             // throw away u
2915:irmp.c        ****             }
2916:irmp.c        ****             else
2917:irmp.c        ****             {
2918:irmp.c        ****                 mitsu_parity = PARITY_CHECK_FAILED;
2919:irmp.c        ****             }
2920:irmp.c        **** 
2921:irmp.c        ****             check = irmp_tmp_command >> 8;                                          // inverted upp
2922:irmp.c        ****             check = ~ check;
2923:irmp.c        ****             if (check == (irmp_tmp_command & 0xFF))
2924:irmp.c        ****             {                                                                       // ok:  pack to
2925:irmp.c        ****                 irmp_tmp_address |= irmp_tmp_command & 0xFF;                        // byte 1, byte
2926:irmp.c        ****             }
2927:irmp.c        ****             else
2928:irmp.c        ****             {
2929:irmp.c        ****                 mitsu_parity = PARITY_CHECK_FAILED;
2930:irmp.c        ****             }
2931:irmp.c        ****             irmp_tmp_command = 0;
2932:irmp.c        ****         }
2933:irmp.c        **** 
2934:irmp.c        ****         if (irmp_bit >= 72 )
2935:irmp.c        ****         {                                                                           // receive 3. w
2936:irmp.c        ****             irmp_tmp_command <<= 1;
2937:irmp.c        ****             irmp_tmp_command |= value;
2938:irmp.c        ****         }
2939:irmp.c        ****     }
2940:irmp.c        ****     else
2941:irmp.c        **** #endif // IRMP_SUPPORT_MITSU_HEAVY_PROTOCOL
2942:irmp.c        ****     {
2943:irmp.c        ****         ;
2944:irmp.c        ****     }
2945:irmp.c        **** 
2946:irmp.c        ****     irmp_bit++;
 186               	.LM9:
 187 0046 2F5F      		subi r18,lo8(-(1))
 188 0048 2093 0000 		sts irmp_bit,r18
 189               	/* epilogue start */
2947:irmp.c        **** }
 191               	.LM10:
 192 004c 0895      		ret
 193               	.L3:
2816:irmp.c        ****             irmp_tmp_address |= value;
 195               	.LM11:
 196 004e 440F      		lsl r20
 197 0050 551F      		rol r21
 198 0052 00C0      		rjmp .L6
 199               	.L2:
2820:irmp.c        ****     {
 201               	.LM12:
 202 0054 3091 0000 		lds r19,irmp_param+11
2820:irmp.c        ****     {
 204               	.LM13:
 205 0058 2317      		cp r18,r19
 206 005a 00F0      		brlo .L4
2820:irmp.c        ****     {
 208               	.LM14:
 209 005c 8091 0000 		lds r24,irmp_param+12
 210 0060 2817      		cp r18,r24
 211 0062 00F4      		brsh .L4
 212 0064 4091 0000 		lds r20,irmp_tmp_command
 213 0068 5091 0000 		lds r21,irmp_tmp_command+1
 214 006c 892F      		mov r24,r25
 215 006e 90E0      		ldi r25,0
2822:irmp.c        ****         {
 217               	.LM15:
 218 0070 6091 0000 		lds r22,irmp_param+15
 219 0074 6623      		tst r22
 220 0076 01F0      		breq .L5
2832:irmp.c        ****             }
 222               	.LM16:
 223 0078 E22F      		mov r30,r18
 224 007a E31B      		sub r30,r19
 225 007c FF0B      		sbc r31,r31
2832:irmp.c        ****             }
 227               	.LM17:
 228 007e 00C0      		rjmp 2f
 229               		1:
 230 0080 880F      		lsl r24
 231 0082 991F      		rol r25
 232               		2:
 233 0084 EA95      		dec r30
 234 0086 02F4      		brpl 1b
 235               	.L7:
2838:irmp.c        ****         }
 237               	.LM18:
 238 0088 842B      		or r24,r20
 239 008a 952B      		or r25,r21
 240 008c 9093 0000 		sts irmp_tmp_command+1,r25
 241 0090 8093 0000 		sts irmp_tmp_command,r24
 242 0094 00C0      		rjmp .L4
 243               	.L5:
2837:irmp.c        ****             irmp_tmp_command |= value;
 245               	.LM19:
 246 0096 440F      		lsl r20
 247 0098 551F      		rol r21
 248 009a 00C0      		rjmp .L7
 250               	.Lscope1:
 252               		.stabd	78,0,0
 254               	.global	irmp_init
 256               	irmp_init:
 257               		.stabd	46,0,0
2334:irmp.c        **** #if defined(PIC_CCS) || defined(PIC_C18)                                // PIC: do nothing
 259               	.LM20:
 260               	.LFBB2:
 261               	/* prologue: function */
 262               	/* frame size = 0 */
 263               	/* stack size = 0 */
 264               	.L__stack_usage = 0
2397:irmp.c        ****     IRMP_DDR &= ~(1<<IRMP_BIT);                                         // set pin to input
 266               	.LM21:
 267 009c 5F98      		cbi 0xb,7
2398:irmp.c        **** #endif
 269               	.LM22:
 270 009e 5798      		cbi 0xa,7
 271               	/* epilogue start */
2404:irmp.c        **** #endif
 273               	.LM23:
 274 00a0 0895      		ret
 276               	.Lscope2:
 278               		.stabd	78,0,0
 281               	.global	irmp_get_data
 283               	irmp_get_data:
 284               		.stabd	46,0,0
2415:irmp.c        ****     uint_fast8_t   rtc = FALSE;
 286               	.LM24:
 287               	.LFBB3:
 288               	/* prologue: function */
 289               	/* frame size = 0 */
 290               	/* stack size = 0 */
 291               	.L__stack_usage = 0
 292 00a2 FC01      		movw r30,r24
2421:irmp.c        ****     {
 294               	.LM25:
 295 00a4 8091 0000 		lds r24,irmp_ir_detected
2421:irmp.c        ****     {
 297               	.LM26:
 298 00a8 8823      		tst r24
 299 00aa 01F4      		brne .+2
 300 00ac 00C0      		rjmp .L9
2423:irmp.c        ****         {
 302               	.LM27:
 303 00ae 8091 0000 		lds r24,irmp_protocol
 304 00b2 8230      		cpi r24,lo8(2)
 305 00b4 01F0      		breq .L11
 306 00b6 8233      		cpi r24,lo8(50)
 307 00b8 01F4      		brne .+2
 308 00ba 00C0      		rjmp .L12
 309               	.L13:
2641:irmp.c        ****             irmp_data_p->address  = irmp_address;
 311               	.LM28:
 312 00bc 8091 0000 		lds r24,irmp_protocol
 313 00c0 8083      		st Z,r24
2642:irmp.c        ****             irmp_data_p->command  = irmp_command;
 315               	.LM29:
 316 00c2 8091 0000 		lds r24,irmp_address
 317 00c6 9091 0000 		lds r25,irmp_address+1
 318 00ca 9283      		std Z+2,r25
 319 00cc 8183      		std Z+1,r24
2643:irmp.c        ****             irmp_data_p->flags    = irmp_flags;
 321               	.LM30:
 322 00ce 8091 0000 		lds r24,irmp_command
 323 00d2 9091 0000 		lds r25,irmp_command+1
 324 00d6 9483      		std Z+4,r25
 325 00d8 8383      		std Z+3,r24
2644:irmp.c        **** #if IRMP_SUPPORT_MERLIN_PROTOCOL == 1
 327               	.LM31:
 328 00da 8091 0000 		lds r24,irmp_flags
 329 00de 8583      		std Z+5,r24
 330 00e0 81E0      		ldi r24,lo8(1)
 331 00e2 00C0      		rjmp .L17
 332               	.L11:
2445:irmp.c        ****                 {
 334               	.LM32:
 335 00e4 8091 0000 		lds r24,irmp_command
 336 00e8 9091 0000 		lds r25,irmp_command+1
2445:irmp.c        ****                 {
 338               	.LM33:
 339 00ec 2091 0000 		lds r18,irmp_command
 340 00f0 3091 0000 		lds r19,irmp_command+1
2445:irmp.c        ****                 {
 342               	.LM34:
 343 00f4 892F      		mov r24,r25
 344 00f6 9927      		clr r25
2445:irmp.c        ****                 {
 346               	.LM35:
 347 00f8 2095      		com r18
 348 00fa 3095      		com r19
2445:irmp.c        ****                 {
 350               	.LM36:
 351 00fc 2817      		cp r18,r24
 352 00fe 1906      		cpc __zero_reg__,r25
 353 0100 01F4      		brne .L14
 354               	.L16:
2476:irmp.c        ****                     rtc = TRUE;
 356               	.LM37:
 357 0102 8091 0000 		lds r24,irmp_command
 358 0106 9091 0000 		lds r25,irmp_command+1
 359 010a 9927      		clr r25
 360 010c 9093 0000 		sts irmp_command+1,r25
 361 0110 8093 0000 		sts irmp_command,r24
 362 0114 00C0      		rjmp .L13
 363               	.L14:
2450:irmp.c        ****                 {
 365               	.LM38:
 366 0116 8091 0000 		lds r24,irmp_address
 367 011a 9091 0000 		lds r25,irmp_address+1
2450:irmp.c        ****                 {
 369               	.LM39:
 370 011e 8E3E      		cpi r24,-18
 371 0120 9748      		sbci r25,-121
 372 0122 01F4      		brne .L15
2455:irmp.c        ****                     irmp_address = (irmp_command & 0xFF00) >> 8;
 374               	.LM40:
 375 0124 8BE0      		ldi r24,lo8(11)
 376 0126 8093 0000 		sts irmp_protocol,r24
2456:irmp.c        ****                     irmp_command &= 0x00FF;
 378               	.LM41:
 379 012a 8091 0000 		lds r24,irmp_command
 380 012e 9091 0000 		lds r25,irmp_command+1
 381 0132 892F      		mov r24,r25
 382 0134 9927      		clr r25
2456:irmp.c        ****                     irmp_command &= 0x00FF;
 384               	.LM42:
 385 0136 9093 0000 		sts irmp_address+1,r25
 386 013a 8093 0000 		sts irmp_address,r24
 387 013e 00C0      		rjmp .L16
 388               	.L15:
2465:irmp.c        ****                     rtc = TRUE;
 390               	.LM43:
 391 0140 88E3      		ldi r24,lo8(56)
 392 0142 8093 0000 		sts irmp_protocol,r24
 393 0146 00C0      		rjmp .L13
 394               	.L12:
2474:irmp.c        ****                 {
 396               	.LM44:
 397 0148 8091 0000 		lds r24,irmp_command
 398 014c 9091 0000 		lds r25,irmp_command+1
2474:irmp.c        ****                 {
 400               	.LM45:
 401 0150 2091 0000 		lds r18,irmp_command
 402 0154 3091 0000 		lds r19,irmp_command+1
2474:irmp.c        ****                 {
 404               	.LM46:
 405 0158 892F      		mov r24,r25
 406 015a 9927      		clr r25
2474:irmp.c        ****                 {
 408               	.LM47:
 409 015c 2817      		cp r18,r24
 410 015e 1906      		cpc __zero_reg__,r25
 411 0160 01F0      		breq .L16
2651:irmp.c        ****         }
 413               	.LM48:
 414 0162 1092 0000 		sts irmp_protocol,__zero_reg__
2416:irmp.c        **** #if IRMP_SUPPORT_MERLIN_PROTOCOL == 1
 416               	.LM49:
 417 0166 80E0      		ldi r24,0
 418               	.L17:
2654:irmp.c        ****         irmp_address  = 0;
 420               	.LM50:
 421 0168 1092 0000 		sts irmp_command+1,__zero_reg__
 422 016c 1092 0000 		sts irmp_command,__zero_reg__
2655:irmp.c        ****         irmp_flags    = 0;
 424               	.LM51:
 425 0170 1092 0000 		sts irmp_address+1,__zero_reg__
 426 0174 1092 0000 		sts irmp_address,__zero_reg__
2656:irmp.c        **** 
 428               	.LM52:
 429 0178 1092 0000 		sts irmp_flags,__zero_reg__
2658:irmp.c        ****     }
 431               	.LM53:
 432 017c 1092 0000 		sts irmp_ir_detected,__zero_reg__
 433               	.L9:
 434               	/* epilogue start */
2662:irmp.c        **** 
 436               	.LM54:
 437 0180 0895      		ret
 442               	.Lscope3:
 444               		.stabd	78,0,0
 446               	.global	irmp_ISR
 448               	irmp_ISR:
 449               		.stabd	46,0,0
2948:irmp.c        **** 
2949:irmp.c        **** /*-------------------------------------------------------------------------------------------------
2950:irmp.c        ****  *  store bit
2951:irmp.c        ****  *  @details  store bit in temp address or temp command
2952:irmp.c        ****  *  @param    value to store: 0 or 1
2953:irmp.c        ****  *-------------------------------------------------------------------------------------------------
2954:irmp.c        ****  */
2955:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
2956:irmp.c        **** static void
2957:irmp.c        **** irmp_store_bit2 (uint_fast8_t value)
2958:irmp.c        **** {
2959:irmp.c        ****     uint_fast8_t irmp_bit2;
2960:irmp.c        **** 
2961:irmp.c        ****     if (irmp_param.protocol)
2962:irmp.c        ****     {
2963:irmp.c        ****         irmp_bit2 = irmp_bit - 2;
2964:irmp.c        ****     }
2965:irmp.c        ****     else
2966:irmp.c        ****     {
2967:irmp.c        ****         irmp_bit2 = irmp_bit - 1;
2968:irmp.c        ****     }
2969:irmp.c        **** 
2970:irmp.c        ****     if (irmp_bit2 >= irmp_param2.address_offset && irmp_bit2 < irmp_param2.address_end)
2971:irmp.c        ****     {
2972:irmp.c        ****         irmp_tmp_address2 |= (((uint_fast16_t) (value)) << (irmp_bit2 - irmp_param2.address_offset)
2973:irmp.c        ****     }
2974:irmp.c        ****     else if (irmp_bit2 >= irmp_param2.command_offset && irmp_bit2 < irmp_param2.command_end)
2975:irmp.c        ****     {
2976:irmp.c        ****         irmp_tmp_command2 |= (((uint_fast16_t) (value)) << (irmp_bit2 - irmp_param2.command_offset)
2977:irmp.c        ****     }
2978:irmp.c        **** }
2979:irmp.c        **** #endif // IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_P
2980:irmp.c        **** 
2981:irmp.c        **** /*-------------------------------------------------------------------------------------------------
2982:irmp.c        ****  *  ISR routine
2983:irmp.c        ****  *  @details  ISR routine, called 10000 times per second
2984:irmp.c        ****  *-------------------------------------------------------------------------------------------------
2985:irmp.c        ****  */
2986:irmp.c        **** uint_fast8_t
2987:irmp.c        **** irmp_ISR (void)
2988:irmp.c        **** {
 451               	.LM55:
 452               	.LFBB4:
 453               	/* prologue: function */
 454               	/* frame size = 0 */
 455               	/* stack size = 0 */
 456               	.L__stack_usage = 0
2989:irmp.c        ****     static uint_fast8_t     irmp_start_bit_detected;                                // flag: start 
2990:irmp.c        ****     static uint_fast8_t     wait_for_space;                                         // flag: wait f
2991:irmp.c        ****     static uint_fast8_t     wait_for_start_space;                                   // flag: wait f
2992:irmp.c        ****     static uint_fast8_t     irmp_pulse_time;                                        // count bit ti
2993:irmp.c        ****     static PAUSE_LEN        irmp_pause_time;                                        // count bit ti
2994:irmp.c        ****     static uint_fast16_t    last_irmp_address = 0xFFFF;                             // save last ir
2995:irmp.c        **** #if IRMP_32_BIT == 1
2996:irmp.c        ****     static uint_fast32_t    last_irmp_command = 0xFFFFFFFF;                         // save last ir
2997:irmp.c        **** #else
2998:irmp.c        ****     static uint_fast16_t    last_irmp_command = 0xFFFF;                             // save last ir
2999:irmp.c        **** #endif
3000:irmp.c        ****     static uint_fast16_t    key_repetition_len;                                     // SIRCS repeat
3001:irmp.c        ****     static uint_fast8_t     repetition_frame_number;
3002:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
3003:irmp.c        ****     static uint_fast16_t    last_irmp_denon_command;                                // save last ir
3004:irmp.c        ****     static uint_fast16_t    denon_repetition_len = 0xFFFF;                          // denon repeti
3005:irmp.c        **** #endif
3006:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 || IRMP_SUPPORT_S100_PROTOCOL == 1
3007:irmp.c        ****     static uint_fast8_t     rc5_cmd_bit6;                                           // bit 6 of RC5
3008:irmp.c        **** #endif
3009:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1
3010:irmp.c        ****     static PAUSE_LEN        last_pause;                                             // last pause v
3011:irmp.c        **** #endif
3012:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1 || IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
3013:irmp.c        ****     static uint_fast8_t     last_value;                                             // last bit val
3014:irmp.c        **** #endif
3015:irmp.c        **** #if IRMP_SUPPORT_RCII_PROTOCOL == 1
3016:irmp.c        ****     static uint_fast8_t     waiting_for_2nd_pulse = 0;
3017:irmp.c        **** #endif
3018:irmp.c        ****     uint_fast8_t            irmp_input;                                             // input value
3019:irmp.c        **** 
3020:irmp.c        **** #ifdef ANALYZE
3021:irmp.c        **** 
3022:irmp.c        **** #if 0 // only for test
3023:irmp.c        ****     static uint_fast8_t     last_irmp_start_bit_detected = 0xFF;
3024:irmp.c        ****     static uint_fast8_t     last_irmp_pulse_time = 0xFF;
3025:irmp.c        **** 
3026:irmp.c        ****     if (last_irmp_start_bit_detected != irmp_start_bit_detected || last_irmp_pulse_time != irmp_pul
3027:irmp.c        ****     {
3028:irmp.c        ****         last_irmp_start_bit_detected    = irmp_start_bit_detected;
3029:irmp.c        ****         last_irmp_pulse_time            = irmp_pulse_time;
3030:irmp.c        **** 
3031:irmp.c        ****         printf ("%d %d %d\n", time_counter, irmp_start_bit_detected, irmp_pulse_time);
3032:irmp.c        ****     }
3033:irmp.c        **** #endif // 0
3034:irmp.c        **** 
3035:irmp.c        ****     time_counter++;
3036:irmp.c        **** #endif // ANALYZE
3037:irmp.c        **** 
3038:irmp.c        **** #if defined(__SDCC_stm8)
3039:irmp.c        ****     irmp_input = input(IRMP_GPIO_STRUCT->IDR)
3040:irmp.c        **** #elif defined(__MBED__)
3041:irmp.c        ****     //irmp_input = inputPin;
3042:irmp.c        ****     irmp_input = gpio_read (&gpioIRin);
3043:irmp.c        **** #else
3044:irmp.c        ****     irmp_input = input(IRMP_PIN);
 458               	.LM56:
 459 0182 89B1      		in r24,0x9
3045:irmp.c        **** #endif
3046:irmp.c        **** 
3047:irmp.c        **** #if IRMP_USE_CALLBACK == 1
3048:irmp.c        ****     if (irmp_callback_ptr)
3049:irmp.c        ****     {
3050:irmp.c        ****         static uint_fast8_t last_inverted_input;
3051:irmp.c        **** 
3052:irmp.c        ****         if (last_inverted_input != !irmp_input)
3053:irmp.c        ****         {
3054:irmp.c        ****             (*irmp_callback_ptr) (! irmp_input);
3055:irmp.c        ****             last_inverted_input = !irmp_input;
3056:irmp.c        ****         }
3057:irmp.c        ****     }
3058:irmp.c        **** #endif // IRMP_USE_CALLBACK == 1
3059:irmp.c        **** 
3060:irmp.c        ****     irmp_log(irmp_input);                                                       // log ir signal, i
3061:irmp.c        **** 
3062:irmp.c        ****     if (! irmp_ir_detected)                                                     // ir code already 
 461               	.LM57:
 462 0184 9091 0000 		lds r25,irmp_ir_detected
 464               	.LM58:
 465 0188 9111      		cpse r25,__zero_reg__
 466 018a 00C0      		rjmp .L25
3063:irmp.c        ****     {                                                                           // no...
3064:irmp.c        ****         if (! irmp_start_bit_detected)                                          // start bit detect
 468               	.LM59:
 469 018c 9091 0000 		lds r25,irmp_start_bit_detected.1698
 470 0190 9111      		cpse r25,__zero_reg__
 471 0192 00C0      		rjmp .L23
 472 0194 9091 0000 		lds r25,irmp_pulse_time.1701
3065:irmp.c        ****         {                                                                       // no...
3066:irmp.c        ****             if (! irmp_input)                                                   // receiving burst?
 474               	.LM60:
 475 0198 87FD      		sbrc r24,7
 476 019a 00C0      		rjmp .L24
3067:irmp.c        ****             {                                                                   // yes...
3068:irmp.c        **** //              irmp_busy_flag = TRUE;
3069:irmp.c        **** #ifdef ANALYZE
3070:irmp.c        ****                 if (! irmp_pulse_time)
3071:irmp.c        ****                 {
3072:irmp.c        ****                     ANALYZE_PRINTF("%8.3fms [starting pulse]\n", (double) (time_counter * 1000) / F
3073:irmp.c        ****                 }
3074:irmp.c        **** #endif // ANALYZE
3075:irmp.c        ****                 irmp_pulse_time++;                                              // increment counte
 478               	.LM61:
 479 019c 9F5F      		subi r25,lo8(-(1))
 480 019e 9093 0000 		sts irmp_pulse_time.1701,r25
 481               	.L25:
3076:irmp.c        ****             }
3077:irmp.c        ****             else
3078:irmp.c        ****             {                                                                   // no...
3079:irmp.c        ****                 if (irmp_pulse_time)                                            // it's dark....
3080:irmp.c        ****                 {                                                               // set flags for co
3081:irmp.c        ****                     irmp_start_bit_detected = 1;
3082:irmp.c        ****                     wait_for_start_space    = 1;
3083:irmp.c        ****                     wait_for_space          = 0;
3084:irmp.c        ****                     irmp_tmp_command        = 0;
3085:irmp.c        ****                     irmp_tmp_address        = 0;
3086:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
3087:irmp.c        ****                     genre2                  = 0;
3088:irmp.c        **** #endif
3089:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
3090:irmp.c        ****                     irmp_tmp_id = 0;
3091:irmp.c        **** #endif
3092:irmp.c        **** 
3093:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
3094:irmp.c        ****                     irmp_tmp_command2       = 0;
3095:irmp.c        ****                     irmp_tmp_address2       = 0;
3096:irmp.c        **** #endif
3097:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
3098:irmp.c        ****                     irmp_lgair_command      = 0;
3099:irmp.c        ****                     irmp_lgair_address      = 0;
3100:irmp.c        **** #endif
3101:irmp.c        ****                     irmp_bit                = 0xff;
3102:irmp.c        ****                     irmp_pause_time         = 1;                                // 1st pause: set t
3103:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 || IRMP_SUPPORT_S100_PROTOCOL == 1
3104:irmp.c        ****                     rc5_cmd_bit6            = 0;                                // fm 2010-03-07: b
3105:irmp.c        **** #endif
3106:irmp.c        ****                 }
3107:irmp.c        ****                 else
3108:irmp.c        ****                 {
3109:irmp.c        ****                     if (key_repetition_len < 0xFFFF)                            // avoid overflow o
3110:irmp.c        ****                     {
3111:irmp.c        ****                         key_repetition_len++;
3112:irmp.c        **** 
3113:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
3114:irmp.c        ****                         if (denon_repetition_len < 0xFFFF)                      // avoid overflow o
3115:irmp.c        ****                         {
3116:irmp.c        ****                             denon_repetition_len++;
3117:irmp.c        **** 
3118:irmp.c        ****                             if (denon_repetition_len >= DENON_AUTO_REPETITION_PAUSE_LEN && last_irm
3119:irmp.c        ****                             {
3120:irmp.c        **** #ifdef ANALYZE
3121:irmp.c        ****                                 ANALYZE_PRINTF ("%8.3fms warning: did not receive inverted command 
3122:irmp.c        ****                                                 (double) (time_counter * 1000) / F_INTERRUPTS);
3123:irmp.c        **** #endif // ANALYZE
3124:irmp.c        ****                                 last_irmp_denon_command = 0;
3125:irmp.c        ****                                 denon_repetition_len = 0xFFFF;
3126:irmp.c        ****                             }
3127:irmp.c        ****                         }
3128:irmp.c        **** #endif // IRMP_SUPPORT_DENON_PROTOCOL == 1
3129:irmp.c        ****                     }
3130:irmp.c        ****                 }
3131:irmp.c        ****             }
3132:irmp.c        ****         }
3133:irmp.c        ****         else
3134:irmp.c        ****         {
3135:irmp.c        ****             if (wait_for_start_space)                                           // we have received
3136:irmp.c        ****             {                                                                   // ...and are count
3137:irmp.c        ****                 if (irmp_input)                                                 // still dark?
3138:irmp.c        ****                 {                                                               // yes
3139:irmp.c        ****                     irmp_pause_time++;                                          // increment counte
3140:irmp.c        **** 
3141:irmp.c        **** #if IRMP_SUPPORT_NIKON_PROTOCOL == 1
3142:irmp.c        ****                     if (((irmp_pulse_time < NIKON_START_BIT_PULSE_LEN_MIN || irmp_pulse_time > NIKO
3143:irmp.c        ****                          irmp_pause_time > IRMP_TIMEOUT_NIKON_LEN)
3144:irmp.c        **** #else
3145:irmp.c        ****                     if (irmp_pause_time > IRMP_TIMEOUT_LEN)                     // timeout?
3146:irmp.c        **** #endif
3147:irmp.c        ****                     {                                                           // yes...
3148:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
3149:irmp.c        ****                         if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // don't show eror 
3150:irmp.c        ****                         {
3151:irmp.c        ****                             ;
3152:irmp.c        ****                         }
3153:irmp.c        ****                         else
3154:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
3155:irmp.c        ****                         {
3156:irmp.c        **** #ifdef ANALYZE
3157:irmp.c        ****                             ANALYZE_PRINTF ("%8.3fms error 1: pause after start bit pulse %d too lo
3158:irmp.c        ****                             ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
3159:irmp.c        **** #endif // ANALYZE
3160:irmp.c        ****                         }
3161:irmp.c        **** 
3162:irmp.c        ****                         irmp_start_bit_detected = 0;                            // reset flags, let
3163:irmp.c        ****                         irmp_pulse_time         = 0;
3164:irmp.c        ****                         irmp_pause_time         = 0;
3165:irmp.c        ****                     }
3166:irmp.c        ****                 }
3167:irmp.c        ****                 else
3168:irmp.c        ****                 {                                                               // receiving first 
3169:irmp.c        ****                     IRMP_PARAMETER * irmp_param_p;
3170:irmp.c        ****                     irmp_param_p = (IRMP_PARAMETER *) 0;
3171:irmp.c        **** 
3172:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
3173:irmp.c        ****                     irmp_param2.protocol = 0;
3174:irmp.c        **** #endif
3175:irmp.c        **** 
3176:irmp.c        **** #ifdef ANALYZE
3177:irmp.c        ****                     ANALYZE_PRINTF ("%8.3fms [start-bit: pulse = %2d, pause = %2d]\n", (double) (ti
3178:irmp.c        **** #endif // ANALYZE
3179:irmp.c        **** 
3180:irmp.c        **** #if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
3181:irmp.c        ****                     if (irmp_pulse_time >= SIRCS_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SIRC
3182:irmp.c        ****                         irmp_pause_time >= SIRCS_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SIRC
3183:irmp.c        ****                     {                                                           // it's SIRCS
3184:irmp.c        **** #ifdef ANALYZE
3185:irmp.c        ****                         ANALYZE_PRINTF ("protocol = SIRCS, start bit timings: pulse: %3d - %3d, pau
3186:irmp.c        ****                                         SIRCS_START_BIT_PULSE_LEN_MIN, SIRCS_START_BIT_PULSE_LEN_MA
3187:irmp.c        ****                                         SIRCS_START_BIT_PAUSE_LEN_MIN, SIRCS_START_BIT_PAUSE_LEN_MA
3188:irmp.c        **** #endif // ANALYZE
3189:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &sircs_param;
3190:irmp.c        ****                     }
3191:irmp.c        ****                     else
3192:irmp.c        **** #endif // IRMP_SUPPORT_SIRCS_PROTOCOL == 1
3193:irmp.c        **** 
3194:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
3195:irmp.c        ****                     if (irmp_protocol == IRMP_JVC_PROTOCOL &&                                      
3196:irmp.c        ****                         irmp_pulse_time >= JVC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= JVC_ST
3197:irmp.c        ****                         irmp_pause_time >= JVC_REPEAT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <=
3198:irmp.c        ****                     {
3199:irmp.c        **** #ifdef ANALYZE
3200:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NEC or JVC (type 1) repeat frame, start bit tim
3201:irmp.c        ****                                         JVC_START_BIT_PULSE_LEN_MIN, JVC_START_BIT_PULSE_LEN_MAX,
3202:irmp.c        ****                                         JVC_REPEAT_START_BIT_PAUSE_LEN_MIN, JVC_REPEAT_START_BIT_PA
3203:irmp.c        **** #endif // ANALYZE
3204:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nec_param;
3205:irmp.c        ****                     }
3206:irmp.c        ****                     else
3207:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
3208:irmp.c        **** 
3209:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
3210:irmp.c        ****                     if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_ST
3211:irmp.c        ****                         irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_ST
3212:irmp.c        ****                     {
3213:irmp.c        **** #if IRMP_SUPPORT_NEC42_PROTOCOL == 1
3214:irmp.c        **** #ifdef ANALYZE
3215:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NEC42, start bit timings: pulse: %3d - %3d, pau
3216:irmp.c        ****                                         NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
3217:irmp.c        ****                                         NEC_START_BIT_PAUSE_LEN_MIN, NEC_START_BIT_PAUSE_LEN_MAX);
3218:irmp.c        **** #endif // ANALYZE
3219:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nec42_param;
3220:irmp.c        **** #else
3221:irmp.c        **** #ifdef ANALYZE
3222:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NEC, start bit timings: pulse: %3d - %3d, pause
3223:irmp.c        ****                                         NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
3224:irmp.c        ****                                         NEC_START_BIT_PAUSE_LEN_MIN, NEC_START_BIT_PAUSE_LEN_MAX);
3225:irmp.c        **** #endif // ANALYZE
3226:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nec_param;
3227:irmp.c        **** #endif
3228:irmp.c        ****                     }
3229:irmp.c        ****                     else if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN        && irmp_pulse_ti
3230:irmp.c        ****                              irmp_pause_time >= NEC_REPEAT_START_BIT_PAUSE_LEN_MIN && irmp_pause_ti
3231:irmp.c        ****                     {                                                           // it's NEC
3232:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
3233:irmp.c        ****                         if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // last protocol wa
3234:irmp.c        ****                         {                                                       // some jvc remote 
3235:irmp.c        **** #ifdef ANALYZE
3236:irmp.c        ****                             ANALYZE_PRINTF ("protocol = JVC repeat frame type 2, start bit timings:
3237:irmp.c        ****                                             NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MA
3238:irmp.c        ****                                             NEC_REPEAT_START_BIT_PAUSE_LEN_MIN, NEC_REPEAT_START_BI
3239:irmp.c        **** #endif // ANALYZE
3240:irmp.c        ****                             irmp_param_p = (IRMP_PARAMETER *) &nec_param;
3241:irmp.c        ****                         }
3242:irmp.c        ****                         else
3243:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
3244:irmp.c        ****                         {
3245:irmp.c        **** #ifdef ANALYZE
3246:irmp.c        ****                             ANALYZE_PRINTF ("protocol = NEC (repetition frame), start bit timings: 
3247:irmp.c        ****                                             NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MA
3248:irmp.c        ****                                             NEC_REPEAT_START_BIT_PAUSE_LEN_MIN, NEC_REPEAT_START_BI
3249:irmp.c        **** #endif // ANALYZE
3250:irmp.c        **** 
3251:irmp.c        ****                             irmp_param_p = (IRMP_PARAMETER *) &nec_rep_param;
3252:irmp.c        ****                         }
3253:irmp.c        ****                     }
3254:irmp.c        ****                     else
3255:irmp.c        **** 
3256:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
3257:irmp.c        ****                     if (irmp_protocol == IRMP_JVC_PROTOCOL &&                   // last protocol wa
3258:irmp.c        ****                         irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_ST
3259:irmp.c        ****                         irmp_pause_time >= NEC_0_PAUSE_LEN_MIN         && irmp_pause_time <= NEC_0_
3260:irmp.c        ****                     {                                                           // it's JVC repetit
3261:irmp.c        **** #ifdef ANALYZE
3262:irmp.c        ****                         ANALYZE_PRINTF ("protocol = JVC repeat frame type 3, start bit timings: pul
3263:irmp.c        ****                                         NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
3264:irmp.c        ****                                         NEC_0_PAUSE_LEN_MIN, NEC_0_PAUSE_LEN_MAX);
3265:irmp.c        **** #endif // ANALYZE
3266:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nec_param;
3267:irmp.c        ****                     }
3268:irmp.c        ****                     else
3269:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
3270:irmp.c        **** 
3271:irmp.c        **** #endif // IRMP_SUPPORT_NEC_PROTOCOL == 1
3272:irmp.c        **** 
3273:irmp.c        **** #if IRMP_SUPPORT_TELEFUNKEN_PROTOCOL == 1
3274:irmp.c        ****                     if (irmp_pulse_time >= TELEFUNKEN_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <=
3275:irmp.c        ****                         irmp_pause_time >= TELEFUNKEN_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <=
3276:irmp.c        ****                     {
3277:irmp.c        **** #ifdef ANALYZE
3278:irmp.c        ****                         ANALYZE_PRINTF ("protocol = TELEFUNKEN, start bit timings: pulse: %3d - %3d
3279:irmp.c        ****                                         TELEFUNKEN_START_BIT_PULSE_LEN_MIN, TELEFUNKEN_START_BIT_PU
3280:irmp.c        ****                                         TELEFUNKEN_START_BIT_PAUSE_LEN_MIN, TELEFUNKEN_START_BIT_PA
3281:irmp.c        **** #endif // ANALYZE
3282:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &telefunken_param;
3283:irmp.c        ****                     }
3284:irmp.c        ****                     else
3285:irmp.c        **** #endif // IRMP_SUPPORT_TELEFUNKEN_PROTOCOL == 1
3286:irmp.c        **** 
3287:irmp.c        **** #if IRMP_SUPPORT_ROOMBA_PROTOCOL == 1
3288:irmp.c        ****                     if (irmp_pulse_time >= ROOMBA_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= ROO
3289:irmp.c        ****                         irmp_pause_time >= ROOMBA_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= ROO
3290:irmp.c        ****                     {
3291:irmp.c        **** #ifdef ANALYZE
3292:irmp.c        ****                         ANALYZE_PRINTF ("protocol = ROOMBA, start bit timings: pulse: %3d - %3d, pa
3293:irmp.c        ****                                         ROOMBA_START_BIT_PULSE_LEN_MIN, ROOMBA_START_BIT_PULSE_LEN_
3294:irmp.c        ****                                         ROOMBA_START_BIT_PAUSE_LEN_MIN, ROOMBA_START_BIT_PAUSE_LEN_
3295:irmp.c        **** #endif // ANALYZE
3296:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &roomba_param;
3297:irmp.c        ****                     }
3298:irmp.c        ****                     else
3299:irmp.c        **** #endif // IRMP_SUPPORT_ROOMBA_PROTOCOL == 1
3300:irmp.c        **** 
3301:irmp.c        **** #if IRMP_SUPPORT_ACP24_PROTOCOL == 1
3302:irmp.c        ****                     if (irmp_pulse_time >= ACP24_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= ACP2
3303:irmp.c        ****                         irmp_pause_time >= ACP24_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= ACP2
3304:irmp.c        ****                     {
3305:irmp.c        **** #ifdef ANALYZE
3306:irmp.c        ****                         ANALYZE_PRINTF ("protocol = ACP24, start bit timings: pulse: %3d - %3d, pau
3307:irmp.c        ****                                         ACP24_START_BIT_PULSE_LEN_MIN, ACP24_START_BIT_PULSE_LEN_MA
3308:irmp.c        ****                                         ACP24_START_BIT_PAUSE_LEN_MIN, ACP24_START_BIT_PAUSE_LEN_MA
3309:irmp.c        **** #endif // ANALYZE
3310:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &acp24_param;
3311:irmp.c        ****                     }
3312:irmp.c        ****                     else
3313:irmp.c        **** #endif // IRMP_SUPPORT_ROOMBA_PROTOCOL == 1
3314:irmp.c        **** 
3315:irmp.c        **** #if IRMP_SUPPORT_PENTAX_PROTOCOL == 1
3316:irmp.c        ****                     if (irmp_pulse_time >= PENTAX_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= PEN
3317:irmp.c        ****                         irmp_pause_time >= PENTAX_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= PEN
3318:irmp.c        ****                     {
3319:irmp.c        **** #ifdef ANALYZE
3320:irmp.c        ****                         ANALYZE_PRINTF ("protocol = PENTAX, start bit timings: pulse: %3d - %3d, pa
3321:irmp.c        ****                                         PENTAX_START_BIT_PULSE_LEN_MIN, PENTAX_START_BIT_PULSE_LEN_
3322:irmp.c        ****                                         PENTAX_START_BIT_PAUSE_LEN_MIN, PENTAX_START_BIT_PAUSE_LEN_
3323:irmp.c        **** #endif // ANALYZE
3324:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &pentax_param;
3325:irmp.c        ****                     }
3326:irmp.c        ****                     else
3327:irmp.c        **** #endif // IRMP_SUPPORT_PENTAX_PROTOCOL == 1
3328:irmp.c        **** 
3329:irmp.c        **** #if IRMP_SUPPORT_NIKON_PROTOCOL == 1
3330:irmp.c        ****                     if (irmp_pulse_time >= NIKON_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NIKO
3331:irmp.c        ****                         irmp_pause_time >= NIKON_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NIKO
3332:irmp.c        ****                     {
3333:irmp.c        **** #ifdef ANALYZE
3334:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NIKON, start bit timings: pulse: %3d - %3d, pau
3335:irmp.c        ****                                         NIKON_START_BIT_PULSE_LEN_MIN, NIKON_START_BIT_PULSE_LEN_MA
3336:irmp.c        ****                                         NIKON_START_BIT_PAUSE_LEN_MIN, NIKON_START_BIT_PAUSE_LEN_MA
3337:irmp.c        **** #endif // ANALYZE
3338:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nikon_param;
3339:irmp.c        ****                     }
3340:irmp.c        ****                     else
3341:irmp.c        **** #endif // IRMP_SUPPORT_NIKON_PROTOCOL == 1
3342:irmp.c        **** 
3343:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
3344:irmp.c        ****                     if (irmp_pulse_time >= SAMSUNG_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SA
3345:irmp.c        ****                         irmp_pause_time >= SAMSUNG_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SA
3346:irmp.c        ****                     {                                                           // it's SAMSUNG
3347:irmp.c        **** #ifdef ANALYZE
3348:irmp.c        ****                         ANALYZE_PRINTF ("protocol = SAMSUNG, start bit timings: pulse: %3d - %3d, p
3349:irmp.c        ****                                         SAMSUNG_START_BIT_PULSE_LEN_MIN, SAMSUNG_START_BIT_PULSE_LE
3350:irmp.c        ****                                         SAMSUNG_START_BIT_PAUSE_LEN_MIN, SAMSUNG_START_BIT_PAUSE_LE
3351:irmp.c        **** #endif // ANALYZE
3352:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &samsung_param;
3353:irmp.c        ****                     }
3354:irmp.c        ****                     else
3355:irmp.c        **** #endif // IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
3356:irmp.c        **** 
3357:irmp.c        **** #if IRMP_SUPPORT_SAMSUNGAH_PROTOCOL == 1
3358:irmp.c        ****                     if (irmp_pulse_time >= SAMSUNGAH_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= 
3359:irmp.c        ****                         irmp_pause_time >= SAMSUNGAH_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= 
3360:irmp.c        ****                     {                                                           // it's SAMSUNGAH
3361:irmp.c        **** #ifdef ANALYZE
3362:irmp.c        ****                         ANALYZE_PRINTF ("protocol = SAMSUNGAH, start bit timings: pulse: %3d - %3d,
3363:irmp.c        ****                                         SAMSUNGAH_START_BIT_PULSE_LEN_MIN, SAMSUNGAH_START_BIT_PULS
3364:irmp.c        ****                                         SAMSUNGAH_START_BIT_PAUSE_LEN_MIN, SAMSUNGAH_START_BIT_PAUS
3365:irmp.c        **** #endif // ANALYZE
3366:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &samsungah_param;
3367:irmp.c        ****                     }
3368:irmp.c        ****                     else
3369:irmp.c        **** #endif // IRMP_SUPPORT_SAMSUNGAH_PROTOCOL == 1
3370:irmp.c        **** 
3371:irmp.c        **** #if IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
3372:irmp.c        ****                     if (irmp_pulse_time >= MATSUSHITA_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <=
3373:irmp.c        ****                         irmp_pause_time >= MATSUSHITA_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <=
3374:irmp.c        ****                     {                                                           // it's MATSUSHITA
3375:irmp.c        **** #ifdef ANALYZE
3376:irmp.c        ****                         ANALYZE_PRINTF ("protocol = MATSUSHITA, start bit timings: pulse: %3d - %3d
3377:irmp.c        ****                                         MATSUSHITA_START_BIT_PULSE_LEN_MIN, MATSUSHITA_START_BIT_PU
3378:irmp.c        ****                                         MATSUSHITA_START_BIT_PAUSE_LEN_MIN, MATSUSHITA_START_BIT_PA
3379:irmp.c        **** #endif // ANALYZE
3380:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &matsushita_param;
3381:irmp.c        ****                     }
3382:irmp.c        ****                     else
3383:irmp.c        **** #endif // IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
3384:irmp.c        **** 
3385:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
3386:irmp.c        ****                     if (irmp_pulse_time >= KASEIKYO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= K
3387:irmp.c        ****                         irmp_pause_time >= KASEIKYO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= K
3388:irmp.c        ****                     {                                                           // it's KASEIKYO
3389:irmp.c        **** #ifdef ANALYZE
3390:irmp.c        ****                         ANALYZE_PRINTF ("protocol = KASEIKYO, start bit timings: pulse: %3d - %3d, 
3391:irmp.c        ****                                         KASEIKYO_START_BIT_PULSE_LEN_MIN, KASEIKYO_START_BIT_PULSE_
3392:irmp.c        ****                                         KASEIKYO_START_BIT_PAUSE_LEN_MIN, KASEIKYO_START_BIT_PAUSE_
3393:irmp.c        **** #endif // ANALYZE
3394:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &kaseikyo_param;
3395:irmp.c        ****                     }
3396:irmp.c        ****                     else
3397:irmp.c        **** #endif // IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
3398:irmp.c        **** 
3399:irmp.c        **** #if IRMP_SUPPORT_PANASONIC_PROTOCOL == 1
3400:irmp.c        ****                     if (irmp_pulse_time >= PANASONIC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= 
3401:irmp.c        ****                         irmp_pause_time >= PANASONIC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= 
3402:irmp.c        ****                     {                                                           // it's PANASONIC
3403:irmp.c        **** #ifdef ANALYZE
3404:irmp.c        ****                         ANALYZE_PRINTF ("protocol = PANASONIC, start bit timings: pulse: %3d - %3d,
3405:irmp.c        ****                                         PANASONIC_START_BIT_PULSE_LEN_MIN, PANASONIC_START_BIT_PULS
3406:irmp.c        ****                                         PANASONIC_START_BIT_PAUSE_LEN_MIN, PANASONIC_START_BIT_PAUS
3407:irmp.c        **** #endif // ANALYZE
3408:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &panasonic_param;
3409:irmp.c        ****                     }
3410:irmp.c        ****                     else
3411:irmp.c        **** #endif // IRMP_SUPPORT_PANASONIC_PROTOCOL == 1
3412:irmp.c        **** 
3413:irmp.c        **** #if IRMP_SUPPORT_MITSU_HEAVY_PROTOCOL == 1
3414:irmp.c        ****                     if (irmp_pulse_time >= MITSU_HEAVY_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <
3415:irmp.c        ****                         irmp_pause_time >= MITSU_HEAVY_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <
3416:irmp.c        ****                     {                                                           // it's MITSU_HEAVY
3417:irmp.c        **** #ifdef ANALYZE
3418:irmp.c        ****                         ANALYZE_PRINTF ("protocol = MITSU_HEAVY, start bit timings: pulse: %3d - %3
3419:irmp.c        ****                                         MITSU_HEAVY_START_BIT_PULSE_LEN_MIN, MITSU_HEAVY_START_BIT_
3420:irmp.c        ****                                         MITSU_HEAVY_START_BIT_PAUSE_LEN_MIN, MITSU_HEAVY_START_BIT_
3421:irmp.c        **** #endif // ANALYZE
3422:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &mitsu_heavy_param;
3423:irmp.c        ****                     }
3424:irmp.c        ****                     else
3425:irmp.c        **** #endif // IRMP_SUPPORT_MITSU_HEAVY_PROTOCOL == 1
3426:irmp.c        **** 
3427:irmp.c        **** #if IRMP_SUPPORT_VINCENT_PROTOCOL == 1
3428:irmp.c        ****                     if (irmp_pulse_time >= VINCENT_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= VI
3429:irmp.c        ****                         irmp_pause_time >= VINCENT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= VI
3430:irmp.c        ****                     {                                                           // it's VINCENT
3431:irmp.c        **** #ifdef ANALYZE
3432:irmp.c        ****                         ANALYZE_PRINTF ("protocol = VINCENT, start bit timings: pulse: %3d - %3d, p
3433:irmp.c        ****                                         VINCENT_START_BIT_PULSE_LEN_MIN, VINCENT_START_BIT_PULSE_LE
3434:irmp.c        ****                                         VINCENT_START_BIT_PAUSE_LEN_MIN, VINCENT_START_BIT_PAUSE_LE
3435:irmp.c        **** #endif // ANALYZE
3436:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &vincent_param;
3437:irmp.c        ****                     }
3438:irmp.c        ****                     else
3439:irmp.c        **** #endif // IRMP_SUPPORT_VINCENT_PROTOCOL == 1
3440:irmp.c        **** 
3441:irmp.c        **** #if IRMP_SUPPORT_METZ_PROTOCOL == 1
3442:irmp.c        ****                     if (irmp_pulse_time >= METZ_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= METZ_
3443:irmp.c        ****                         irmp_pause_time >= METZ_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= METZ_
3444:irmp.c        ****                     {
3445:irmp.c        **** #ifdef ANALYZE
3446:irmp.c        ****                         ANALYZE_PRINTF ("protocol = METZ, start bit timings: pulse: %3d - %3d, paus
3447:irmp.c        ****                                         METZ_START_BIT_PULSE_LEN_MIN, METZ_START_BIT_PULSE_LEN_MAX,
3448:irmp.c        ****                                         METZ_START_BIT_PAUSE_LEN_MIN, METZ_START_BIT_PAUSE_LEN_MAX)
3449:irmp.c        **** #endif // ANALYZE
3450:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &metz_param;
3451:irmp.c        ****                     }
3452:irmp.c        ****                     else
3453:irmp.c        **** #endif // IRMP_SUPPORT_METZ_PROTOCOL == 1
3454:irmp.c        **** 
3455:irmp.c        **** #if IRMP_SUPPORT_RADIO1_PROTOCOL == 1
3456:irmp.c        ****                     if (irmp_pulse_time >= RADIO1_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RAD
3457:irmp.c        ****                         irmp_pause_time >= RADIO1_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RAD
3458:irmp.c        ****                     {
3459:irmp.c        **** #ifdef ANALYZE
3460:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RADIO1, start bit timings: pulse: %3d - %3d, pa
3461:irmp.c        ****                                         RADIO1_START_BIT_PULSE_LEN_MIN, RADIO1_START_BIT_PULSE_LEN_
3462:irmp.c        ****                                         RADIO1_START_BIT_PAUSE_LEN_MIN, RADIO1_START_BIT_PAUSE_LEN_
3463:irmp.c        **** #endif // ANALYZE
3464:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &radio1_param;
3465:irmp.c        ****                     }
3466:irmp.c        ****                     else
3467:irmp.c        **** #endif // IRMP_SUPPORT_RRADIO1_PROTOCOL == 1
3468:irmp.c        **** 
3469:irmp.c        **** #if IRMP_SUPPORT_RECS80_PROTOCOL == 1
3470:irmp.c        ****                     if (irmp_pulse_time >= RECS80_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= REC
3471:irmp.c        ****                         irmp_pause_time >= RECS80_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= REC
3472:irmp.c        ****                     {                                                           // it's RECS80
3473:irmp.c        **** #ifdef ANALYZE
3474:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RECS80, start bit timings: pulse: %3d - %3d, pa
3475:irmp.c        ****                                         RECS80_START_BIT_PULSE_LEN_MIN, RECS80_START_BIT_PULSE_LEN_
3476:irmp.c        ****                                         RECS80_START_BIT_PAUSE_LEN_MIN, RECS80_START_BIT_PAUSE_LEN_
3477:irmp.c        **** #endif // ANALYZE
3478:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &recs80_param;
3479:irmp.c        ****                     }
3480:irmp.c        ****                     else
3481:irmp.c        **** #endif // IRMP_SUPPORT_RECS80_PROTOCOL == 1
3482:irmp.c        **** 
3483:irmp.c        **** #if IRMP_SUPPORT_S100_PROTOCOL == 1
3484:irmp.c        ****                     if (((irmp_pulse_time >= S100_START_BIT_LEN_MIN     && irmp_pulse_time <= S100_
3485:irmp.c        ****                          (irmp_pulse_time >= 2 * S100_START_BIT_LEN_MIN && irmp_pulse_time <= 2 * S
3486:irmp.c        ****                         ((irmp_pause_time >= S100_START_BIT_LEN_MIN     && irmp_pause_time <= S100_
3487:irmp.c        ****                          (irmp_pause_time >= 2 * S100_START_BIT_LEN_MIN && irmp_pause_time <= 2 * S
3488:irmp.c        ****                     {                                                           // it's S100
3489:irmp.c        **** #ifdef ANALYZE
3490:irmp.c        ****                         ANALYZE_PRINTF ("protocol = S100, start bit timings: pulse: %3d - %3d, paus
3491:irmp.c        ****                                         S100_START_BIT_LEN_MIN, S100_START_BIT_LEN_MAX,
3492:irmp.c        ****                                         2 * S100_START_BIT_LEN_MIN, 2 * S100_START_BIT_LEN_MAX,
3493:irmp.c        ****                                         S100_START_BIT_LEN_MIN, S100_START_BIT_LEN_MAX,
3494:irmp.c        ****                                         2 * S100_START_BIT_LEN_MIN, 2 * S100_START_BIT_LEN_MAX);
3495:irmp.c        **** #endif // ANALYZE
3496:irmp.c        **** 
3497:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &s100_param;
3498:irmp.c        ****                         last_pause = irmp_pause_time;
3499:irmp.c        **** 
3500:irmp.c        ****                         if ((irmp_pulse_time > S100_START_BIT_LEN_MAX && irmp_pulse_time <= 2 * S10
3501:irmp.c        ****                             (irmp_pause_time > S100_START_BIT_LEN_MAX && irmp_pause_time <= 2 * S10
3502:irmp.c        ****                         {
3503:irmp.c        ****                           last_value  = 0;
3504:irmp.c        ****                           rc5_cmd_bit6 = 1<<6;
3505:irmp.c        ****                         }
3506:irmp.c        ****                         else
3507:irmp.c        ****                         {
3508:irmp.c        ****                           last_value  = 1;
3509:irmp.c        ****                         }
3510:irmp.c        ****                     }
3511:irmp.c        ****                     else
3512:irmp.c        **** #endif // IRMP_SUPPORT_S100_PROTOCOL == 1
3513:irmp.c        **** 
3514:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1
3515:irmp.c        ****                     if (((irmp_pulse_time >= RC5_START_BIT_LEN_MIN     && irmp_pulse_time <= RC5_ST
3516:irmp.c        ****                          (irmp_pulse_time >= 2 * RC5_START_BIT_LEN_MIN && irmp_pulse_time <= 2 * RC
3517:irmp.c        ****                         ((irmp_pause_time >= RC5_START_BIT_LEN_MIN     && irmp_pause_time <= RC5_ST
3518:irmp.c        ****                          (irmp_pause_time >= 2 * RC5_START_BIT_LEN_MIN && irmp_pause_time <= 2 * RC
3519:irmp.c        ****                     {                                                           // it's RC5
3520:irmp.c        **** #if IRMP_SUPPORT_FDC_PROTOCOL == 1
3521:irmp.c        ****                         if (irmp_pulse_time >= FDC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= FD
3522:irmp.c        ****                             irmp_pause_time >= FDC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= FD
3523:irmp.c        ****                         {
3524:irmp.c        **** #ifdef ANALYZE
3525:irmp.c        ****                             ANALYZE_PRINTF ("protocol = RC5 or FDC\n");
3526:irmp.c        ****                             ANALYZE_PRINTF ("FDC start bit timings: pulse: %3d - %3d, pause: %3d - 
3527:irmp.c        ****                                             FDC_START_BIT_PULSE_LEN_MIN, FDC_START_BIT_PULSE_LEN_MA
3528:irmp.c        ****                                             FDC_START_BIT_PAUSE_LEN_MIN, FDC_START_BIT_PAUSE_LEN_MA
3529:irmp.c        ****                             ANALYZE_PRINTF ("RC5 start bit timings: pulse: %3d - %3d, pause: %3d - 
3530:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
3531:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX);
3532:irmp.c        **** #endif // ANALYZE
3533:irmp.c        ****                             memcpy_P (&irmp_param2, &fdc_param, sizeof (IRMP_PARAMETER));
3534:irmp.c        ****                         }
3535:irmp.c        ****                         else
3536:irmp.c        **** #endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
3537:irmp.c        **** 
3538:irmp.c        **** #if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
3539:irmp.c        ****                         if (irmp_pulse_time >= RCCAR_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= 
3540:irmp.c        ****                             irmp_pause_time >= RCCAR_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= 
3541:irmp.c        ****                         {
3542:irmp.c        **** #ifdef ANALYZE
3543:irmp.c        ****                             ANALYZE_PRINTF ("protocol = RC5 or RCCAR\n");
3544:irmp.c        ****                             ANALYZE_PRINTF ("RCCAR start bit timings: pulse: %3d - %3d, pause: %3d 
3545:irmp.c        ****                                             RCCAR_START_BIT_PULSE_LEN_MIN, RCCAR_START_BIT_PULSE_LE
3546:irmp.c        ****                                             RCCAR_START_BIT_PAUSE_LEN_MIN, RCCAR_START_BIT_PAUSE_LE
3547:irmp.c        ****                             ANALYZE_PRINTF ("RC5 start bit timings: pulse: %3d - %3d, pause: %3d - 
3548:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
3549:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX);
3550:irmp.c        **** #endif // ANALYZE
3551:irmp.c        ****                             memcpy_P (&irmp_param2, &rccar_param, sizeof (IRMP_PARAMETER));
3552:irmp.c        ****                         }
3553:irmp.c        ****                         else
3554:irmp.c        **** #endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
3555:irmp.c        ****                         {
3556:irmp.c        **** #ifdef ANALYZE
3557:irmp.c        ****                             ANALYZE_PRINTF ("protocol = RC5, start bit timings: pulse: %3d - %3d, p
3558:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
3559:irmp.c        ****                                             2 * RC5_START_BIT_LEN_MIN, 2 * RC5_START_BIT_LEN_MAX,
3560:irmp.c        ****                                             RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
3561:irmp.c        ****                                             2 * RC5_START_BIT_LEN_MIN, 2 * RC5_START_BIT_LEN_MAX);
3562:irmp.c        **** #endif // ANALYZE
3563:irmp.c        ****                         }
3564:irmp.c        **** 
3565:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &rc5_param;
3566:irmp.c        ****                         last_pause = irmp_pause_time;
3567:irmp.c        **** 
3568:irmp.c        ****                         if ((irmp_pulse_time > RC5_START_BIT_LEN_MAX && irmp_pulse_time <= 2 * RC5_
3569:irmp.c        ****                             (irmp_pause_time > RC5_START_BIT_LEN_MAX && irmp_pause_time <= 2 * RC5_
3570:irmp.c        ****                         {
3571:irmp.c        ****                             last_value  = 0;
3572:irmp.c        ****                             rc5_cmd_bit6 = 1<<6;
3573:irmp.c        ****                         }
3574:irmp.c        ****                         else
3575:irmp.c        ****                         {
3576:irmp.c        ****                             last_value  = 1;
3577:irmp.c        ****                         }
3578:irmp.c        ****                     }
3579:irmp.c        ****                     else
3580:irmp.c        **** #endif // IRMP_SUPPORT_RC5_PROTOCOL == 1
3581:irmp.c        **** 
3582:irmp.c        **** #if IRMP_SUPPORT_RCII_PROTOCOL == 1
3583:irmp.c        ****                     if ((irmp_pulse_time >= RCII_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RCII
3584:irmp.c        ****                         (irmp_pause_time >= RCII_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RCII
3585:irmp.c        ****                     {                                                           // it's RCII
3586:irmp.c        **** #ifdef ANALYZE
3587:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RCII, start bit timings: pulse: %3d - %3d, paus
3588:irmp.c        ****                                         RCII_START_BIT_PULSE_LEN_MIN, RCII_START_BIT_PULSE_LEN_MAX,
3589:irmp.c        ****                                         RCII_START_BIT_PAUSE_LEN_MIN, RCII_START_BIT_PAUSE_LEN_MAX)
3590:irmp.c        **** #endif // ANALYZE
3591:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &rcii_param;
3592:irmp.c        ****                         last_pause = irmp_pause_time;
3593:irmp.c        ****                         waiting_for_2nd_pulse = 1;
3594:irmp.c        ****                         last_value  = 1;
3595:irmp.c        ****                     }
3596:irmp.c        ****                     else
3597:irmp.c        **** #endif // IRMP_SUPPORT_RCII_PROTOCOL == 1
3598:irmp.c        **** 
3599:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
3600:irmp.c        ****                     if ( (irmp_pulse_time >= DENON_PULSE_LEN_MIN && irmp_pulse_time <= DENON_PULSE_
3601:irmp.c        ****                         ((irmp_pause_time >= DENON_1_PAUSE_LEN_MIN && irmp_pause_time <= DENON_1_PA
3602:irmp.c        ****                          (irmp_pause_time >= DENON_0_PAUSE_LEN_MIN && irmp_pause_time <= DENON_0_PA
3603:irmp.c        ****                     {                                                           // it's DENON
3604:irmp.c        **** #ifdef ANALYZE
3605:irmp.c        ****                         ANALYZE_PRINTF ("protocol = DENON, start bit timings: pulse: %3d - %3d, pau
3606:irmp.c        ****                                         DENON_PULSE_LEN_MIN, DENON_PULSE_LEN_MAX,
3607:irmp.c        ****                                         DENON_1_PAUSE_LEN_MIN, DENON_1_PAUSE_LEN_MAX,
3608:irmp.c        ****                                         DENON_0_PAUSE_LEN_MIN, DENON_0_PAUSE_LEN_MAX);
3609:irmp.c        **** #endif // ANALYZE
3610:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &denon_param;
3611:irmp.c        ****                     }
3612:irmp.c        ****                     else
3613:irmp.c        **** #endif // IRMP_SUPPORT_DENON_PROTOCOL == 1
3614:irmp.c        **** 
3615:irmp.c        **** #if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
3616:irmp.c        ****                     if ( (irmp_pulse_time >= THOMSON_PULSE_LEN_MIN && irmp_pulse_time <= THOMSON_PU
3617:irmp.c        ****                         ((irmp_pause_time >= THOMSON_1_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_
3618:irmp.c        ****                          (irmp_pause_time >= THOMSON_0_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_
3619:irmp.c        ****                     {                                                           // it's THOMSON
3620:irmp.c        **** #ifdef ANALYZE
3621:irmp.c        ****                         ANALYZE_PRINTF ("protocol = THOMSON, start bit timings: pulse: %3d - %3d, p
3622:irmp.c        ****                                         THOMSON_PULSE_LEN_MIN, THOMSON_PULSE_LEN_MAX,
3623:irmp.c        ****                                         THOMSON_1_PAUSE_LEN_MIN, THOMSON_1_PAUSE_LEN_MAX,
3624:irmp.c        ****                                         THOMSON_0_PAUSE_LEN_MIN, THOMSON_0_PAUSE_LEN_MAX);
3625:irmp.c        **** #endif // ANALYZE
3626:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &thomson_param;
3627:irmp.c        ****                     }
3628:irmp.c        ****                     else
3629:irmp.c        **** #endif // IRMP_SUPPORT_THOMSON_PROTOCOL == 1
3630:irmp.c        **** 
3631:irmp.c        **** #if IRMP_SUPPORT_BOSE_PROTOCOL == 1
3632:irmp.c        ****                     if (irmp_pulse_time >= BOSE_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= BOSE_
3633:irmp.c        ****                         irmp_pause_time >= BOSE_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= BOSE_
3634:irmp.c        ****                     {
3635:irmp.c        **** #ifdef ANALYZE
3636:irmp.c        ****                         ANALYZE_PRINTF ("protocol = BOSE, start bit timings: pulse: %3d - %3d, paus
3637:irmp.c        ****                                         BOSE_START_BIT_PULSE_LEN_MIN, BOSE_START_BIT_PULSE_LEN_MAX,
3638:irmp.c        ****                                         BOSE_START_BIT_PAUSE_LEN_MIN, BOSE_START_BIT_PAUSE_LEN_MAX)
3639:irmp.c        **** #endif // ANALYZE
3640:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &bose_param;
3641:irmp.c        ****                     }
3642:irmp.c        ****                     else
3643:irmp.c        **** #endif // IRMP_SUPPORT_BOSE_PROTOCOL == 1
3644:irmp.c        **** 
3645:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
3646:irmp.c        ****                     if (irmp_pulse_time >= RC6_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RC6_ST
3647:irmp.c        ****                         irmp_pause_time >= RC6_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RC6_ST
3648:irmp.c        ****                     {                                                           // it's RC6
3649:irmp.c        **** #ifdef ANALYZE
3650:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RC6, start bit timings: pulse: %3d - %3d, pause
3651:irmp.c        ****                                         RC6_START_BIT_PULSE_LEN_MIN, RC6_START_BIT_PULSE_LEN_MAX,
3652:irmp.c        ****                                         RC6_START_BIT_PAUSE_LEN_MIN, RC6_START_BIT_PAUSE_LEN_MAX);
3653:irmp.c        **** #endif // ANALYZE
3654:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &rc6_param;
3655:irmp.c        ****                         last_pause = 0;
3656:irmp.c        ****                         last_value = 1;
3657:irmp.c        ****                     }
3658:irmp.c        ****                     else
3659:irmp.c        **** #endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
3660:irmp.c        **** 
3661:irmp.c        **** #if IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
3662:irmp.c        ****                     if (irmp_pulse_time >= RECS80EXT_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= 
3663:irmp.c        ****                         irmp_pause_time >= RECS80EXT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= 
3664:irmp.c        ****                     {                                                           // it's RECS80EXT
3665:irmp.c        **** #ifdef ANALYZE
3666:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RECS80EXT, start bit timings: pulse: %3d - %3d,
3667:irmp.c        ****                                         RECS80EXT_START_BIT_PULSE_LEN_MIN, RECS80EXT_START_BIT_PULS
3668:irmp.c        ****                                         RECS80EXT_START_BIT_PAUSE_LEN_MIN, RECS80EXT_START_BIT_PAUS
3669:irmp.c        **** #endif // ANALYZE
3670:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &recs80ext_param;
3671:irmp.c        ****                     }
3672:irmp.c        ****                     else
3673:irmp.c        **** #endif // IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
3674:irmp.c        **** 
3675:irmp.c        **** #if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
3676:irmp.c        ****                     if (irmp_pulse_time >= NUBERT_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NUB
3677:irmp.c        ****                         irmp_pause_time >= NUBERT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NUB
3678:irmp.c        ****                     {                                                           // it's NUBERT
3679:irmp.c        **** #ifdef ANALYZE
3680:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NUBERT, start bit timings: pulse: %3d - %3d, pa
3681:irmp.c        ****                                         NUBERT_START_BIT_PULSE_LEN_MIN, NUBERT_START_BIT_PULSE_LEN_
3682:irmp.c        ****                                         NUBERT_START_BIT_PAUSE_LEN_MIN, NUBERT_START_BIT_PAUSE_LEN_
3683:irmp.c        **** #endif // ANALYZE
3684:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &nubert_param;
3685:irmp.c        ****                     }
3686:irmp.c        ****                     else
3687:irmp.c        **** #endif // IRMP_SUPPORT_NUBERT_PROTOCOL == 1
3688:irmp.c        **** 
3689:irmp.c        **** #if IRMP_SUPPORT_FAN_PROTOCOL == 1
3690:irmp.c        ****                     if (irmp_pulse_time >= FAN_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= FAN_ST
3691:irmp.c        ****                         irmp_pause_time >= FAN_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= FAN_ST
3692:irmp.c        ****                     {                                                           // it's FAN
3693:irmp.c        **** #ifdef ANALYZE
3694:irmp.c        ****                         ANALYZE_PRINTF ("protocol = FAN, start bit timings: pulse: %3d - %3d, pause
3695:irmp.c        ****                                         FAN_START_BIT_PULSE_LEN_MIN, FAN_START_BIT_PULSE_LEN_MAX,
3696:irmp.c        ****                                         FAN_START_BIT_PAUSE_LEN_MIN, FAN_START_BIT_PAUSE_LEN_MAX);
3697:irmp.c        **** #endif // ANALYZE
3698:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &fan_param;
3699:irmp.c        ****                     }
3700:irmp.c        ****                     else
3701:irmp.c        **** #endif // IRMP_SUPPORT_FAN_PROTOCOL == 1
3702:irmp.c        **** 
3703:irmp.c        **** #if IRMP_SUPPORT_SPEAKER_PROTOCOL == 1
3704:irmp.c        ****                     if (irmp_pulse_time >= SPEAKER_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SP
3705:irmp.c        ****                         irmp_pause_time >= SPEAKER_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SP
3706:irmp.c        ****                     {                                                           // it's SPEAKER
3707:irmp.c        **** #ifdef ANALYZE
3708:irmp.c        ****                         ANALYZE_PRINTF ("protocol = SPEAKER, start bit timings: pulse: %3d - %3d, p
3709:irmp.c        ****                                         SPEAKER_START_BIT_PULSE_LEN_MIN, SPEAKER_START_BIT_PULSE_LE
3710:irmp.c        ****                                         SPEAKER_START_BIT_PAUSE_LEN_MIN, SPEAKER_START_BIT_PAUSE_LE
3711:irmp.c        **** #endif // ANALYZE
3712:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &speaker_param;
3713:irmp.c        ****                     }
3714:irmp.c        ****                     else
3715:irmp.c        **** #endif // IRMP_SUPPORT_SPEAKER_PROTOCOL == 1
3716:irmp.c        **** 
3717:irmp.c        **** #if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
3718:irmp.c        ****                     if (irmp_pulse_time >= BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN && irmp_pulse_time
3719:irmp.c        ****                         irmp_pause_time >= BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN && irmp_pause_time
3720:irmp.c        ****                     {                                                           // it's BANG_OLUFSE
3721:irmp.c        **** #ifdef ANALYZE
3722:irmp.c        ****                         ANALYZE_PRINTF ("protocol = BANG_OLUFSEN\n");
3723:irmp.c        ****                         ANALYZE_PRINTF ("start bit 1 timings: pulse: %3d - %3d, pause: %3d - %3d\n"
3724:irmp.c        ****                                         BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN, BANG_OLUFSEN_START_B
3725:irmp.c        ****                                         BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN, BANG_OLUFSEN_START_B
3726:irmp.c        ****                         ANALYZE_PRINTF ("start bit 2 timings: pulse: %3d - %3d, pause: %3d - %3d\n"
3727:irmp.c        ****                                         BANG_OLUFSEN_START_BIT2_PULSE_LEN_MIN, BANG_OLUFSEN_START_B
3728:irmp.c        ****                                         BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MIN, BANG_OLUFSEN_START_B
3729:irmp.c        ****                         ANALYZE_PRINTF ("start bit 3 timings: pulse: %3d - %3d, pause: %3d - %3d\n"
3730:irmp.c        ****                                         BANG_OLUFSEN_START_BIT3_PULSE_LEN_MIN, BANG_OLUFSEN_START_B
3731:irmp.c        ****                                         BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN, BANG_OLUFSEN_START_B
3732:irmp.c        ****                         ANALYZE_PRINTF ("start bit 4 timings: pulse: %3d - %3d, pause: %3d - %3d\n"
3733:irmp.c        ****                                         BANG_OLUFSEN_START_BIT4_PULSE_LEN_MIN, BANG_OLUFSEN_START_B
3734:irmp.c        ****                                         BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MIN, BANG_OLUFSEN_START_B
3735:irmp.c        **** #endif // ANALYZE
3736:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &bang_olufsen_param;
3737:irmp.c        ****                         last_value = 0;
3738:irmp.c        ****                     }
3739:irmp.c        ****                     else
3740:irmp.c        **** #endif // IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
3741:irmp.c        **** 
3742:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
3743:irmp.c        ****                     if (irmp_pulse_time >= GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN && irmp_pulse_time 
3744:irmp.c        ****                         irmp_pause_time >= GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN && irmp_pause_time 
3745:irmp.c        ****                     {                                                           // it's GRUNDIG
3746:irmp.c        **** #ifdef ANALYZE
3747:irmp.c        ****                         ANALYZE_PRINTF ("protocol = GRUNDIG, pre bit timings: pulse: %3d - %3d, pau
3748:irmp.c        ****                                         GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN, GRUNDIG_NOKIA_IR60_ST
3749:irmp.c        ****                                         GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN, GRUNDIG_NOKIA_IR60_PR
3750:irmp.c        **** #endif // ANALYZE
3751:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &grundig_param;
3752:irmp.c        ****                         last_pause = irmp_pause_time;
3753:irmp.c        ****                         last_value  = 1;
3754:irmp.c        ****                     }
3755:irmp.c        ****                     else
3756:irmp.c        **** #endif // IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
3757:irmp.c        **** 
3758:irmp.c        **** #if IRMP_SUPPORT_MERLIN_PROTOCOL == 1 // check MERLIN before RUWIDO!
3759:irmp.c        ****                     if (irmp_pulse_time >= MERLIN_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= MER
3760:irmp.c        ****                         irmp_pause_time >= MERLIN_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= MER
3761:irmp.c        ****                     {                                                           // it's MERLIN
3762:irmp.c        **** #ifdef ANALYZE
3763:irmp.c        ****                         ANALYZE_PRINTF ("protocol = MERLIN, start bit timings: pulse: %3d - %3d, pa
3764:irmp.c        ****                                         MERLIN_START_BIT_PULSE_LEN_MIN, MERLIN_START_BIT_PULSE_LEN_
3765:irmp.c        ****                                         MERLIN_START_BIT_PAUSE_LEN_MIN, MERLIN_START_BIT_PAUSE_LEN_
3766:irmp.c        **** #endif // ANALYZE
3767:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &merlin_param;
3768:irmp.c        ****                         last_pause = irmp_pause_time;
3769:irmp.c        ****                         last_value = 1;
3770:irmp.c        ****                     }
3771:irmp.c        ****                     else
3772:irmp.c        **** #endif // IRMP_SUPPORT_MERLIN_PROTOCOL == 1
3773:irmp.c        **** 
3774:irmp.c        **** #if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
3775:irmp.c        ****                     if (((irmp_pulse_time >= SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN && irmp_puls
3776:irmp.c        ****                          (irmp_pulse_time >= 2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN && irmp_
3777:irmp.c        ****                         ((irmp_pause_time >= SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN && irmp_paus
3778:irmp.c        ****                          (irmp_pause_time >= 2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN && irmp_
3779:irmp.c        ****                     {                                                           // it's RUWIDO or S
3780:irmp.c        **** #ifdef ANALYZE
3781:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RUWIDO, start bit timings: pulse: %3d - %3d or 
3782:irmp.c        ****                                         SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN,   SIEMENS_OR_RUW
3783:irmp.c        ****                                         2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN, 2 * SIEMENS_
3784:irmp.c        ****                                         SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN,   SIEMENS_OR_RUW
3785:irmp.c        ****                                         2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN, 2 * SIEMENS_
3786:irmp.c        **** #endif // ANALYZE
3787:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &ruwido_param;
3788:irmp.c        ****                         last_pause = irmp_pause_time;
3789:irmp.c        ****                         last_value  = 1;
3790:irmp.c        ****                     }
3791:irmp.c        ****                     else
3792:irmp.c        **** #endif // IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
3793:irmp.c        **** 
3794:irmp.c        **** #if IRMP_SUPPORT_FDC_PROTOCOL == 1
3795:irmp.c        ****                     if (irmp_pulse_time >= FDC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= FDC_ST
3796:irmp.c        ****                         irmp_pause_time >= FDC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= FDC_ST
3797:irmp.c        ****                     {
3798:irmp.c        **** #ifdef ANALYZE
3799:irmp.c        ****                         ANALYZE_PRINTF ("protocol = FDC, start bit timings: pulse: %3d - %3d, pause
3800:irmp.c        ****                                         FDC_START_BIT_PULSE_LEN_MIN, FDC_START_BIT_PULSE_LEN_MAX,
3801:irmp.c        ****                                         FDC_START_BIT_PAUSE_LEN_MIN, FDC_START_BIT_PAUSE_LEN_MAX);
3802:irmp.c        **** #endif // ANALYZE
3803:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &fdc_param;
3804:irmp.c        ****                     }
3805:irmp.c        ****                     else
3806:irmp.c        **** #endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
3807:irmp.c        **** 
3808:irmp.c        **** #if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
3809:irmp.c        ****                     if (irmp_pulse_time >= RCCAR_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RCCA
3810:irmp.c        ****                         irmp_pause_time >= RCCAR_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RCCA
3811:irmp.c        ****                     {
3812:irmp.c        **** #ifdef ANALYZE
3813:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RCCAR, start bit timings: pulse: %3d - %3d, pau
3814:irmp.c        ****                                         RCCAR_START_BIT_PULSE_LEN_MIN, RCCAR_START_BIT_PULSE_LEN_MA
3815:irmp.c        ****                                         RCCAR_START_BIT_PAUSE_LEN_MIN, RCCAR_START_BIT_PAUSE_LEN_MA
3816:irmp.c        **** #endif // ANALYZE
3817:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &rccar_param;
3818:irmp.c        ****                     }
3819:irmp.c        ****                     else
3820:irmp.c        **** #endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
3821:irmp.c        **** 
3822:irmp.c        **** #if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
3823:irmp.c        ****                     if (irmp_pulse_time >= KATHREIN_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= K
3824:irmp.c        ****                         irmp_pause_time >= KATHREIN_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= K
3825:irmp.c        ****                     {                                                           // it's KATHREIN
3826:irmp.c        **** #ifdef ANALYZE
3827:irmp.c        ****                         ANALYZE_PRINTF ("protocol = KATHREIN, start bit timings: pulse: %3d - %3d, 
3828:irmp.c        ****                                         KATHREIN_START_BIT_PULSE_LEN_MIN, KATHREIN_START_BIT_PULSE_
3829:irmp.c        ****                                         KATHREIN_START_BIT_PAUSE_LEN_MIN, KATHREIN_START_BIT_PAUSE_
3830:irmp.c        **** #endif // ANALYZE
3831:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &kathrein_param;
3832:irmp.c        ****                     }
3833:irmp.c        ****                     else
3834:irmp.c        **** #endif // IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
3835:irmp.c        **** 
3836:irmp.c        **** #if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
3837:irmp.c        ****                     if (irmp_pulse_time >= NETBOX_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NET
3838:irmp.c        ****                         irmp_pause_time >= NETBOX_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NET
3839:irmp.c        ****                     {                                                           // it's NETBOX
3840:irmp.c        **** #ifdef ANALYZE
3841:irmp.c        ****                         ANALYZE_PRINTF ("protocol = NETBOX, start bit timings: pulse: %3d - %3d, pa
3842:irmp.c        ****                                         NETBOX_START_BIT_PULSE_LEN_MIN, NETBOX_START_BIT_PULSE_LEN_
3843:irmp.c        ****                                         NETBOX_START_BIT_PAUSE_LEN_MIN, NETBOX_START_BIT_PAUSE_LEN_
3844:irmp.c        **** #endif // ANALYZE
3845:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &netbox_param;
3846:irmp.c        ****                     }
3847:irmp.c        ****                     else
3848:irmp.c        **** #endif // IRMP_SUPPORT_NETBOX_PROTOCOL == 1
3849:irmp.c        **** 
3850:irmp.c        **** #if IRMP_SUPPORT_LEGO_PROTOCOL == 1
3851:irmp.c        ****                     if (irmp_pulse_time >= LEGO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= LEGO_
3852:irmp.c        ****                         irmp_pause_time >= LEGO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= LEGO_
3853:irmp.c        ****                     {
3854:irmp.c        **** #ifdef ANALYZE
3855:irmp.c        ****                         ANALYZE_PRINTF ("protocol = LEGO, start bit timings: pulse: %3d - %3d, paus
3856:irmp.c        ****                                         LEGO_START_BIT_PULSE_LEN_MIN, LEGO_START_BIT_PULSE_LEN_MAX,
3857:irmp.c        ****                                         LEGO_START_BIT_PAUSE_LEN_MIN, LEGO_START_BIT_PAUSE_LEN_MAX)
3858:irmp.c        **** #endif // ANALYZE
3859:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &lego_param;
3860:irmp.c        ****                     }
3861:irmp.c        ****                     else
3862:irmp.c        **** #endif // IRMP_SUPPORT_LEGO_PROTOCOL == 1
3863:irmp.c        **** 
3864:irmp.c        **** #if IRMP_SUPPORT_IRMP16_PROTOCOL == 1
3865:irmp.c        ****                     if (irmp_pulse_time >= IRMP16_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= IRM
3866:irmp.c        ****                         irmp_pause_time >= IRMP16_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= IRM
3867:irmp.c        ****                     {
3868:irmp.c        **** #ifdef ANALYZE
3869:irmp.c        ****                         ANALYZE_PRINTF ("protocol = IRMP16, start bit timings: pulse: %3d - %3d, pa
3870:irmp.c        ****                                         IRMP16_START_BIT_PULSE_LEN_MIN, IRMP16_START_BIT_PULSE_LEN_
3871:irmp.c        ****                                         IRMP16_START_BIT_PAUSE_LEN_MIN, IRMP16_START_BIT_PAUSE_LEN_
3872:irmp.c        **** #endif // ANALYZE
3873:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &irmp16_param;
3874:irmp.c        ****                     }
3875:irmp.c        ****                     else
3876:irmp.c        **** #endif // IRMP_SUPPORT_IRMP16_PROTOCOL == 1
3877:irmp.c        **** 
3878:irmp.c        **** #if IRMP_SUPPORT_GREE_PROTOCOL == 1
3879:irmp.c        ****                     if (irmp_pulse_time >= GREE_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= GREE_
3880:irmp.c        ****                         irmp_pause_time >= GREE_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= GREE_
3881:irmp.c        ****                     {
3882:irmp.c        **** #ifdef ANALYZE
3883:irmp.c        ****                         ANALYZE_PRINTF ("protocol = GREE, start bit timings: pulse: %3d - %3d, paus
3884:irmp.c        ****                                         GREE_START_BIT_PULSE_LEN_MIN, GREE_START_BIT_PULSE_LEN_MAX,
3885:irmp.c        ****                                         GREE_START_BIT_PAUSE_LEN_MIN, GREE_START_BIT_PAUSE_LEN_MAX)
3886:irmp.c        **** #endif // ANALYZE
3887:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &gree_param;
3888:irmp.c        ****                     }
3889:irmp.c        ****                     else
3890:irmp.c        **** #endif // IRMP_SUPPORT_GREE_PROTOCOL == 1
3891:irmp.c        **** 
3892:irmp.c        **** #if IRMP_SUPPORT_A1TVBOX_PROTOCOL == 1
3893:irmp.c        ****                     if (irmp_pulse_time >= A1TVBOX_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= A1
3894:irmp.c        ****                         irmp_pause_time >= A1TVBOX_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= A1
3895:irmp.c        ****                     {                                                           // it's A1TVBOX
3896:irmp.c        **** #ifdef ANALYZE
3897:irmp.c        ****                         ANALYZE_PRINTF ("protocol = A1TVBOX, start bit timings: pulse: %3d - %3d, p
3898:irmp.c        ****                                         A1TVBOX_START_BIT_PULSE_LEN_MIN, A1TVBOX_START_BIT_PULSE_LE
3899:irmp.c        ****                                         A1TVBOX_START_BIT_PAUSE_LEN_MIN, A1TVBOX_START_BIT_PAUSE_LE
3900:irmp.c        **** #endif // ANALYZE
3901:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &a1tvbox_param;
3902:irmp.c        ****                         last_pause = 0;
3903:irmp.c        ****                         last_value = 1;
3904:irmp.c        ****                     }
3905:irmp.c        ****                     else
3906:irmp.c        **** #endif // IRMP_SUPPORT_A1TVBOX_PROTOCOL == 1
3907:irmp.c        **** 
3908:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
3909:irmp.c        ****                     if (irmp_pulse_time >= ORTEK_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= ORTE
3910:irmp.c        ****                         irmp_pause_time >= ORTEK_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= ORTE
3911:irmp.c        ****                     {                                                           // it's ORTEK (Hama
3912:irmp.c        **** #ifdef ANALYZE
3913:irmp.c        ****                         ANALYZE_PRINTF ("protocol = ORTEK, start bit timings: pulse: %3d - %3d, pau
3914:irmp.c        ****                                         ORTEK_START_BIT_PULSE_LEN_MIN, ORTEK_START_BIT_PULSE_LEN_MA
3915:irmp.c        ****                                         ORTEK_START_BIT_PAUSE_LEN_MIN, ORTEK_START_BIT_PAUSE_LEN_MA
3916:irmp.c        **** #endif // ANALYZE
3917:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &ortek_param;
3918:irmp.c        ****                         last_pause  = 0;
3919:irmp.c        ****                         last_value  = 1;
3920:irmp.c        ****                         parity      = 0;
3921:irmp.c        ****                     }
3922:irmp.c        ****                     else
3923:irmp.c        **** #endif // IRMP_SUPPORT_ORTEK_PROTOCOL == 1
3924:irmp.c        **** 
3925:irmp.c        **** #if IRMP_SUPPORT_RCMM_PROTOCOL == 1
3926:irmp.c        ****                     if (irmp_pulse_time >= RCMM32_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RCM
3927:irmp.c        ****                         irmp_pause_time >= RCMM32_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RCM
3928:irmp.c        ****                     {                                                           // it's RCMM
3929:irmp.c        **** #ifdef ANALYZE
3930:irmp.c        ****                         ANALYZE_PRINTF ("protocol = RCMM, start bit timings: pulse: %3d - %3d, paus
3931:irmp.c        ****                                         RCMM32_START_BIT_PULSE_LEN_MIN, RCMM32_START_BIT_PULSE_LEN_
3932:irmp.c        ****                                         RCMM32_START_BIT_PAUSE_LEN_MIN, RCMM32_START_BIT_PAUSE_LEN_
3933:irmp.c        **** #endif // ANALYZE
3934:irmp.c        ****                         irmp_param_p = (IRMP_PARAMETER *) &rcmm_param;
3935:irmp.c        ****                     }
3936:irmp.c        ****                     else
3937:irmp.c        **** #endif // IRMP_SUPPORT_RCMM_PROTOCOL == 1
3938:irmp.c        ****                     {
3939:irmp.c        **** #ifdef ANALYZE
3940:irmp.c        ****                         ANALYZE_PRINTF ("protocol = UNKNOWN\n");
3941:irmp.c        **** #endif // ANALYZE
3942:irmp.c        ****                         irmp_start_bit_detected = 0;                            // wait for another
3943:irmp.c        ****                     }
3944:irmp.c        **** 
3945:irmp.c        ****                     if (irmp_start_bit_detected)
3946:irmp.c        ****                     {
3947:irmp.c        ****                         memcpy_P (&irmp_param, irmp_param_p, sizeof (IRMP_PARAMETER));
3948:irmp.c        **** 
3949:irmp.c        ****                         if (! (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
3950:irmp.c        ****                         {
3951:irmp.c        **** #ifdef ANALYZE
3952:irmp.c        ****                             ANALYZE_PRINTF ("pulse_1: %3d - %3d\n", irmp_param.pulse_1_len_min, irm
3953:irmp.c        ****                             ANALYZE_PRINTF ("pause_1: %3d - %3d\n", irmp_param.pause_1_len_min, irm
3954:irmp.c        **** #endif // ANALYZE
3955:irmp.c        ****                         }
3956:irmp.c        ****                         else
3957:irmp.c        ****                         {
3958:irmp.c        **** #ifdef ANALYZE
3959:irmp.c        ****                             ANALYZE_PRINTF ("pulse: %3d - %3d or %3d - %3d\n", irmp_param.pulse_1_l
3960:irmp.c        ****                                             2 * irmp_param.pulse_1_len_min, 2 * irmp_param.pulse_1_
3961:irmp.c        ****                             ANALYZE_PRINTF ("pause: %3d - %3d or %3d - %3d\n", irmp_param.pause_1_l
3962:irmp.c        ****                                             2 * irmp_param.pause_1_len_min, 2 * irmp_param.pause_1_
3963:irmp.c        **** #endif // ANALYZE
3964:irmp.c        ****                         }
3965:irmp.c        **** 
3966:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
3967:irmp.c        ****                         if (irmp_param2.protocol)
3968:irmp.c        ****                         {
3969:irmp.c        **** #ifdef ANALYZE
3970:irmp.c        ****                             ANALYZE_PRINTF ("pulse_0: %3d - %3d\n", irmp_param2.pulse_0_len_min, ir
3971:irmp.c        ****                             ANALYZE_PRINTF ("pause_0: %3d - %3d\n", irmp_param2.pause_0_len_min, ir
3972:irmp.c        ****                             ANALYZE_PRINTF ("pulse_1: %3d - %3d\n", irmp_param2.pulse_1_len_min, ir
3973:irmp.c        ****                             ANALYZE_PRINTF ("pause_1: %3d - %3d\n", irmp_param2.pause_1_len_min, ir
3974:irmp.c        **** #endif // ANALYZE
3975:irmp.c        ****                         }
3976:irmp.c        **** #endif
3977:irmp.c        **** 
3978:irmp.c        **** 
3979:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
3980:irmp.c        ****                         if (irmp_param.protocol == IRMP_RC6_PROTOCOL)
3981:irmp.c        ****                         {
3982:irmp.c        **** #ifdef ANALYZE
3983:irmp.c        ****                             ANALYZE_PRINTF ("pulse_toggle: %3d - %3d\n", RC6_TOGGLE_BIT_LEN_MIN, RC
3984:irmp.c        **** #endif // ANALYZE
3985:irmp.c        ****                         }
3986:irmp.c        **** #endif
3987:irmp.c        **** 
3988:irmp.c        ****                         if (! (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
3989:irmp.c        ****                         {
3990:irmp.c        **** #ifdef ANALYZE
3991:irmp.c        ****                             ANALYZE_PRINTF ("pulse_0: %3d - %3d\n", irmp_param.pulse_0_len_min, irm
3992:irmp.c        ****                             ANALYZE_PRINTF ("pause_0: %3d - %3d\n", irmp_param.pause_0_len_min, irm
3993:irmp.c        **** #endif // ANALYZE
3994:irmp.c        ****                         }
3995:irmp.c        ****                         else
3996:irmp.c        ****                         {
3997:irmp.c        **** #ifdef ANALYZE
3998:irmp.c        ****                             ANALYZE_PRINTF ("pulse: %3d - %3d or %3d - %3d\n", irmp_param.pulse_0_l
3999:irmp.c        ****                                             2 * irmp_param.pulse_0_len_min, 2 * irmp_param.pulse_0_
4000:irmp.c        ****                             ANALYZE_PRINTF ("pause: %3d - %3d or %3d - %3d\n", irmp_param.pause_0_l
4001:irmp.c        ****                                             2 * irmp_param.pause_0_len_min, 2 * irmp_param.pause_0_
4002:irmp.c        **** #endif // ANALYZE
4003:irmp.c        ****                         }
4004:irmp.c        **** 
4005:irmp.c        **** #ifdef ANALYZE
4006:irmp.c        **** #if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
4007:irmp.c        ****                         if (irmp_param.protocol == IRMP_BANG_OLUFSEN_PROTOCOL)
4008:irmp.c        ****                         {
4009:irmp.c        ****                             ANALYZE_PRINTF ("pulse_r: %3d - %3d\n", irmp_param.pulse_0_len_min, irm
4010:irmp.c        ****                             ANALYZE_PRINTF ("pause_r: %3d - %3d\n", BANG_OLUFSEN_R_PAUSE_LEN_MIN, B
4011:irmp.c        ****                         }
4012:irmp.c        **** #endif
4013:irmp.c        **** 
4014:irmp.c        ****                         ANALYZE_PRINTF ("command_offset: %2d\n", irmp_param.command_offset);
4015:irmp.c        ****                         ANALYZE_PRINTF ("command_len:    %3d\n", irmp_param.command_end - irmp_para
4016:irmp.c        ****                         ANALYZE_PRINTF ("complete_len:   %3d\n", irmp_param.complete_len);
4017:irmp.c        ****                         ANALYZE_PRINTF ("stop_bit:       %3d\n", irmp_param.stop_bit);
4018:irmp.c        **** #endif // ANALYZE
4019:irmp.c        ****                     }
4020:irmp.c        **** 
4021:irmp.c        ****                     irmp_bit = 0;
4022:irmp.c        **** 
4023:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1
4024:irmp.c        ****                     if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
4025:irmp.c        ****                          irmp_param.protocol != IRMP_RUWIDO_PROTOCOL && // Manchester, but not RUWI
4026:irmp.c        ****                          irmp_param.protocol != IRMP_RC6_PROTOCOL /*** &&    // Manchester, but not
4027:irmp.c        ****                          irmp_param.protocol != IRMP_RCII_PROTOCOL ****/)     // Manchester, but no
4028:irmp.c        ****                     {
4029:irmp.c        ****                         if (irmp_pause_time > irmp_param.pulse_1_len_max && irmp_pause_time <= 2 * 
4030:irmp.c        ****                         {
4031:irmp.c        **** #ifdef ANALYZE
4032:irmp.c        ****                             ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double
4033:irmp.c        ****                             ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 
4034:irmp.c        ****                             ANALYZE_NEWLINE ();
4035:irmp.c        **** #endif // ANALYZE
4036:irmp.c        ****                             irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 0
4037:irmp.c        ****                         }
4038:irmp.c        ****                         else if (! last_value)  // && irmp_pause_time >= irmp_param.pause_1_len_min
4039:irmp.c        ****                         {
4040:irmp.c        **** #ifdef ANALYZE
4041:irmp.c        ****                             ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double
4042:irmp.c        ****                             ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 
4043:irmp.c        ****                             ANALYZE_NEWLINE ();
4044:irmp.c        **** #endif // ANALYZE
4045:irmp.c        ****                             irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1
4046:irmp.c        ****                         }
4047:irmp.c        ****                     }
4048:irmp.c        ****                     else
4049:irmp.c        **** #endif // IRMP_SUPPORT_MANCHESTER == 1
4050:irmp.c        **** 
4051:irmp.c        **** #if IRMP_SUPPORT_SERIAL == 1
4052:irmp.c        ****                     if (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL)
4053:irmp.c        ****                     {
4054:irmp.c        ****                         ; // do nothing
4055:irmp.c        ****                     }
4056:irmp.c        ****                     else
4057:irmp.c        **** #endif // IRMP_SUPPORT_SERIAL == 1
4058:irmp.c        **** 
4059:irmp.c        **** 
4060:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
4061:irmp.c        ****                     if (irmp_param.protocol == IRMP_DENON_PROTOCOL)
4062:irmp.c        ****                     {
4063:irmp.c        **** #ifdef ANALYZE
4064:irmp.c        ****                         ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double) (t
4065:irmp.c        **** #endif // ANALYZE
4066:irmp.c        **** 
4067:irmp.c        ****                         if (irmp_pause_time >= DENON_1_PAUSE_LEN_MIN && irmp_pause_time <= DENON_1_
4068:irmp.c        ****                         {                                                       // pause timings co
4069:irmp.c        **** #ifdef ANALYZE
4070:irmp.c        ****                             ANALYZE_PUTCHAR ('1');                                  // yes, store 1
4071:irmp.c        ****                             ANALYZE_NEWLINE ();
4072:irmp.c        **** #endif // ANALYZE
4073:irmp.c        ****                             irmp_store_bit (1);
4074:irmp.c        ****                         }
4075:irmp.c        ****                         else // if (irmp_pause_time >= DENON_0_PAUSE_LEN_MIN && irmp_pause_time <= 
4076:irmp.c        ****                         {                                                       // pause timings co
4077:irmp.c        **** #ifdef ANALYZE
4078:irmp.c        ****                             ANALYZE_PUTCHAR ('0');                                  // yes, store 0
4079:irmp.c        ****                             ANALYZE_NEWLINE ();
4080:irmp.c        **** #endif // ANALYZE
4081:irmp.c        ****                             irmp_store_bit (0);
4082:irmp.c        ****                         }
4083:irmp.c        ****                     }
4084:irmp.c        ****                     else
4085:irmp.c        **** #endif // IRMP_SUPPORT_DENON_PROTOCOL == 1
4086:irmp.c        **** #if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
4087:irmp.c        ****                     if (irmp_param.protocol == IRMP_THOMSON_PROTOCOL)
4088:irmp.c        ****                     {
4089:irmp.c        **** #ifdef ANALYZE
4090:irmp.c        ****                         ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double) (t
4091:irmp.c        **** #endif // ANALYZE
4092:irmp.c        **** 
4093:irmp.c        ****                         if (irmp_pause_time >= THOMSON_1_PAUSE_LEN_MIN && irmp_pause_time <= THOMSO
4094:irmp.c        ****                         {                                                       // pause timings co
4095:irmp.c        **** #ifdef ANALYZE
4096:irmp.c        ****                           ANALYZE_PUTCHAR ('1');                                  // yes, store 1
4097:irmp.c        ****                           ANALYZE_NEWLINE ();
4098:irmp.c        **** #endif // ANALYZE
4099:irmp.c        ****                           irmp_store_bit (1);
4100:irmp.c        ****                         }
4101:irmp.c        ****                         else // if (irmp_pause_time >= THOMSON_0_PAUSE_LEN_MIN && irmp_pause_time <
4102:irmp.c        ****                         {                                                       // pause timings co
4103:irmp.c        **** #ifdef ANALYZE
4104:irmp.c        ****                           ANALYZE_PUTCHAR ('0');                                  // yes, store 0
4105:irmp.c        ****                           ANALYZE_NEWLINE ();
4106:irmp.c        **** #endif // ANALYZE
4107:irmp.c        ****                           irmp_store_bit (0);
4108:irmp.c        ****                         }
4109:irmp.c        ****                     }
4110:irmp.c        ****                     else
4111:irmp.c        **** #endif // IRMP_SUPPORT_THOMSON_PROTOCOL == 1
4112:irmp.c        ****                     {
4113:irmp.c        ****                         ;                                                       // else do nothing
4114:irmp.c        ****                     }
4115:irmp.c        **** 
4116:irmp.c        ****                     irmp_pulse_time = 1;                                        // set counter to 1
4117:irmp.c        ****                     irmp_pause_time = 0;
4118:irmp.c        ****                     wait_for_start_space = 0;
4119:irmp.c        ****                 }
4120:irmp.c        ****             }
4121:irmp.c        ****             else if (wait_for_space)                                            // the data section
4122:irmp.c        ****             {                                                                   // counting the tim
4123:irmp.c        ****                 uint_fast8_t got_light = FALSE;
4124:irmp.c        **** 
4125:irmp.c        ****                 if (irmp_input)                                                 // still dark?
4126:irmp.c        ****                 {                                                               // yes...
4127:irmp.c        ****                     if (irmp_bit == irmp_param.complete_len && irmp_param.stop_bit == 1)
4128:irmp.c        ****                     {
4129:irmp.c        ****                         if (
4130:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1
4131:irmp.c        ****                             (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) ||
4132:irmp.c        **** #endif
4133:irmp.c        **** #if IRMP_SUPPORT_SERIAL == 1
4134:irmp.c        ****                             (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL) ||
4135:irmp.c        **** #endif
4136:irmp.c        ****                             (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= ir
4137:irmp.c        ****                         {
4138:irmp.c        **** #ifdef ANALYZE
4139:irmp.c        ****                             if (! (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
4140:irmp.c        ****                             {
4141:irmp.c        ****                                 ANALYZE_PRINTF ("stop bit detected\n");
4142:irmp.c        ****                             }
4143:irmp.c        **** #endif // ANALYZE
4144:irmp.c        ****                             irmp_param.stop_bit = 0;
4145:irmp.c        ****                         }
4146:irmp.c        ****                         else
4147:irmp.c        ****                         {
4148:irmp.c        **** #ifdef ANALYZE
4149:irmp.c        ****                             ANALYZE_PRINTF ("error: stop bit timing wrong, irmp_bit = %d, irmp_puls
4150:irmp.c        ****                                             irmp_bit, irmp_pulse_time, irmp_param.pulse_0_len_min, 
4151:irmp.c        **** #endif // ANALYZE
4152:irmp.c        ****                             irmp_start_bit_detected = 0;                        // wait for another
4153:irmp.c        ****                             irmp_pulse_time         = 0;
4154:irmp.c        ****                             irmp_pause_time         = 0;
4155:irmp.c        ****                         }
4156:irmp.c        ****                     }
4157:irmp.c        ****                     else
4158:irmp.c        ****                     {
4159:irmp.c        ****                         irmp_pause_time++;                                                         
4160:irmp.c        **** 
4161:irmp.c        **** #if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
4162:irmp.c        ****                         if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL &&                          
4163:irmp.c        ****                             irmp_pause_time > SIRCS_PAUSE_LEN_MAX &&                               
4164:irmp.c        ****                             irmp_bit >= 12 - 1)                                                    
4165:irmp.c        ****                         {                                                                          
4166:irmp.c        ****                             irmp_param.complete_len = irmp_bit + 1;                                
4167:irmp.c        ****                             got_light = TRUE;                                                      
4168:irmp.c        ****                             irmp_tmp_address |= (irmp_bit - SIRCS_MINIMUM_DATA_LEN + 1) << 8;      
4169:irmp.c        ****                             irmp_param.command_end = irmp_param.command_offset + irmp_bit + 1;     
4170:irmp.c        ****                             irmp_pause_time = SIRCS_PAUSE_LEN_MAX - 1;                             
4171:irmp.c        ****                         }
4172:irmp.c        ****                         else
4173:irmp.c        **** #endif
4174:irmp.c        **** #if IRMP_SUPPORT_MERLIN_PROTOCOL == 1
4175:irmp.c        ****                         if (irmp_param.protocol == IRMP_MERLIN_PROTOCOL &&                         
4176:irmp.c        ****                             irmp_pause_time > MERLIN_START_BIT_PAUSE_LEN_MAX &&                    
4177:irmp.c        ****                             irmp_bit >= 8 - 1)                                                     
4178:irmp.c        ****                         {                                                                          
4179:irmp.c        ****                             irmp_param.complete_len = irmp_bit;                                    
4180:irmp.c        ****                             got_light = TRUE;                                                      
4181:irmp.c        ****                             irmp_pause_time = MERLIN_BIT_PAUSE_LEN_MAX - 1;                        
4182:irmp.c        ****                         }
4183:irmp.c        ****                         else
4184:irmp.c        **** #endif
4185:irmp.c        **** #if IRMP_SUPPORT_FAN_PROTOCOL == 1
4186:irmp.c        ****                         if (irmp_param.protocol == IRMP_FAN_PROTOCOL &&                            
4187:irmp.c        ****                             irmp_bit >= FAN_COMPLETE_DATA_LEN - 1)                                 
4188:irmp.c        ****                         {                                                                          
4189:irmp.c        ****                             if (irmp_pulse_time <= FAN_0_PULSE_LEN_MAX && irmp_pause_time >= FAN_0_
4190:irmp.c        ****                             {
4191:irmp.c        **** #ifdef ANALYZE
4192:irmp.c        ****                                 ANALYZE_PRINTF ("Generating virtual stop bit\n");
4193:irmp.c        **** #endif // ANALYZE
4194:irmp.c        ****                                 got_light = TRUE;                                                  
4195:irmp.c        ****                             }
4196:irmp.c        ****                             else if (irmp_pulse_time >= FAN_1_PULSE_LEN_MIN && irmp_pause_time >= F
4197:irmp.c        ****                             {
4198:irmp.c        **** #ifdef ANALYZE
4199:irmp.c        ****                                 ANALYZE_PRINTF ("Generating virtual stop bit\n");
4200:irmp.c        **** #endif // ANALYZE
4201:irmp.c        ****                                 got_light = TRUE;                                                  
4202:irmp.c        ****                             }
4203:irmp.c        ****                         }
4204:irmp.c        ****                         else
4205:irmp.c        **** #endif
4206:irmp.c        **** #if IRMP_SUPPORT_SERIAL == 1
4207:irmp.c        ****                         // NETBOX generates no stop bit, here is the timeout condition:
4208:irmp.c        ****                         if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL) && irmp_param.protocol =
4209:irmp.c        ****                             irmp_pause_time >= NETBOX_PULSE_LEN * (NETBOX_COMPLETE_DATA_LEN - irmp_
4210:irmp.c        ****                         {
4211:irmp.c        ****                             got_light = TRUE;                                                      
4212:irmp.c        ****                         }
4213:irmp.c        ****                         else
4214:irmp.c        **** #endif
4215:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
4216:irmp.c        ****                         if (irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL && !irmp_param.stop_bit)
4217:irmp.c        ****                         {
4218:irmp.c        ****                             if (irmp_pause_time > IR60_TIMEOUT_LEN && (irmp_bit == 5 || irmp_bit ==
4219:irmp.c        ****                             {
4220:irmp.c        **** #ifdef ANALYZE
4221:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to IR60 protocol\n");
4222:irmp.c        **** #endif // ANALYZE
4223:irmp.c        ****                                 got_light = TRUE;                                       // this is 
4224:irmp.c        ****                                 irmp_param.stop_bit = TRUE;                             // set flag
4225:irmp.c        **** 
4226:irmp.c        ****                                 irmp_param.protocol         = IRMP_IR60_PROTOCOL;       // change p
4227:irmp.c        ****                                 irmp_param.complete_len     = IR60_COMPLETE_DATA_LEN;   // correct 
4228:irmp.c        ****                                 irmp_param.address_offset   = IR60_ADDRESS_OFFSET;
4229:irmp.c        ****                                 irmp_param.address_end      = IR60_ADDRESS_OFFSET + IR60_ADDRESS_LE
4230:irmp.c        ****                                 irmp_param.command_offset   = IR60_COMMAND_OFFSET;
4231:irmp.c        ****                                 irmp_param.command_end      = IR60_COMMAND_OFFSET + IR60_COMMAND_LE
4232:irmp.c        **** 
4233:irmp.c        ****                                 irmp_tmp_command <<= 1;
4234:irmp.c        ****                                 irmp_tmp_command |= first_bit;
4235:irmp.c        ****                             }
4236:irmp.c        ****                             else if (irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit 
4237:irmp.c        ****                             {                                                           // special 
4238:irmp.c        ****                                 irmp_param.complete_len = GRUNDIG_COMPLETE_DATA_LEN;    // correct 
4239:irmp.c        ****                                 got_light = TRUE;                                       // this is 
4240:irmp.c        ****                                 irmp_param.stop_bit = TRUE;                             // set flag
4241:irmp.c        ****                             }
4242:irmp.c        ****                             else if (irmp_bit >= GRUNDIG_COMPLETE_DATA_LEN)
4243:irmp.c        ****                             {
4244:irmp.c        **** #ifdef ANALYZE
4245:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to NOKIA protocol, irmp_bit = %d\n", irm
4246:irmp.c        **** #endif // ANALYZE
4247:irmp.c        ****                                 irmp_param.protocol         = IRMP_NOKIA_PROTOCOL;      // change p
4248:irmp.c        ****                                 irmp_param.address_offset   = NOKIA_ADDRESS_OFFSET;
4249:irmp.c        ****                                 irmp_param.address_end      = NOKIA_ADDRESS_OFFSET + NOKIA_ADDRESS_
4250:irmp.c        ****                                 irmp_param.command_offset   = NOKIA_COMMAND_OFFSET;
4251:irmp.c        ****                                 irmp_param.command_end      = NOKIA_COMMAND_OFFSET + NOKIA_COMMAND_
4252:irmp.c        **** 
4253:irmp.c        ****                                 if (irmp_tmp_command & 0x300)
4254:irmp.c        ****                                 {
4255:irmp.c        ****                                     irmp_tmp_address = (irmp_tmp_command >> 8);
4256:irmp.c        ****                                     irmp_tmp_command &= 0xFF;
4257:irmp.c        ****                                 }
4258:irmp.c        ****                             }
4259:irmp.c        ****                         }
4260:irmp.c        ****                         else
4261:irmp.c        **** #endif
4262:irmp.c        **** #if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
4263:irmp.c        ****                         if (irmp_param.protocol == IRMP_RUWIDO_PROTOCOL && !irmp_param.stop_bit)
4264:irmp.c        ****                         {
4265:irmp.c        ****                             if (irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= RU
4266:irmp.c        ****                             {                                                           // special 
4267:irmp.c        ****                                 irmp_param.complete_len = RUWIDO_COMPLETE_DATA_LEN;     // correct 
4268:irmp.c        ****                                 got_light = TRUE;                                       // this is 
4269:irmp.c        ****                                 irmp_param.stop_bit = TRUE;                             // set flag
4270:irmp.c        ****                             }
4271:irmp.c        ****                             else if (irmp_bit >= RUWIDO_COMPLETE_DATA_LEN)
4272:irmp.c        ****                             {
4273:irmp.c        **** #ifdef ANALYZE
4274:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to SIEMENS protocol\n");
4275:irmp.c        **** #endif // ANALYZE
4276:irmp.c        ****                                 irmp_param.protocol         = IRMP_SIEMENS_PROTOCOL;    // change p
4277:irmp.c        ****                                 irmp_param.address_offset   = SIEMENS_ADDRESS_OFFSET;
4278:irmp.c        ****                                 irmp_param.address_end      = SIEMENS_ADDRESS_OFFSET + SIEMENS_ADDR
4279:irmp.c        ****                                 irmp_param.command_offset   = SIEMENS_COMMAND_OFFSET;
4280:irmp.c        ****                                 irmp_param.command_end      = SIEMENS_COMMAND_OFFSET + SIEMENS_COMM
4281:irmp.c        **** 
4282:irmp.c        ****                                 //                   76543210
4283:irmp.c        ****                                 // RUWIDO:  AAAAAAAAACCCCCCCp
4284:irmp.c        ****                                 // SIEMENS: AAAAAAAAAAACCCCCCCCCCp
4285:irmp.c        ****                                 irmp_tmp_address <<= 2;
4286:irmp.c        ****                                 irmp_tmp_address |= (irmp_tmp_command >> 6);
4287:irmp.c        ****                                 irmp_tmp_command &= 0x003F;
4288:irmp.c        **** //                              irmp_tmp_command <<= 4;
4289:irmp.c        ****                                 irmp_tmp_command |= last_value;
4290:irmp.c        ****                             }
4291:irmp.c        ****                         }
4292:irmp.c        ****                         else
4293:irmp.c        **** #endif
4294:irmp.c        **** #if IRMP_SUPPORT_ROOMBA_PROTOCOL == 1
4295:irmp.c        ****                         if (irmp_param.protocol == IRMP_ROOMBA_PROTOCOL &&                         
4296:irmp.c        ****                             irmp_bit >= ROOMBA_COMPLETE_DATA_LEN - 1)                              
4297:irmp.c        ****                         {                                                                          
4298:irmp.c        ****                             if (irmp_pulse_time >= ROOMBA_1_PULSE_LEN_MIN && irmp_pulse_time <= ROO
4299:irmp.c        ****                             {
4300:irmp.c        ****                                 irmp_pause_time = ROOMBA_1_PAUSE_LEN_EXACT;
4301:irmp.c        ****                             }
4302:irmp.c        ****                             else if (irmp_pulse_time >= ROOMBA_0_PULSE_LEN_MIN && irmp_pulse_time <
4303:irmp.c        ****                             {
4304:irmp.c        ****                                 irmp_pause_time = ROOMBA_0_PAUSE_LEN;
4305:irmp.c        ****                             }
4306:irmp.c        **** 
4307:irmp.c        ****                             got_light = TRUE;                                                      
4308:irmp.c        ****                         }
4309:irmp.c        ****                         else
4310:irmp.c        **** #endif
4311:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1
4312:irmp.c        ****                         if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
4313:irmp.c        ****                             irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= irmp_p
4314:irmp.c        ****                         {                                                       // special manchest
4315:irmp.c        ****                             got_light = TRUE;                                   // this is a lie, b
4316:irmp.c        ****                             irmp_param.stop_bit = TRUE;                         // set flag
4317:irmp.c        ****                         }
4318:irmp.c        ****                         else
4319:irmp.c        **** #endif // IRMP_SUPPORT_MANCHESTER == 1
4320:irmp.c        ****                         if (irmp_pause_time > IRMP_TIMEOUT_LEN)                 // timeout?
4321:irmp.c        ****                         {                                                       // yes...
4322:irmp.c        ****                             if (irmp_bit == irmp_param.complete_len - 1 && irmp_param.stop_bit == 0
4323:irmp.c        ****                             {
4324:irmp.c        ****                                 irmp_bit++;
4325:irmp.c        ****                             }
4326:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
4327:irmp.c        ****                             else if ((irmp_param.protocol == IRMP_NEC_PROTOCOL || irmp_param.protoc
4328:irmp.c        ****                             {                                                               // it w
4329:irmp.c        **** #ifdef ANALYZE                                                                              // with
4330:irmp.c        ****                                 ANALYZE_PRINTF ("Detected non-standard repetition frame, switching 
4331:irmp.c        **** #endif // ANALYZE
4332:irmp.c        ****                                 if (key_repetition_len < NEC_FRAME_REPEAT_PAUSE_LEN_MAX)
4333:irmp.c        ****                                 {
4334:irmp.c        ****                                     irmp_param.stop_bit     = TRUE;                         // set 
4335:irmp.c        ****                                     irmp_param.protocol     = IRMP_NEC_PROTOCOL;            // swit
4336:irmp.c        ****                                     irmp_param.complete_len = irmp_bit;                     // patc
4337:irmp.c        ****                                     irmp_tmp_address = last_irmp_address;                   // addr
4338:irmp.c        ****                                     irmp_tmp_command = last_irmp_command;                   // comm
4339:irmp.c        ****                                     irmp_flags |= IRMP_FLAG_REPETITION;
4340:irmp.c        ****                                     key_repetition_len = 0;
4341:irmp.c        ****                                 }
4342:irmp.c        ****                                 else
4343:irmp.c        ****                                 {
4344:irmp.c        **** #ifdef ANALYZE
4345:irmp.c        ****                                     ANALYZE_PRINTF ("ignoring NEC repetition frame: timeout occured
4346:irmp.c        ****                                                     key_repetition_len, NEC_FRAME_REPEAT_PAUSE_LEN_
4347:irmp.c        **** #endif // ANALYZE
4348:irmp.c        ****                                     irmp_ir_detected = FALSE;
4349:irmp.c        ****                                 }
4350:irmp.c        ****                             }
4351:irmp.c        **** #endif // IRMP_SUPPORT_NEC_PROTOCOL == 1
4352:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
4353:irmp.c        ****                             else if (irmp_param.protocol == IRMP_NEC_PROTOCOL && (irmp_bit == 16 ||
4354:irmp.c        ****                             {
4355:irmp.c        **** #ifdef ANALYZE
4356:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to JVC protocol, irmp_bit = %d\n", irmp_
4357:irmp.c        **** #endif // ANALYZE
4358:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
4359:irmp.c        ****                                 irmp_param.protocol     = IRMP_JVC_PROTOCOL;                       
4360:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
4361:irmp.c        ****                                 irmp_tmp_command        = (irmp_tmp_address >> 4);                 
4362:irmp.c        ****                                 irmp_tmp_address        = irmp_tmp_address & 0x000F;               
4363:irmp.c        ****                                 irmp_start_bit_detected = 1;                                       
4364:irmp.c        ****                             }
4365:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
4366:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
4367:irmp.c        ****                             else if (irmp_param.protocol == IRMP_NEC_PROTOCOL && (irmp_bit == 28 ||
4368:irmp.c        ****                             {
4369:irmp.c        **** #ifdef ANALYZE
4370:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to LGAIR protocol, irmp_bit = %d\n", irm
4371:irmp.c        **** #endif // ANALYZE
4372:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
4373:irmp.c        ****                                 irmp_param.protocol     = IRMP_LGAIR_PROTOCOL;                     
4374:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
4375:irmp.c        ****                                 irmp_tmp_command        = irmp_lgair_command;                      
4376:irmp.c        ****                                 irmp_tmp_address        = irmp_lgair_address;                      
4377:irmp.c        ****                                 irmp_start_bit_detected = 1;                                       
4378:irmp.c        ****                             }
4379:irmp.c        **** #endif // IRMP_SUPPORT_LGAIR_PROTOCOL == 1
4380:irmp.c        **** 
4381:irmp.c        **** #if IRMP_SUPPORT_NEC42_PROTOCOL == 1
4382:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
4383:irmp.c        ****                             else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && irmp_bit == 32) 
4384:irmp.c        ****                             {
4385:irmp.c        **** #ifdef ANALYZE
4386:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to NEC protocol\n");
4387:irmp.c        **** #endif // ANALYZE
4388:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
4389:irmp.c        ****                                 irmp_param.protocol     = IRMP_NEC_PROTOCOL;                       
4390:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
4391:irmp.c        **** 
4392:irmp.c        ****                                 //        0123456789ABC0123456789ABC0123456701234567
4393:irmp.c        ****                                 // NEC42: AAAAAAAAAAAAAaaaaaaaaaaaaaCCCCCCCCcccccccc
4394:irmp.c        ****                                 // NEC:   AAAAAAAAaaaaaaaaCCCCCCCCcccccccc
4395:irmp.c        ****                                 irmp_tmp_address        |= (irmp_tmp_address2 & 0x0007) << 13;     
4396:irmp.c        ****                                 irmp_tmp_command        = (irmp_tmp_address2 >> 3) | (irmp_tmp_comm
4397:irmp.c        ****                             }
4398:irmp.c        **** #endif // IRMP_SUPPORT_NEC_PROTOCOL == 1
4399:irmp.c        **** #if IRMP_SUPPORT_LGAIR_PROTOCOL == 1
4400:irmp.c        ****                             else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && irmp_bit == 28) 
4401:irmp.c        ****                             {
4402:irmp.c        **** #ifdef ANALYZE
4403:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to LGAIR protocol\n");
4404:irmp.c        **** #endif // ANALYZE
4405:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
4406:irmp.c        ****                                 irmp_param.protocol     = IRMP_LGAIR_PROTOCOL;                     
4407:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
4408:irmp.c        ****                                 irmp_tmp_address        = irmp_lgair_address;
4409:irmp.c        ****                                 irmp_tmp_command        = irmp_lgair_command;
4410:irmp.c        ****                             }
4411:irmp.c        **** #endif // IRMP_SUPPORT_LGAIR_PROTOCOL == 1
4412:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
4413:irmp.c        ****                             else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && (irmp_bit == 16 
4414:irmp.c        ****                             {
4415:irmp.c        **** #ifdef ANALYZE
4416:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to JVC protocol, irmp_bit = %d\n", irmp_
4417:irmp.c        **** #endif // ANALYZE
4418:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
4419:irmp.c        ****                                 irmp_param.protocol     = IRMP_JVC_PROTOCOL;                       
4420:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
4421:irmp.c        **** 
4422:irmp.c        ****                                 //        0123456789ABC0123456789ABC0123456701234567
4423:irmp.c        ****                                 // NEC42: AAAAAAAAAAAAAaaaaaaaaaaaaaCCCCCCCCcccccccc
4424:irmp.c        ****                                 // JVC:   AAAACCCCCCCCCCCC
4425:irmp.c        ****                                 irmp_tmp_command        = (irmp_tmp_address >> 4) | (irmp_tmp_addre
4426:irmp.c        ****                                 irmp_tmp_address        = irmp_tmp_address & 0x000F;               
4427:irmp.c        ****                             }
4428:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
4429:irmp.c        **** #endif // IRMP_SUPPORT_NEC42_PROTOCOL == 1
4430:irmp.c        **** 
4431:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG48_PROTOCOL == 1
4432:irmp.c        ****                             else if (irmp_param.protocol == IRMP_SAMSUNG48_PROTOCOL && irmp_bit == 
4433:irmp.c        ****                             {
4434:irmp.c        **** #ifdef ANALYZE
4435:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to SAMSUNG32 protocol\n");
4436:irmp.c        **** #endif // ANALYZE
4437:irmp.c        ****                                 irmp_param.protocol         = IRMP_SAMSUNG32_PROTOCOL;
4438:irmp.c        ****                                 irmp_param.command_offset   = SAMSUNG32_COMMAND_OFFSET;
4439:irmp.c        ****                                 irmp_param.command_end      = SAMSUNG32_COMMAND_OFFSET + SAMSUNG32_
4440:irmp.c        ****                                 irmp_param.complete_len     = SAMSUNG32_COMPLETE_DATA_LEN;
4441:irmp.c        ****                             }
4442:irmp.c        **** #endif // IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
4443:irmp.c        **** 
4444:irmp.c        **** #if IRMP_SUPPORT_RCMM_PROTOCOL == 1
4445:irmp.c        ****                             else if (irmp_param.protocol == IRMP_RCMM32_PROTOCOL && (irmp_bit == 12
4446:irmp.c        ****                             {
4447:irmp.c        ****                                 if (irmp_bit == 12)
4448:irmp.c        ****                                 {
4449:irmp.c        ****                                     irmp_tmp_command = (irmp_tmp_address & 0xFF);                  
4450:irmp.c        ****                                     irmp_tmp_address >>= 8;                                        
4451:irmp.c        **** 
4452:irmp.c        **** #ifdef ANALYZE
4453:irmp.c        ****                                     ANALYZE_PRINTF ("Switching to RCMM12 protocol, irmp_bit = %d\n"
4454:irmp.c        **** #endif // ANALYZE
4455:irmp.c        ****                                     irmp_param.protocol     = IRMP_RCMM12_PROTOCOL;                
4456:irmp.c        ****                                 }
4457:irmp.c        ****                                 else // if ((irmp_bit == 24)
4458:irmp.c        ****                                 {
4459:irmp.c        **** #ifdef ANALYZE
4460:irmp.c        ****                                     ANALYZE_PRINTF ("Switching to RCMM24 protocol, irmp_bit = %d\n"
4461:irmp.c        **** #endif // ANALYZE
4462:irmp.c        ****                                     irmp_param.protocol     = IRMP_RCMM24_PROTOCOL;                
4463:irmp.c        ****                                 }
4464:irmp.c        ****                                 irmp_param.stop_bit     = TRUE;                                    
4465:irmp.c        ****                                 irmp_param.complete_len = irmp_bit;                                
4466:irmp.c        ****                             }
4467:irmp.c        **** #endif // IRMP_SUPPORT_RCMM_PROTOCOL == 1
4468:irmp.c        **** 
4469:irmp.c        **** #if IRMP_SUPPORT_TECHNICS_PROTOCOL == 1
4470:irmp.c        ****                             else if (irmp_param.protocol == IRMP_MATSUSHITA_PROTOCOL && irmp_bit ==
4471:irmp.c        ****                             {
4472:irmp.c        **** #ifdef ANALYZE
4473:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to TECHNICS protocol, irmp_bit = %d\n", 
4474:irmp.c        **** #endif // ANALYZE
4475:irmp.c        ****                                 // Situation:
4476:irmp.c        ****                                 // The first 12 bits have been stored in irmp_tmp_command (LSB firs
4477:irmp.c        ****                                 // The following 10 bits have been stored in irmp_tmp_address (LSB 
4478:irmp.c        ****                                 // The code of TECHNICS is:
4479:irmp.c        ****                                 //   cccccccccccCCCCCCCCCCC (11 times c and 11 times C)
4480:irmp.c        ****                                 //   ccccccccccccaaaaaaaaaa
4481:irmp.c        ****                                 // where C is inverted value of c
4482:irmp.c        **** 
4483:irmp.c        ****                                 irmp_tmp_address <<= 1;
4484:irmp.c        ****                                 if (irmp_tmp_command & (1<<11))
4485:irmp.c        ****                                 {
4486:irmp.c        ****                                     irmp_tmp_address |= 1;
4487:irmp.c        ****                                     irmp_tmp_command &= ~(1<<11);
4488:irmp.c        ****                                 }
4489:irmp.c        **** 
4490:irmp.c        ****                                 if (irmp_tmp_command == ((~irmp_tmp_address) & 0x07FF))
4491:irmp.c        ****                                 {
4492:irmp.c        ****                                     irmp_tmp_address = 0;
4493:irmp.c        **** 
4494:irmp.c        ****                                     irmp_param.protocol     = IRMP_TECHNICS_PROTOCOL;              
4495:irmp.c        ****                                     irmp_param.complete_len = irmp_bit;                            
4496:irmp.c        ****                                 }
4497:irmp.c        ****                                 else
4498:irmp.c        ****                                 {
4499:irmp.c        **** #ifdef ANALYZE
4500:irmp.c        ****                                     ANALYZE_PRINTF ("error 8: TECHNICS frame error\n");
4501:irmp.c        ****                                     ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
4502:irmp.c        **** #endif // ANALYZE
4503:irmp.c        ****                                     irmp_start_bit_detected = 0;                    // wait for ano
4504:irmp.c        ****                                     irmp_pulse_time         = 0;
4505:irmp.c        ****                                     irmp_pause_time         = 0;
4506:irmp.c        ****                                 }
4507:irmp.c        ****                             }
4508:irmp.c        **** #endif // IRMP_SUPPORT_TECHNICS_PROTOCOL == 1
4509:irmp.c        ****                             else
4510:irmp.c        ****                             {
4511:irmp.c        **** #ifdef ANALYZE
4512:irmp.c        ****                                 ANALYZE_PRINTF ("error 2: pause %d after data bit %d too long\n", i
4513:irmp.c        ****                                 ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
4514:irmp.c        **** #endif // ANALYZE
4515:irmp.c        ****                                 irmp_start_bit_detected = 0;                    // wait for another
4516:irmp.c        ****                                 irmp_pulse_time         = 0;
4517:irmp.c        ****                                 irmp_pause_time         = 0;
4518:irmp.c        ****                             }
4519:irmp.c        ****                         }
4520:irmp.c        ****                     }
4521:irmp.c        ****                 }
4522:irmp.c        ****                 else
4523:irmp.c        ****                 {                                                               // got light now!
4524:irmp.c        ****                     got_light = TRUE;
4525:irmp.c        ****                 }
4526:irmp.c        **** 
4527:irmp.c        ****                 if (got_light)
4528:irmp.c        ****                 {
4529:irmp.c        **** #ifdef ANALYZE
4530:irmp.c        ****                     ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double) (time_
4531:irmp.c        **** #endif // ANALYZE
4532:irmp.c        **** 
4533:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1
4534:irmp.c        ****                     if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))                        
4535:irmp.c        ****                     {
4536:irmp.c        **** #if IRMP_SUPPORT_MERLIN_PROTOCOL == 1
4537:irmp.c        ****                         if (irmp_param.complete_len == irmp_bit && irmp_param.protocol == IRMP_MERL
4538:irmp.c        ****                         {
4539:irmp.c        ****                             if (last_value == 0)
4540:irmp.c        ****                             {
4541:irmp.c        ****                                 if (irmp_pulse_time >= 2 * irmp_param.pulse_1_len_min && irmp_pulse
4542:irmp.c        ****                                     last_pause >= irmp_param.pause_1_len_min && last_pause <= irmp_
4543:irmp.c        ****                                 {
4544:irmp.c        ****                                     irmp_param.complete_len += 2;
4545:irmp.c        ****                                     irmp_store_bit(0);
4546:irmp.c        ****                                     irmp_store_bit(1);
4547:irmp.c        ****                                 }
4548:irmp.c        ****                             }
4549:irmp.c        ****                             else
4550:irmp.c        ****                             {
4551:irmp.c        ****                                 if (last_pause >= 2 * irmp_param.pause_1_len_min && last_pause <= 2
4552:irmp.c        ****                                 {
4553:irmp.c        ****                                     if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse
4554:irmp.c        ****                                     {
4555:irmp.c        ****                                         irmp_param.complete_len++;
4556:irmp.c        ****                                         irmp_store_bit(0);
4557:irmp.c        ****                                     }
4558:irmp.c        ****                                     else if (irmp_pulse_time >= 2 * irmp_param.pulse_1_len_min && i
4559:irmp.c        ****                                     {
4560:irmp.c        ****                                         irmp_param.complete_len += 2;
4561:irmp.c        ****                                         irmp_store_bit(0);
4562:irmp.c        ****                                         irmp_store_bit(1);
4563:irmp.c        ****                                     }
4564:irmp.c        ****                                 }
4565:irmp.c        ****                             }
4566:irmp.c        ****                         }
4567:irmp.c        ****                         else
4568:irmp.c        **** #endif
4569:irmp.c        **** #if 1
4570:irmp.c        ****                         if (irmp_pulse_time > irmp_param.pulse_1_len_max /* && irmp_pulse_time <= 2
4571:irmp.c        **** #else // better, but some IR-RCs use asymmetric timings :-/
4572:irmp.c        ****                         if (irmp_pulse_time > irmp_param.pulse_1_len_max && irmp_pulse_time <= 2 * 
4573:irmp.c        ****                             irmp_pause_time <= 2 * irmp_param.pause_1_len_max)
4574:irmp.c        **** #endif
4575:irmp.c        ****                         {
4576:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
4577:irmp.c        ****                             if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 4 && irmp_p
4578:irmp.c        ****                             {
4579:irmp.c        **** #ifdef ANALYZE
4580:irmp.c        ****                                 ANALYZE_PUTCHAR ('T');
4581:irmp.c        **** #endif // ANALYZE
4582:irmp.c        ****                                 if (irmp_param.complete_len == RC6_COMPLETE_DATA_LEN_LONG)         
4583:irmp.c        ****                                 {
4584:irmp.c        ****                                     irmp_store_bit (1);
4585:irmp.c        ****                                     last_value = 1;
4586:irmp.c        ****                                 }
4587:irmp.c        ****                                 else                                                               
4588:irmp.c        ****                                 {
4589:irmp.c        ****                                     irmp_store_bit (0);
4590:irmp.c        ****                                     last_value = 0;
4591:irmp.c        ****                                 }
4592:irmp.c        **** #ifdef ANALYZE
4593:irmp.c        ****                                 ANALYZE_NEWLINE ();
4594:irmp.c        **** #endif // ANALYZE
4595:irmp.c        ****                             }
4596:irmp.c        ****                             else
4597:irmp.c        **** #endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
4598:irmp.c        ****                             {
4599:irmp.c        **** #ifdef ANALYZE
4600:irmp.c        ****                                 ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1
4601:irmp.c        **** #endif // ANALYZE
4602:irmp.c        ****                                 irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1)
4603:irmp.c        **** 
4604:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
4605:irmp.c        ****                                 if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 4 && ir
4606:irmp.c        ****                                 {
4607:irmp.c        **** #ifdef ANALYZE
4608:irmp.c        ****                                     ANALYZE_PUTCHAR ('T');
4609:irmp.c        **** #endif // ANALYZE
4610:irmp.c        ****                                     irmp_store_bit (1);
4611:irmp.c        **** 
4612:irmp.c        ****                                     if (irmp_pause_time > 2 * irmp_param.pause_1_len_max)
4613:irmp.c        ****                                     {
4614:irmp.c        ****                                         last_value = 0;
4615:irmp.c        ****                                     }
4616:irmp.c        ****                                     else
4617:irmp.c        ****                                     {
4618:irmp.c        ****                                         last_value = 1;
4619:irmp.c        ****                                     }
4620:irmp.c        **** #ifdef ANALYZE
4621:irmp.c        ****                                     ANALYZE_NEWLINE ();
4622:irmp.c        **** #endif // ANALYZE
4623:irmp.c        ****                                 }
4624:irmp.c        ****                                 else
4625:irmp.c        **** #endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
4626:irmp.c        ****                                 {
4627:irmp.c        **** #ifdef ANALYZE
4628:irmp.c        ****                                     ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_
4629:irmp.c        **** #endif // ANALYZE
4630:irmp.c        ****                                     irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_I
4631:irmp.c        **** 
4632:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_RCII_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL
4633:irmp.c        ****                                     if (! irmp_param2.protocol)
4634:irmp.c        **** #endif
4635:irmp.c        ****                                     {
4636:irmp.c        **** #ifdef ANALYZE
4637:irmp.c        ****                                         ANALYZE_NEWLINE ();
4638:irmp.c        **** #endif // ANALYZE
4639:irmp.c        ****                                     }
4640:irmp.c        ****                                     last_value = (irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1
4641:irmp.c        ****                                 }
4642:irmp.c        ****                             }
4643:irmp.c        ****                         }
4644:irmp.c        ****                         else if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <
4645:irmp.c        ****                                  /* && irmp_pause_time <= 2 * irmp_param.pause_1_len_max */)
4646:irmp.c        ****                         {
4647:irmp.c        ****                             uint_fast8_t manchester_value;
4648:irmp.c        **** 
4649:irmp.c        ****                             if (last_pause > irmp_param.pause_1_len_max && last_pause <= 2 * irmp_p
4650:irmp.c        ****                             {
4651:irmp.c        ****                                 manchester_value = last_value ? 0 : 1;
4652:irmp.c        ****                                 last_value  = manchester_value;
4653:irmp.c        ****                             }
4654:irmp.c        ****                             else
4655:irmp.c        ****                             {
4656:irmp.c        ****                                 manchester_value = last_value;
4657:irmp.c        ****                             }
4658:irmp.c        **** 
4659:irmp.c        **** #ifdef ANALYZE
4660:irmp.c        ****                             ANALYZE_PUTCHAR (manchester_value + '0');
4661:irmp.c        **** #endif // ANALYZE
4662:irmp.c        **** 
4663:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCO
4664:irmp.c        ****                             if (! irmp_param2.protocol)
4665:irmp.c        **** #endif
4666:irmp.c        ****                             {
4667:irmp.c        **** #ifdef ANALYZE
4668:irmp.c        ****                                 ANALYZE_NEWLINE ();
4669:irmp.c        **** #endif // ANALYZE
4670:irmp.c        ****                             }
4671:irmp.c        **** 
4672:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
4673:irmp.c        ****                             if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 1 && manche
4674:irmp.c        ****                             {
4675:irmp.c        **** #ifdef ANALYZE
4676:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to RC6A protocol\n");
4677:irmp.c        **** #endif // ANALYZE
4678:irmp.c        ****                                 irmp_param.complete_len = RC6_COMPLETE_DATA_LEN_LONG;
4679:irmp.c        ****                                 irmp_param.address_offset = 5;
4680:irmp.c        ****                                 irmp_param.address_end = irmp_param.address_offset + 15;
4681:irmp.c        ****                                 irmp_param.command_offset = irmp_param.address_end + 1;            
4682:irmp.c        ****                                 irmp_param.command_end = irmp_param.command_offset + 16 - 1;
4683:irmp.c        ****                                 irmp_tmp_address = 0;
4684:irmp.c        ****                             }
4685:irmp.c        **** #endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
4686:irmp.c        **** 
4687:irmp.c        ****                             irmp_store_bit (manchester_value);
4688:irmp.c        ****                         }
4689:irmp.c        ****                         else
4690:irmp.c        ****                         {
4691:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_FDC_PROTOCOL == 1
4692:irmp.c        ****                             if (irmp_param2.protocol == IRMP_FDC_PROTOCOL &&
4693:irmp.c        ****                                 irmp_pulse_time >= FDC_PULSE_LEN_MIN && irmp_pulse_time <= FDC_PULS
4694:irmp.c        ****                                 ((irmp_pause_time >= FDC_1_PAUSE_LEN_MIN && irmp_pause_time <= FDC_
4695:irmp.c        ****                                  (irmp_pause_time >= FDC_0_PAUSE_LEN_MIN && irmp_pause_time <= FDC_
4696:irmp.c        ****                             {
4697:irmp.c        **** #ifdef ANALYZE
4698:irmp.c        ****                                 ANALYZE_PUTCHAR ('?');
4699:irmp.c        **** #endif // ANALYZE
4700:irmp.c        ****                                 irmp_param.protocol = 0;                // switch to FDC, see below
4701:irmp.c        ****                             }
4702:irmp.c        ****                             else
4703:irmp.c        **** #endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
4704:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_RCCAR_PROTOCOL == 1
4705:irmp.c        ****                             if (irmp_param2.protocol == IRMP_RCCAR_PROTOCOL &&
4706:irmp.c        ****                                 irmp_pulse_time >= RCCAR_PULSE_LEN_MIN && irmp_pulse_time <= RCCAR_
4707:irmp.c        ****                                 ((irmp_pause_time >= RCCAR_1_PAUSE_LEN_MIN && irmp_pause_time <= RC
4708:irmp.c        ****                                  (irmp_pause_time >= RCCAR_0_PAUSE_LEN_MIN && irmp_pause_time <= RC
4709:irmp.c        ****                             {
4710:irmp.c        **** #ifdef ANALYZE
4711:irmp.c        ****                                 ANALYZE_PUTCHAR ('?');
4712:irmp.c        **** #endif // ANALYZE
4713:irmp.c        ****                                 irmp_param.protocol = 0;                // switch to RCCAR, see bel
4714:irmp.c        ****                             }
4715:irmp.c        ****                             else
4716:irmp.c        **** #endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
4717:irmp.c        ****                             {
4718:irmp.c        **** #ifdef ANALYZE
4719:irmp.c        ****                                 ANALYZE_PUTCHAR ('?');
4720:irmp.c        ****                                 ANALYZE_NEWLINE ();
4721:irmp.c        ****                                 ANALYZE_PRINTF ("error 3 manchester: timing not correct: data bit %
4722:irmp.c        ****                                 ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
4723:irmp.c        **** #endif // ANALYZE
4724:irmp.c        ****                                 irmp_start_bit_detected = 0;                            // reset fl
4725:irmp.c        ****                                 irmp_pause_time         = 0;
4726:irmp.c        ****                             }
4727:irmp.c        ****                         }
4728:irmp.c        **** 
4729:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_FDC_PROTOCOL == 1
4730:irmp.c        ****                         if (irmp_param2.protocol == IRMP_FDC_PROTOCOL && irmp_pulse_time >= FDC_PUL
4731:irmp.c        ****                         {
4732:irmp.c        ****                             if (irmp_pause_time >= FDC_1_PAUSE_LEN_MIN && irmp_pause_time <= FDC_1_
4733:irmp.c        ****                             {
4734:irmp.c        **** #ifdef ANALYZE
4735:irmp.c        ****                                 ANALYZE_PRINTF ("   1 (FDC)\n");
4736:irmp.c        **** #endif // ANALYZE
4737:irmp.c        ****                                 irmp_store_bit2 (1);
4738:irmp.c        ****                             }
4739:irmp.c        ****                             else if (irmp_pause_time >= FDC_0_PAUSE_LEN_MIN && irmp_pause_time <= F
4740:irmp.c        ****                             {
4741:irmp.c        **** #ifdef ANALYZE
4742:irmp.c        ****                                 ANALYZE_PRINTF ("   0 (FDC)\n");
4743:irmp.c        **** #endif // ANALYZE
4744:irmp.c        ****                                 irmp_store_bit2 (0);
4745:irmp.c        ****                             }
4746:irmp.c        **** 
4747:irmp.c        ****                             if (! irmp_param.protocol)
4748:irmp.c        ****                             {
4749:irmp.c        **** #ifdef ANALYZE
4750:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to FDC protocol\n");
4751:irmp.c        **** #endif // ANALYZE
4752:irmp.c        ****                                 memcpy (&irmp_param, &irmp_param2, sizeof (IRMP_PARAMETER));
4753:irmp.c        ****                                 irmp_param2.protocol = 0;
4754:irmp.c        ****                                 irmp_tmp_address = irmp_tmp_address2;
4755:irmp.c        ****                                 irmp_tmp_command = irmp_tmp_command2;
4756:irmp.c        ****                             }
4757:irmp.c        ****                         }
4758:irmp.c        **** #endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
4759:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_RCCAR_PROTOCOL == 1
4760:irmp.c        ****                         if (irmp_param2.protocol == IRMP_RCCAR_PROTOCOL && irmp_pulse_time >= RCCAR
4761:irmp.c        ****                         {
4762:irmp.c        ****                             if (irmp_pause_time >= RCCAR_1_PAUSE_LEN_MIN && irmp_pause_time <= RCCA
4763:irmp.c        ****                             {
4764:irmp.c        **** #ifdef ANALYZE
4765:irmp.c        ****                                 ANALYZE_PRINTF ("   1 (RCCAR)\n");
4766:irmp.c        **** #endif // ANALYZE
4767:irmp.c        ****                                 irmp_store_bit2 (1);
4768:irmp.c        ****                             }
4769:irmp.c        ****                             else if (irmp_pause_time >= RCCAR_0_PAUSE_LEN_MIN && irmp_pause_time <=
4770:irmp.c        ****                             {
4771:irmp.c        **** #ifdef ANALYZE
4772:irmp.c        ****                                 ANALYZE_PRINTF ("   0 (RCCAR)\n");
4773:irmp.c        **** #endif // ANALYZE
4774:irmp.c        ****                                 irmp_store_bit2 (0);
4775:irmp.c        ****                             }
4776:irmp.c        **** 
4777:irmp.c        ****                             if (! irmp_param.protocol)
4778:irmp.c        ****                             {
4779:irmp.c        **** #ifdef ANALYZE
4780:irmp.c        ****                                 ANALYZE_PRINTF ("Switching to RCCAR protocol\n");
4781:irmp.c        **** #endif // ANALYZE
4782:irmp.c        ****                                 memcpy (&irmp_param, &irmp_param2, sizeof (IRMP_PARAMETER));
4783:irmp.c        ****                                 irmp_param2.protocol = 0;
4784:irmp.c        ****                                 irmp_tmp_address = irmp_tmp_address2;
4785:irmp.c        ****                                 irmp_tmp_command = irmp_tmp_command2;
4786:irmp.c        ****                             }
4787:irmp.c        ****                         }
4788:irmp.c        **** #endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
4789:irmp.c        **** 
4790:irmp.c        ****                         last_pause      = irmp_pause_time;
4791:irmp.c        ****                         wait_for_space  = 0;
4792:irmp.c        ****                     }
4793:irmp.c        ****                     else
4794:irmp.c        **** #endif // IRMP_SUPPORT_MANCHESTER == 1
4795:irmp.c        **** 
4796:irmp.c        **** #if IRMP_SUPPORT_SERIAL == 1
4797:irmp.c        ****                     if (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL)
4798:irmp.c        ****                     {
4799:irmp.c        ****                         while (irmp_bit < irmp_param.complete_len && irmp_pulse_time > irmp_param.p
4800:irmp.c        ****                         {
4801:irmp.c        **** #ifdef ANALYZE
4802:irmp.c        ****                             ANALYZE_PUTCHAR ('1');
4803:irmp.c        **** #endif // ANALYZE
4804:irmp.c        ****                             irmp_store_bit (1);
4805:irmp.c        **** 
4806:irmp.c        ****                             if (irmp_pulse_time >= irmp_param.pulse_1_len_min)
4807:irmp.c        ****                             {
4808:irmp.c        ****                                 irmp_pulse_time -= irmp_param.pulse_1_len_min;
4809:irmp.c        ****                             }
4810:irmp.c        ****                             else
4811:irmp.c        ****                             {
4812:irmp.c        ****                                 irmp_pulse_time = 0;
4813:irmp.c        ****                             }
4814:irmp.c        ****                         }
4815:irmp.c        **** 
4816:irmp.c        ****                         while (irmp_bit < irmp_param.complete_len && irmp_pause_time > irmp_param.p
4817:irmp.c        ****                         {
4818:irmp.c        **** #ifdef ANALYZE
4819:irmp.c        ****                             ANALYZE_PUTCHAR ('0');
4820:irmp.c        **** #endif // ANALYZE
4821:irmp.c        ****                             irmp_store_bit (0);
4822:irmp.c        **** 
4823:irmp.c        ****                             if (irmp_pause_time >= irmp_param.pause_1_len_min)
4824:irmp.c        ****                             {
4825:irmp.c        ****                                 irmp_pause_time -= irmp_param.pause_1_len_min;
4826:irmp.c        ****                             }
4827:irmp.c        ****                             else
4828:irmp.c        ****                             {
4829:irmp.c        ****                                 irmp_pause_time = 0;
4830:irmp.c        ****                             }
4831:irmp.c        ****                         }
4832:irmp.c        **** #ifdef ANALYZE
4833:irmp.c        ****                         ANALYZE_NEWLINE ();
4834:irmp.c        **** #endif // ANALYZE
4835:irmp.c        ****                         wait_for_space = 0;
4836:irmp.c        ****                     }
4837:irmp.c        ****                     else
4838:irmp.c        **** #endif // IRMP_SUPPORT_SERIAL == 1
4839:irmp.c        **** 
4840:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
4841:irmp.c        ****                     if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit == 16)       // Sa
4842:irmp.c        ****                     {
4843:irmp.c        ****                         if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_
4844:irmp.c        ****                             irmp_pause_time >= SAMSUNG_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <
4845:irmp.c        ****                         {
4846:irmp.c        **** #ifdef ANALYZE
4847:irmp.c        ****                             ANALYZE_PRINTF ("SYNC\n");
4848:irmp.c        **** #endif // ANALYZE
4849:irmp.c        ****                             wait_for_space = 0;
4850:irmp.c        ****                             irmp_bit++;
4851:irmp.c        ****                         }
4852:irmp.c        ****                         else  if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SA
4853:irmp.c        ****                         {
4854:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG48_PROTOCOL == 1
4855:irmp.c        **** #ifdef ANALYZE
4856:irmp.c        ****                             ANALYZE_PRINTF ("Switching to SAMSUNG48 protocol ");
4857:irmp.c        **** #endif // ANALYZE
4858:irmp.c        ****                             irmp_param.protocol         = IRMP_SAMSUNG48_PROTOCOL;
4859:irmp.c        ****                             irmp_param.command_offset   = SAMSUNG48_COMMAND_OFFSET;
4860:irmp.c        ****                             irmp_param.command_end      = SAMSUNG48_COMMAND_OFFSET + SAMSUNG48_COMM
4861:irmp.c        ****                             irmp_param.complete_len     = SAMSUNG48_COMPLETE_DATA_LEN;
4862:irmp.c        **** #else
4863:irmp.c        **** #ifdef ANALYZE
4864:irmp.c        ****                             ANALYZE_PRINTF ("Switching to SAMSUNG32 protocol ");
4865:irmp.c        **** #endif // ANALYZE
4866:irmp.c        ****                             irmp_param.protocol         = IRMP_SAMSUNG32_PROTOCOL;
4867:irmp.c        ****                             irmp_param.command_offset   = SAMSUNG32_COMMAND_OFFSET;
4868:irmp.c        ****                             irmp_param.command_end      = SAMSUNG32_COMMAND_OFFSET + SAMSUNG32_COMM
4869:irmp.c        ****                             irmp_param.complete_len     = SAMSUNG32_COMPLETE_DATA_LEN;
4870:irmp.c        **** #endif
4871:irmp.c        ****                             if (irmp_pause_time >= SAMSUNG_1_PAUSE_LEN_MIN && irmp_pause_time <= SA
4872:irmp.c        ****                             {
4873:irmp.c        **** #ifdef ANALYZE
4874:irmp.c        ****                                 ANALYZE_PUTCHAR ('1');
4875:irmp.c        ****                                 ANALYZE_NEWLINE ();
4876:irmp.c        **** #endif // ANALYZE
4877:irmp.c        ****                                 irmp_store_bit (1);
4878:irmp.c        ****                                 wait_for_space = 0;
4879:irmp.c        ****                             }
4880:irmp.c        ****                             else
4881:irmp.c        ****                             {
4882:irmp.c        **** #ifdef ANALYZE
4883:irmp.c        ****                                 ANALYZE_PUTCHAR ('0');
4884:irmp.c        ****                                 ANALYZE_NEWLINE ();
4885:irmp.c        **** #endif // ANALYZE
4886:irmp.c        ****                                 irmp_store_bit (0);
4887:irmp.c        ****                                 wait_for_space = 0;
4888:irmp.c        ****                             }
4889:irmp.c        ****                         }
4890:irmp.c        ****                         else
4891:irmp.c        ****                         {                                                           // timing incor
4892:irmp.c        **** #ifdef ANALYZE
4893:irmp.c        ****                             ANALYZE_PRINTF ("error 3 Samsung: timing not correct: data bit %d,  pul
4894:irmp.c        ****                             ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
4895:irmp.c        **** #endif // ANALYZE
4896:irmp.c        ****                             irmp_start_bit_detected = 0;                            // reset flags 
4897:irmp.c        ****                             irmp_pause_time         = 0;
4898:irmp.c        ****                         }
4899:irmp.c        ****                     }
4900:irmp.c        ****                     else
4901:irmp.c        **** #endif // IRMP_SUPPORT_SAMSUNG_PROTOCOL
4902:irmp.c        **** 
4903:irmp.c        **** #if IRMP_SUPPORT_NEC16_PROTOCOL
4904:irmp.c        **** #if IRMP_SUPPORT_NEC42_PROTOCOL == 1
4905:irmp.c        ****                     if (irmp_param.protocol == IRMP_NEC42_PROTOCOL &&
4906:irmp.c        **** #else // IRMP_SUPPORT_NEC_PROTOCOL instead
4907:irmp.c        ****                     if (irmp_param.protocol == IRMP_NEC_PROTOCOL &&
4908:irmp.c        **** #endif // IRMP_SUPPORT_NEC42_PROTOCOL == 1
4909:irmp.c        ****                         irmp_bit == 8 && irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pau
4910:irmp.c        ****                     {
4911:irmp.c        **** #ifdef ANALYZE
4912:irmp.c        ****                         ANALYZE_PRINTF ("Switching to NEC16 protocol\n");
4913:irmp.c        **** #endif // ANALYZE
4914:irmp.c        ****                         irmp_param.protocol         = IRMP_NEC16_PROTOCOL;
4915:irmp.c        ****                         irmp_param.address_offset   = NEC16_ADDRESS_OFFSET;
4916:irmp.c        ****                         irmp_param.address_end      = NEC16_ADDRESS_OFFSET + NEC16_ADDRESS_LEN;
4917:irmp.c        ****                         irmp_param.command_offset   = NEC16_COMMAND_OFFSET;
4918:irmp.c        ****                         irmp_param.command_end      = NEC16_COMMAND_OFFSET + NEC16_COMMAND_LEN;
4919:irmp.c        ****                         irmp_param.complete_len     = NEC16_COMPLETE_DATA_LEN;
4920:irmp.c        ****                         wait_for_space = 0;
4921:irmp.c        ****                     }
4922:irmp.c        ****                     else
4923:irmp.c        **** #endif // IRMP_SUPPORT_NEC16_PROTOCOL
4924:irmp.c        **** 
4925:irmp.c        **** #if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
4926:irmp.c        ****                     if (irmp_param.protocol == IRMP_BANG_OLUFSEN_PROTOCOL)
4927:irmp.c        ****                     {
4928:irmp.c        ****                         if (irmp_pulse_time >= BANG_OLUFSEN_PULSE_LEN_MIN && irmp_pulse_time <= BAN
4929:irmp.c        ****                         {
4930:irmp.c        ****                             if (irmp_bit == 1)                                      // Bang & Olufs
4931:irmp.c        ****                             {
4932:irmp.c        ****                                 if (irmp_pause_time >= BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN && irm
4933:irmp.c        ****                                 {
4934:irmp.c        **** #ifdef ANALYZE
4935:irmp.c        ****                                     ANALYZE_PRINTF ("3rd start bit\n");
4936:irmp.c        **** #endif // ANALYZE
4937:irmp.c        ****                                     wait_for_space = 0;
4938:irmp.c        ****                                     irmp_bit++;
4939:irmp.c        ****                                 }
4940:irmp.c        ****                                 else
4941:irmp.c        ****                                 {                                                   // timing incor
4942:irmp.c        **** #ifdef ANALYZE
4943:irmp.c        ****                                     ANALYZE_PRINTF ("error 3a B&O: timing not correct: data bit %d,
4944:irmp.c        ****                                     ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
4945:irmp.c        **** #endif // ANALYZE
4946:irmp.c        ****                                     irmp_start_bit_detected = 0;                    // reset flags 
4947:irmp.c        ****                                     irmp_pause_time         = 0;
4948:irmp.c        ****                                 }
4949:irmp.c        ****                             }
4950:irmp.c        ****                             else if (irmp_bit == 19)                                // Bang & Olufs
4951:irmp.c        ****                             {
4952:irmp.c        ****                                 if (irmp_pause_time >= BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MIN && ir
4953:irmp.c        ****                                 {
4954:irmp.c        **** #ifdef ANALYZE
4955:irmp.c        ****                                     ANALYZE_PRINTF ("trailer bit\n");
4956:irmp.c        **** #endif // ANALYZE
4957:irmp.c        ****                                     wait_for_space = 0;
4958:irmp.c        ****                                     irmp_bit++;
4959:irmp.c        ****                                 }
4960:irmp.c        ****                                 else
4961:irmp.c        ****                                 {                                                   // timing incor
4962:irmp.c        **** #ifdef ANALYZE
4963:irmp.c        ****                                     ANALYZE_PRINTF ("error 3b B&O: timing not correct: data bit %d,
4964:irmp.c        ****                                     ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
4965:irmp.c        **** #endif // ANALYZE
4966:irmp.c        ****                                     irmp_start_bit_detected = 0;                    // reset flags 
4967:irmp.c        ****                                     irmp_pause_time         = 0;
4968:irmp.c        ****                                 }
4969:irmp.c        ****                             }
4970:irmp.c        ****                             else
4971:irmp.c        ****                             {
4972:irmp.c        ****                                 if (irmp_pause_time >= BANG_OLUFSEN_1_PAUSE_LEN_MIN && irmp_pause_t
4973:irmp.c        ****                                 {                                                   // pulse & paus
4974:irmp.c        **** #ifdef ANALYZE
4975:irmp.c        ****                                     ANALYZE_PUTCHAR ('1');
4976:irmp.c        ****                                     ANALYZE_NEWLINE ();
4977:irmp.c        **** #endif // ANALYZE
4978:irmp.c        ****                                     irmp_store_bit (1);
4979:irmp.c        ****                                     last_value = 1;
4980:irmp.c        ****                                     wait_for_space = 0;
4981:irmp.c        ****                                 }
4982:irmp.c        ****                                 else if (irmp_pause_time >= BANG_OLUFSEN_0_PAUSE_LEN_MIN && irmp_pa
4983:irmp.c        ****                                 {                                                   // pulse & paus
4984:irmp.c        **** #ifdef ANALYZE
4985:irmp.c        ****                                     ANALYZE_PUTCHAR ('0');
4986:irmp.c        ****                                     ANALYZE_NEWLINE ();
4987:irmp.c        **** #endif // ANALYZE
4988:irmp.c        ****                                     irmp_store_bit (0);
4989:irmp.c        ****                                     last_value = 0;
4990:irmp.c        ****                                     wait_for_space = 0;
4991:irmp.c        ****                                 }
4992:irmp.c        ****                                 else if (irmp_pause_time >= BANG_OLUFSEN_R_PAUSE_LEN_MIN && irmp_pa
4993:irmp.c        ****                                 {
4994:irmp.c        **** #ifdef ANALYZE
4995:irmp.c        ****                                     ANALYZE_PUTCHAR (last_value + '0');
4996:irmp.c        ****                                     ANALYZE_NEWLINE ();
4997:irmp.c        **** #endif // ANALYZE
4998:irmp.c        ****                                     irmp_store_bit (last_value);
4999:irmp.c        ****                                     wait_for_space = 0;
5000:irmp.c        ****                                 }
5001:irmp.c        ****                                 else
5002:irmp.c        ****                                 {                                                   // timing incor
5003:irmp.c        **** #ifdef ANALYZE
5004:irmp.c        ****                                     ANALYZE_PRINTF ("error 3c B&O: timing not correct: data bit %d,
5005:irmp.c        ****                                     ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
5006:irmp.c        **** #endif // ANALYZE
5007:irmp.c        ****                                     irmp_start_bit_detected = 0;                    // reset flags 
5008:irmp.c        ****                                     irmp_pause_time         = 0;
5009:irmp.c        ****                                 }
5010:irmp.c        ****                             }
5011:irmp.c        ****                         }
5012:irmp.c        ****                         else
5013:irmp.c        ****                         {                                                           // timing incor
5014:irmp.c        **** #ifdef ANALYZE
5015:irmp.c        ****                             ANALYZE_PRINTF ("error 3d B&O: timing not correct: data bit %d,  pulse:
5016:irmp.c        ****                             ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
5017:irmp.c        **** #endif // ANALYZE
5018:irmp.c        ****                             irmp_start_bit_detected = 0;                            // reset flags 
5019:irmp.c        ****                             irmp_pause_time         = 0;
5020:irmp.c        ****                         }
5021:irmp.c        ****                     }
5022:irmp.c        ****                     else
5023:irmp.c        **** #endif // IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL
5024:irmp.c        **** 
5025:irmp.c        **** #if IRMP_SUPPORT_RCMM_PROTOCOL == 1
5026:irmp.c        ****                     if (irmp_param.protocol == IRMP_RCMM32_PROTOCOL)
5027:irmp.c        ****                     {
5028:irmp.c        ****                         if (irmp_pause_time >= RCMM32_BIT_00_PAUSE_LEN_MIN && irmp_pause_time <= RC
5029:irmp.c        ****                         {
5030:irmp.c        **** #ifdef ANALYZE
5031:irmp.c        ****                             ANALYZE_PUTCHAR ('0');
5032:irmp.c        ****                             ANALYZE_PUTCHAR ('0');
5033:irmp.c        **** #endif // ANALYZE
5034:irmp.c        ****                             irmp_store_bit (0);
5035:irmp.c        ****                             irmp_store_bit (0);
5036:irmp.c        ****                         }
5037:irmp.c        ****                         else if (irmp_pause_time >= RCMM32_BIT_01_PAUSE_LEN_MIN && irmp_pause_time 
5038:irmp.c        ****                         {
5039:irmp.c        **** #ifdef ANALYZE
5040:irmp.c        ****                             ANALYZE_PUTCHAR ('0');
5041:irmp.c        ****                             ANALYZE_PUTCHAR ('1');
5042:irmp.c        **** #endif // ANALYZE
5043:irmp.c        ****                             irmp_store_bit (0);
5044:irmp.c        ****                             irmp_store_bit (1);
5045:irmp.c        ****                         }
5046:irmp.c        ****                         else if (irmp_pause_time >= RCMM32_BIT_10_PAUSE_LEN_MIN && irmp_pause_time 
5047:irmp.c        ****                         {
5048:irmp.c        **** #ifdef ANALYZE
5049:irmp.c        ****                             ANALYZE_PUTCHAR ('1');
5050:irmp.c        ****                             ANALYZE_PUTCHAR ('0');
5051:irmp.c        **** #endif // ANALYZE
5052:irmp.c        ****                             irmp_store_bit (1);
5053:irmp.c        ****                             irmp_store_bit (0);
5054:irmp.c        ****                         }
5055:irmp.c        ****                         else if (irmp_pause_time >= RCMM32_BIT_11_PAUSE_LEN_MIN && irmp_pause_time 
5056:irmp.c        ****                         {
5057:irmp.c        **** #ifdef ANALYZE
5058:irmp.c        ****                             ANALYZE_PUTCHAR ('1');
5059:irmp.c        ****                             ANALYZE_PUTCHAR ('1');
5060:irmp.c        **** #endif // ANALYZE
5061:irmp.c        ****                             irmp_store_bit (1);
5062:irmp.c        ****                             irmp_store_bit (1);
5063:irmp.c        ****                         }
5064:irmp.c        **** #ifdef ANALYZE
5065:irmp.c        ****                         ANALYZE_PRINTF ("\n");
5066:irmp.c        **** #endif // ANALYZE
5067:irmp.c        ****                         wait_for_space = 0;
5068:irmp.c        ****                     }
5069:irmp.c        ****                     else
5070:irmp.c        **** #endif
5071:irmp.c        **** 
5072:irmp.c        ****                     if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <= irmp_pa
5073:irmp.c        ****                         irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_pa
5074:irmp.c        ****                     {                                                               // pulse & paus
5075:irmp.c        **** #ifdef ANALYZE
5076:irmp.c        ****                         ANALYZE_PUTCHAR ('1');
5077:irmp.c        ****                         ANALYZE_NEWLINE ();
5078:irmp.c        **** #endif // ANALYZE
5079:irmp.c        ****                         irmp_store_bit (1);
5080:irmp.c        ****                         wait_for_space = 0;
5081:irmp.c        ****                     }
5082:irmp.c        ****                     else if (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= ir
5083:irmp.c        ****                              irmp_pause_time >= irmp_param.pause_0_len_min && irmp_pause_time <= ir
5084:irmp.c        ****                     {                                                               // pulse & paus
5085:irmp.c        **** #ifdef ANALYZE
5086:irmp.c        ****                         ANALYZE_PUTCHAR ('0');
5087:irmp.c        ****                         ANALYZE_NEWLINE ();
5088:irmp.c        **** #endif // ANALYZE
5089:irmp.c        ****                         irmp_store_bit (0);
5090:irmp.c        ****                         wait_for_space = 0;
5091:irmp.c        ****                     }
5092:irmp.c        ****                     else
5093:irmp.c        **** #if IRMP_SUPPORT_KATHREIN_PROTOCOL
5094:irmp.c        **** 
5095:irmp.c        ****                     if (irmp_param.protocol == IRMP_KATHREIN_PROTOCOL &&
5096:irmp.c        ****                         irmp_pulse_time >= KATHREIN_1_PULSE_LEN_MIN && irmp_pulse_time <= KATHREIN_
5097:irmp.c        ****                         (((irmp_bit == 8 || irmp_bit == 6) &&
5098:irmp.c        ****                                 irmp_pause_time >= KATHREIN_SYNC_BIT_PAUSE_LEN_MIN && irmp_pause_ti
5099:irmp.c        ****                          (irmp_bit == 12 &&
5100:irmp.c        ****                                 irmp_pause_time >= KATHREIN_START_BIT_PAUSE_LEN_MIN && irmp_pause_t
5101:irmp.c        **** 
5102:irmp.c        ****                     {
5103:irmp.c        ****                         if (irmp_bit == 8)
5104:irmp.c        ****                         {
5105:irmp.c        ****                             irmp_bit++;
5106:irmp.c        **** #ifdef ANALYZE
5107:irmp.c        ****                             ANALYZE_PUTCHAR ('S');
5108:irmp.c        ****                             ANALYZE_NEWLINE ();
5109:irmp.c        **** #endif // ANALYZE
5110:irmp.c        ****                             irmp_tmp_command <<= 1;
5111:irmp.c        ****                         }
5112:irmp.c        ****                         else
5113:irmp.c        ****                         {
5114:irmp.c        **** #ifdef ANALYZE
5115:irmp.c        ****                             ANALYZE_PUTCHAR ('S');
5116:irmp.c        ****                             ANALYZE_NEWLINE ();
5117:irmp.c        **** #endif // ANALYZE
5118:irmp.c        ****                             irmp_store_bit (1);
5119:irmp.c        ****                         }
5120:irmp.c        ****                         wait_for_space = 0;
5121:irmp.c        ****                     }
5122:irmp.c        ****                     else
5123:irmp.c        **** #endif // IRMP_SUPPORT_KATHREIN_PROTOCOL
5124:irmp.c        ****                     {                                                               // timing incor
5125:irmp.c        **** #ifdef ANALYZE
5126:irmp.c        ****                         ANALYZE_PRINTF ("error 3: timing not correct: data bit %d,  pulse: %d, paus
5127:irmp.c        ****                         ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
5128:irmp.c        **** #endif // ANALYZE
5129:irmp.c        ****                         irmp_start_bit_detected = 0;                                // reset flags 
5130:irmp.c        ****                         irmp_pause_time         = 0;
5131:irmp.c        ****                     }
5132:irmp.c        **** 
5133:irmp.c        ****                     irmp_pulse_time = 1;                                            // set counter 
5134:irmp.c        ****                 }
5135:irmp.c        ****             }
5136:irmp.c        ****             else
5137:irmp.c        ****             {                                                                       // counting the
5138:irmp.c        ****                 if (! irmp_input)                                                   // still light?
5139:irmp.c        ****                 {                                                                   // yes...
5140:irmp.c        ****                     irmp_pulse_time++;                                              // increment co
5141:irmp.c        ****                 }
5142:irmp.c        ****                 else
5143:irmp.c        ****                 {                                                                   // now it's dar
5144:irmp.c        ****                     wait_for_space  = 1;                                            // let's count 
5145:irmp.c        ****                     irmp_pause_time = 1;                                            // set pause co
5146:irmp.c        **** 
5147:irmp.c        **** #if IRMP_SUPPORT_RCII_PROTOCOL == 1
5148:irmp.c        ****                     if (irmp_param.protocol == IRMP_RCII_PROTOCOL && waiting_for_2nd_pulse)
5149:irmp.c        ****                     {
5150:irmp.c        **** printf ("fm: %d %d\n", irmp_pulse_time * 1000000 / F_INTERRUPTS, RCII_BIT_LEN * 1000000 / F_INTERRU
5151:irmp.c        **** #if 0
5152:irmp.c        ****                         if (irmp_pulse_time >= RCII_BIT_LEN)
5153:irmp.c        ****                         {
5154:irmp.c        ****                             irmp_pulse_time -= RCII_BIT_LEN;
5155:irmp.c        ****                             last_value = 0;
5156:irmp.c        ****                         }
5157:irmp.c        ****                         else
5158:irmp.c        ****                         {
5159:irmp.c        ****                             last_value = 1;
5160:irmp.c        ****                         }
5161:irmp.c        **** #else // fm: das reicht fr RCII
5162:irmp.c        ****                             irmp_pulse_time -= RCII_BIT_LEN;
5163:irmp.c        ****                             last_value = 0;
5164:irmp.c        **** #endif
5165:irmp.c        **** 
5166:irmp.c        **** #ifdef ANALYZE
5167:irmp.c        ****                         ANALYZE_PRINTF ("RCII: got 2nd pulse, irmp_pulse_time = %d\n", irmp_pulse_t
5168:irmp.c        **** #endif
5169:irmp.c        ****                         waiting_for_2nd_pulse = 0;
5170:irmp.c        ****                     }
5171:irmp.c        **** #endif
5172:irmp.c        ****                 }
5173:irmp.c        ****             }
5174:irmp.c        **** 
5175:irmp.c        ****             if (irmp_start_bit_detected && irmp_bit == irmp_param.complete_len && irmp_param.stop_b
5176:irmp.c        ****             {
5177:irmp.c        ****                 if (last_irmp_command == irmp_tmp_command && key_repetition_len < AUTO_FRAME_REPETI
5178:irmp.c        ****                 {
5179:irmp.c        ****                     repetition_frame_number++;
5180:irmp.c        ****                 }
5181:irmp.c        ****                 else
5182:irmp.c        ****                 {
5183:irmp.c        ****                     repetition_frame_number = 0;
5184:irmp.c        ****                 }
5185:irmp.c        **** 
5186:irmp.c        **** #if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
5187:irmp.c        ****                 // if SIRCS protocol and the code will be repeated within 50 ms, we will ignore 2nd
5188:irmp.c        ****                 if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL && (repetition_frame_number == 1 || 
5189:irmp.c        ****                 {
5190:irmp.c        **** #ifdef ANALYZE
5191:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: SIRCS auto repetition frame #%d, counter = %d, a
5192:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
5193:irmp.c        **** #endif // ANALYZE
5194:irmp.c        ****                     key_repetition_len = 0;
5195:irmp.c        ****                 }
5196:irmp.c        ****                 else
5197:irmp.c        **** #endif
5198:irmp.c        **** 
5199:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
5200:irmp.c        ****                 // if ORTEK protocol and the code will be repeated within 50 ms, we will ignore 2nd
5201:irmp.c        ****                 if (irmp_param.protocol == IRMP_ORTEK_PROTOCOL && repetition_frame_number == 1)
5202:irmp.c        ****                 {
5203:irmp.c        **** #ifdef ANALYZE
5204:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: ORTEK auto repetition frame #%d, counter = %d, a
5205:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
5206:irmp.c        **** #endif // ANALYZE
5207:irmp.c        ****                     key_repetition_len = 0;
5208:irmp.c        ****                 }
5209:irmp.c        ****                 else
5210:irmp.c        **** #endif
5211:irmp.c        **** 
5212:irmp.c        **** #if 0 && IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1    // fm 2015-12-02: don't ignore every 2nd frame
5213:irmp.c        ****                 // if KASEIKYO protocol and the code will be repeated within 50 ms, we will ignore 
5214:irmp.c        ****                 if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL && repetition_frame_number == 1)
5215:irmp.c        ****                 {
5216:irmp.c        **** #ifdef ANALYZE
5217:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: KASEIKYO auto repetition frame #%d, counter = %d
5218:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
5219:irmp.c        **** #endif // ANALYZE
5220:irmp.c        ****                     key_repetition_len = 0;
5221:irmp.c        ****                 }
5222:irmp.c        ****                 else
5223:irmp.c        **** #endif
5224:irmp.c        **** 
5225:irmp.c        **** #if 0 && IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1     // fm 2015-12-02: don't ignore every 2nd frame
5226:irmp.c        ****                 // if SAMSUNG32 or SAMSUNG48 protocol and the code will be repeated within 50 ms, w
5227:irmp.c        ****                 if ((irmp_param.protocol == IRMP_SAMSUNG32_PROTOCOL || irmp_param.protocol == IRMP_
5228:irmp.c        ****                 {
5229:irmp.c        **** #ifdef ANALYZE
5230:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: SAMSUNG32/SAMSUNG48 auto repetition frame #%d, c
5231:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
5232:irmp.c        **** #endif // ANALYZE
5233:irmp.c        ****                     key_repetition_len = 0;
5234:irmp.c        ****                 }
5235:irmp.c        ****                 else
5236:irmp.c        **** #endif
5237:irmp.c        **** 
5238:irmp.c        **** #if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
5239:irmp.c        ****                 // if NUBERT protocol and the code will be repeated within 50 ms, we will ignore ev
5240:irmp.c        ****                 if (irmp_param.protocol == IRMP_NUBERT_PROTOCOL && (repetition_frame_number & 0x01)
5241:irmp.c        ****                 {
5242:irmp.c        **** #ifdef ANALYZE
5243:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: NUBERT auto repetition frame #%d, counter = %d, 
5244:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
5245:irmp.c        **** #endif // ANALYZE
5246:irmp.c        ****                     key_repetition_len = 0;
5247:irmp.c        ****                 }
5248:irmp.c        ****                 else
5249:irmp.c        **** #endif
5250:irmp.c        **** 
5251:irmp.c        **** #if IRMP_SUPPORT_SPEAKER_PROTOCOL == 1
5252:irmp.c        ****                 // if SPEAKER protocol and the code will be repeated within 50 ms, we will ignore e
5253:irmp.c        ****                 if (irmp_param.protocol == IRMP_SPEAKER_PROTOCOL && (repetition_frame_number & 0x01
5254:irmp.c        ****                 {
5255:irmp.c        **** #ifdef ANALYZE
5256:irmp.c        ****                     ANALYZE_PRINTF ("code skipped: SPEAKER auto repetition frame #%d, counter = %d,
5257:irmp.c        ****                                     repetition_frame_number + 1, key_repetition_len, AUTO_FRAME_REP
5258:irmp.c        **** #endif // ANALYZE
5259:irmp.c        ****                     key_repetition_len = 0;
5260:irmp.c        ****                 }
5261:irmp.c        ****                 else
5262:irmp.c        **** #endif
5263:irmp.c        **** 
5264:irmp.c        ****                 {
5265:irmp.c        **** #ifdef ANALYZE
5266:irmp.c        ****                     ANALYZE_PRINTF ("%8.3fms code detected, length = %d\n", (double) (time_counter 
5267:irmp.c        **** #endif // ANALYZE
5268:irmp.c        ****                     irmp_ir_detected = TRUE;
5269:irmp.c        **** 
5270:irmp.c        **** #if IRMP_SUPPORT_DENON_PROTOCOL == 1
5271:irmp.c        ****                     if (irmp_param.protocol == IRMP_DENON_PROTOCOL)
5272:irmp.c        ****                     {                                                               // check for re
5273:irmp.c        ****                         if ((~irmp_tmp_command & 0x3FF) == last_irmp_denon_command) // command bits
5274:irmp.c        ****                         {
5275:irmp.c        ****                             irmp_tmp_command = last_irmp_denon_command;             // use command 
5276:irmp.c        ****                             last_irmp_denon_command = 0;
5277:irmp.c        **** 
5278:irmp.c        ****                             irmp_protocol = irmp_param.protocol;                    // store protoc
5279:irmp.c        ****                             irmp_address = irmp_tmp_address;                        // store addres
5280:irmp.c        ****                             irmp_command = irmp_tmp_command;                        // store comman
5281:irmp.c        ****                         }
5282:irmp.c        ****                         else
5283:irmp.c        ****                         {
5284:irmp.c        ****                             if ((irmp_tmp_command & 0x01) == 0x00)
5285:irmp.c        ****                             {
5286:irmp.c        **** #ifdef ANALYZE
5287:irmp.c        ****                                 ANALYZE_PRINTF ("%8.3fms info Denon: waiting for inverted command r
5288:irmp.c        **** #endif // ANALYZE
5289:irmp.c        ****                                 last_irmp_denon_command = irmp_tmp_command;
5290:irmp.c        ****                                 denon_repetition_len = 0;
5291:irmp.c        ****                                 irmp_ir_detected = FALSE;
5292:irmp.c        ****                             }
5293:irmp.c        ****                             else
5294:irmp.c        ****                             {
5295:irmp.c        **** #ifdef ANALYZE
5296:irmp.c        ****                                 ANALYZE_PRINTF ("%8.3fms warning Denon: got unexpected inverted com
5297:irmp.c        **** #endif // ANALYZE
5298:irmp.c        ****                                 last_irmp_denon_command = 0;
5299:irmp.c        ****                                 irmp_ir_detected = FALSE;
5300:irmp.c        ****                             }
5301:irmp.c        ****                         }
5302:irmp.c        ****                     }
5303:irmp.c        ****                     else
5304:irmp.c        **** #endif // IRMP_SUPPORT_DENON_PROTOCOL
5305:irmp.c        **** 
5306:irmp.c        **** #if IRMP_SUPPORT_GRUNDIG_PROTOCOL == 1
5307:irmp.c        ****                     if (irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL && irmp_tmp_command == 0x01ff)
5308:irmp.c        ****                     {                                                               // Grundig star
5309:irmp.c        **** #ifdef ANALYZE
5310:irmp.c        ****                         ANALYZE_PRINTF ("Detected GRUNDIG start frame, ignoring it\n");
5311:irmp.c        **** #endif // ANALYZE
5312:irmp.c        ****                         irmp_ir_detected = FALSE;
5313:irmp.c        ****                     }
5314:irmp.c        ****                     else
5315:irmp.c        **** #endif // IRMP_SUPPORT_GRUNDIG_PROTOCOL
5316:irmp.c        **** 
5317:irmp.c        **** #if IRMP_SUPPORT_NOKIA_PROTOCOL == 1
5318:irmp.c        ****                     if (irmp_param.protocol == IRMP_NOKIA_PROTOCOL && irmp_tmp_address == 0x00ff &&
5319:irmp.c        ****                     {                                                               // Nokia start 
5320:irmp.c        **** #ifdef ANALYZE
5321:irmp.c        ****                         ANALYZE_PRINTF ("Detected NOKIA start frame, ignoring it\n");
5322:irmp.c        **** #endif // ANALYZE
5323:irmp.c        ****                         irmp_ir_detected = FALSE;
5324:irmp.c        ****                     }
5325:irmp.c        ****                     else
5326:irmp.c        **** #endif // IRMP_SUPPORT_NOKIA_PROTOCOL
5327:irmp.c        ****                     {
5328:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
5329:irmp.c        ****                         if (irmp_param.protocol == IRMP_NEC_PROTOCOL && irmp_bit == 0)  // repetiti
5330:irmp.c        ****                         {
5331:irmp.c        ****                             if (key_repetition_len < NEC_FRAME_REPEAT_PAUSE_LEN_MAX)
5332:irmp.c        ****                             {
5333:irmp.c        **** #ifdef ANALYZE
5334:irmp.c        ****                                 ANALYZE_PRINTF ("Detected NEC repetition frame, key_repetition_len 
5335:irmp.c        ****                                 ANALYZE_ONLY_NORMAL_PRINTF("REPETETION FRAME                ");
5336:irmp.c        **** #endif // ANALYZE
5337:irmp.c        ****                                 irmp_tmp_address = last_irmp_address;                   // address 
5338:irmp.c        ****                                 irmp_tmp_command = last_irmp_command;                   // command 
5339:irmp.c        ****                                 irmp_flags |= IRMP_FLAG_REPETITION;
5340:irmp.c        ****                                 key_repetition_len = 0;
5341:irmp.c        ****                             }
5342:irmp.c        ****                             else
5343:irmp.c        ****                             {
5344:irmp.c        **** #ifdef ANALYZE
5345:irmp.c        ****                                 ANALYZE_PRINTF ("Detected NEC repetition frame, ignoring it: timeou
5346:irmp.c        ****                                                 key_repetition_len, NEC_FRAME_REPEAT_PAUSE_LEN_MAX)
5347:irmp.c        **** #endif // ANALYZE
5348:irmp.c        ****                                 irmp_ir_detected = FALSE;
5349:irmp.c        ****                             }
5350:irmp.c        ****                         }
5351:irmp.c        **** #endif // IRMP_SUPPORT_NEC_PROTOCOL
5352:irmp.c        **** 
5353:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
5354:irmp.c        ****                         if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL)
5355:irmp.c        ****                         {
5356:irmp.c        ****                             uint_fast8_t xor_value;
5357:irmp.c        **** 
5358:irmp.c        ****                             xor_value = (xor_check[0] & 0x0F) ^ ((xor_check[0] & 0xF0) >> 4) ^ (xor
5359:irmp.c        **** 
5360:irmp.c        ****                             if (xor_value != (xor_check[2] & 0x0F))
5361:irmp.c        ****                             {
5362:irmp.c        **** #ifdef ANALYZE
5363:irmp.c        ****                                 ANALYZE_PRINTF ("error 4: wrong XOR check for customer id: 0x%1x 0x
5364:irmp.c        **** #endif // ANALYZE
5365:irmp.c        ****                                 irmp_ir_detected = FALSE;
5366:irmp.c        ****                             }
5367:irmp.c        **** 
5368:irmp.c        ****                             xor_value = xor_check[2] ^ xor_check[3] ^ xor_check[4];
5369:irmp.c        **** 
5370:irmp.c        ****                             if (xor_value != xor_check[5])
5371:irmp.c        ****                             {
5372:irmp.c        **** #ifdef ANALYZE
5373:irmp.c        ****                                 ANALYZE_PRINTF ("error 5: wrong XOR check for data bits: 0x%02x 0x%
5374:irmp.c        **** #endif // ANALYZE
5375:irmp.c        ****                                 irmp_ir_detected = FALSE;
5376:irmp.c        ****                             }
5377:irmp.c        **** 
5378:irmp.c        ****                             irmp_flags |= genre2;       // write the genre2 bits into MSB of the fl
5379:irmp.c        ****                         }
5380:irmp.c        **** #endif // IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
5381:irmp.c        **** 
5382:irmp.c        **** #if IRMP_SUPPORT_ORTEK_PROTOCOL == 1
5383:irmp.c        ****                         if (irmp_param.protocol == IRMP_ORTEK_PROTOCOL)
5384:irmp.c        ****                         {
5385:irmp.c        ****                             if (parity == PARITY_CHECK_FAILED)
5386:irmp.c        ****                             {
5387:irmp.c        **** #ifdef ANALYZE
5388:irmp.c        ****                                 ANALYZE_PRINTF ("error 6: parity check failed\n");
5389:irmp.c        **** #endif // ANALYZE
5390:irmp.c        ****                                 irmp_ir_detected = FALSE;
5391:irmp.c        ****                             }
5392:irmp.c        **** 
5393:irmp.c        ****                             if ((irmp_tmp_address & 0x03) == 0x02)
5394:irmp.c        ****                             {
5395:irmp.c        **** #ifdef ANALYZE
5396:irmp.c        ****                                 ANALYZE_PRINTF ("code skipped: ORTEK end of transmission frame (key
5397:irmp.c        **** #endif // ANALYZE
5398:irmp.c        ****                                 irmp_ir_detected = FALSE;
5399:irmp.c        ****                             }
5400:irmp.c        ****                             irmp_tmp_address >>= 2;
5401:irmp.c        ****                         }
5402:irmp.c        **** #endif // IRMP_SUPPORT_ORTEK_PROTOCOL == 1
5403:irmp.c        **** 
5404:irmp.c        **** #if IRMP_SUPPORT_MITSU_HEAVY_PROTOCOL == 1
5405:irmp.c        ****                         if (irmp_param.protocol == IRMP_MITSU_HEAVY_PROTOCOL)
5406:irmp.c        ****                         {
5407:irmp.c        ****                             check = irmp_tmp_command >> 8;                    // inverted upper byt
5408:irmp.c        ****                             check = ~ check;
5409:irmp.c        ****                             if (check == (irmp_tmp_command & 0xFF)) {         //ok:
5410:irmp.c        ****                               irmp_tmp_command &= 0xFF;
5411:irmp.c        ****                             }
5412:irmp.c        ****                             else  mitsu_parity = PARITY_CHECK_FAILED;
5413:irmp.c        ****                             if (mitsu_parity == PARITY_CHECK_FAILED)
5414:irmp.c        ****                             {
5415:irmp.c        **** #ifdef ANALYZE
5416:irmp.c        ****                                 ANALYZE_PRINTF ("error 7: parity check failed\n");
5417:irmp.c        **** #endif // ANALYZE
5418:irmp.c        ****                                 irmp_ir_detected = FALSE;
5419:irmp.c        ****                             }
5420:irmp.c        ****                         }
5421:irmp.c        **** #endif // IRMP_SUPPORT_MITSU_HEAVY_PROTOCOL
5422:irmp.c        **** 
5423:irmp.c        **** #if IRMP_SUPPORT_RC6_PROTOCOL == 1
5424:irmp.c        ****                         if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_param.complete_len == 
5425:irmp.c        ****                         {
5426:irmp.c        ****                             irmp_protocol = IRMP_RC6A_PROTOCOL;
5427:irmp.c        ****                         }
5428:irmp.c        ****                         else
5429:irmp.c        **** #endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
5430:irmp.c        ****                         {
5431:irmp.c        ****                             irmp_protocol = irmp_param.protocol;
5432:irmp.c        ****                         }
5433:irmp.c        **** 
5434:irmp.c        **** #if IRMP_SUPPORT_FDC_PROTOCOL == 1
5435:irmp.c        ****                         if (irmp_param.protocol == IRMP_FDC_PROTOCOL)
5436:irmp.c        ****                         {
5437:irmp.c        ****                             if (irmp_tmp_command & 0x000F)                          // released key
5438:irmp.c        ****                             {
5439:irmp.c        ****                                 irmp_tmp_command = (irmp_tmp_command >> 4) | 0x80;  // yes, set bit
5440:irmp.c        ****                             }
5441:irmp.c        ****                             else
5442:irmp.c        ****                             {
5443:irmp.c        ****                                 irmp_tmp_command >>= 4;                             // no, it's a p
5444:irmp.c        ****                             }
5445:irmp.c        ****                             irmp_tmp_command |= (irmp_tmp_address << 2) & 0x0F00;   // 000000CCCCAA
5446:irmp.c        ****                             irmp_tmp_address &= 0x003F;
5447:irmp.c        ****                         }
5448:irmp.c        **** #endif
5449:irmp.c        **** 
5450:irmp.c        ****                         irmp_address = irmp_tmp_address;                            // store addres
5451:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
5452:irmp.c        ****                         if (irmp_param.protocol == IRMP_NEC_PROTOCOL)
5453:irmp.c        ****                         {
5454:irmp.c        ****                             last_irmp_address = irmp_tmp_address;                   // store as las
5455:irmp.c        ****                         }
5456:irmp.c        **** #endif
5457:irmp.c        **** 
5458:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1
5459:irmp.c        ****                         if (irmp_param.protocol == IRMP_RC5_PROTOCOL)
5460:irmp.c        ****                         {
5461:irmp.c        ****                             irmp_tmp_command |= rc5_cmd_bit6;                       // store bit 6
5462:irmp.c        ****                         }
5463:irmp.c        **** #endif
5464:irmp.c        **** #if IRMP_SUPPORT_S100_PROTOCOL == 1
5465:irmp.c        ****                         if (irmp_param.protocol == IRMP_S100_PROTOCOL)
5466:irmp.c        ****                         {
5467:irmp.c        ****                             irmp_tmp_command |= rc5_cmd_bit6;                       // store bit 6
5468:irmp.c        ****                         }
5469:irmp.c        **** #endif
5470:irmp.c        ****                         irmp_command = irmp_tmp_command;                            // store comman
5471:irmp.c        **** 
5472:irmp.c        **** #if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
5473:irmp.c        ****                         irmp_id = irmp_tmp_id;
5474:irmp.c        **** #endif
5475:irmp.c        ****                     }
5476:irmp.c        ****                 }
5477:irmp.c        **** 
5478:irmp.c        ****                 if (irmp_ir_detected)
5479:irmp.c        ****                 {
5480:irmp.c        ****                     if (last_irmp_command == irmp_tmp_command &&
5481:irmp.c        ****                         last_irmp_address == irmp_tmp_address &&
5482:irmp.c        ****                         key_repetition_len < IRMP_KEY_REPETITION_LEN)
5483:irmp.c        ****                     {
5484:irmp.c        ****                         irmp_flags |= IRMP_FLAG_REPETITION;
5485:irmp.c        ****                     }
5486:irmp.c        **** 
5487:irmp.c        ****                     last_irmp_address = irmp_tmp_address;                           // store as las
5488:irmp.c        ****                     last_irmp_command = irmp_tmp_command;                           // store as las
5489:irmp.c        **** 
5490:irmp.c        ****                     key_repetition_len = 0;
5491:irmp.c        ****                 }
5492:irmp.c        ****                 else
5493:irmp.c        ****                 {
5494:irmp.c        **** #ifdef ANALYZE
5495:irmp.c        ****                     ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
5496:irmp.c        **** #endif // ANALYZE
5497:irmp.c        ****                 }
5498:irmp.c        **** 
5499:irmp.c        ****                 irmp_start_bit_detected = 0;                                        // and wait for
5500:irmp.c        ****                 irmp_tmp_command        = 0;
5501:irmp.c        ****                 irmp_pulse_time         = 0;
5502:irmp.c        ****                 irmp_pause_time         = 0;
5503:irmp.c        **** 
5504:irmp.c        **** #if IRMP_SUPPORT_JVC_PROTOCOL == 1
5505:irmp.c        ****                 if (irmp_protocol == IRMP_JVC_PROTOCOL)                             // the stop bit
5506:irmp.c        ****                 {                                                                   // set pulse ti
5507:irmp.c        ****                     irmp_pulse_time = ((uint_fast8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_TIME));
5508:irmp.c        ****                 }
5509:irmp.c        **** #endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
5510:irmp.c        ****             }
5511:irmp.c        ****         }
5512:irmp.c        ****     }
5513:irmp.c        **** 
5514:irmp.c        **** #if defined(STELLARIS_ARM_CORTEX_M4)
5515:irmp.c        ****     // Clear the timer interrupt
5516:irmp.c        ****     TimerIntClear(TIMER1_BASE, TIMER_TIMA_TIMEOUT);
5517:irmp.c        **** #endif
5518:irmp.c        **** 
5519:irmp.c        **** #if (defined(_CHIBIOS_RT_) || defined(_CHIBIOS_NIL_)) && IRMP_USE_EVENT == 1
5520:irmp.c        ****     if (IRMP_EVENT_THREAD_PTR != NULL && irmp_ir_detected)
5521:irmp.c        ****         chEvtSignalI(IRMP_EVENT_THREAD_PTR,IRMP_EVENT_BIT);
5522:irmp.c        **** #endif
5523:irmp.c        **** 
5524:irmp.c        **** #if IRMP_USE_IDLE_CALL == 1
5525:irmp.c        ****     // check if there is no ongoing transmission or repetition
5526:irmp.c        ****     if (!irmp_start_bit_detected && !irmp_pulse_time
5527:irmp.c        ****         && key_repetition_len > IRMP_KEY_REPETITION_LEN)
5528:irmp.c        ****     {
5529:irmp.c        ****         // no ongoing transmission
5530:irmp.c        ****         // enough time passed since last decoded signal that a repetition won't affect our output
5531:irmp.c        **** 
5532:irmp.c        ****         irmp_idle();
5533:irmp.c        ****     }
5534:irmp.c        **** #endif // IRMP_USE_IDLE_CALL
5535:irmp.c        **** 
5536:irmp.c        ****     return (irmp_ir_detected);
 483               	.LM62:
 484 01a2 8091 0000 		lds r24,irmp_ir_detected
 485               	/* epilogue start */
5537:irmp.c        **** }
 487               	.LM63:
 488 01a6 0895      		ret
 489               	.L24:
3079:irmp.c        ****                 {                                                               // set flags for co
 491               	.LM64:
 492 01a8 9923      		tst r25
 493 01aa 01F0      		breq .L26
3081:irmp.c        ****                     wait_for_start_space    = 1;
 495               	.LM65:
 496 01ac 81E0      		ldi r24,lo8(1)
 497 01ae 8093 0000 		sts irmp_start_bit_detected.1698,r24
3082:irmp.c        ****                     wait_for_space          = 0;
 499               	.LM66:
 500 01b2 8093 0000 		sts wait_for_start_space.1700,r24
3083:irmp.c        ****                     irmp_tmp_command        = 0;
 502               	.LM67:
 503 01b6 1092 0000 		sts wait_for_space.1699,__zero_reg__
3084:irmp.c        ****                     irmp_tmp_address        = 0;
 505               	.LM68:
 506 01ba 1092 0000 		sts irmp_tmp_command+1,__zero_reg__
 507 01be 1092 0000 		sts irmp_tmp_command,__zero_reg__
3085:irmp.c        **** #if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
 509               	.LM69:
 510 01c2 1092 0000 		sts irmp_tmp_address+1,__zero_reg__
 511 01c6 1092 0000 		sts irmp_tmp_address,__zero_reg__
3101:irmp.c        ****                     irmp_pause_time         = 1;                                // 1st pause: set t
 513               	.LM70:
 514 01ca 9FEF      		ldi r25,lo8(-1)
 515 01cc 9093 0000 		sts irmp_bit,r25
3102:irmp.c        **** #if IRMP_SUPPORT_RC5_PROTOCOL == 1 || IRMP_SUPPORT_S100_PROTOCOL == 1
 517               	.LM71:
 518 01d0 8093 0000 		sts irmp_pause_time.1702,r24
 519 01d4 00C0      		rjmp .L25
 520               	.L26:
3109:irmp.c        ****                     {
 522               	.LM72:
 523 01d6 8091 0000 		lds r24,key_repetition_len.1705
 524 01da 9091 0000 		lds r25,key_repetition_len.1705+1
3109:irmp.c        ****                     {
 526               	.LM73:
 527 01de 8F3F      		cpi r24,-1
 528 01e0 9807      		cpc r25,r24
 529 01e2 01F0      		breq .L25
3111:irmp.c        **** 
 531               	.LM74:
 532 01e4 0196      		adiw r24,1
 533 01e6 9093 0000 		sts key_repetition_len.1705+1,r25
 534 01ea 8093 0000 		sts key_repetition_len.1705,r24
 535 01ee 00C0      		rjmp .L25
 536               	.L23:
3135:irmp.c        ****             {                                                                   // ...and are count
 538               	.LM75:
 539 01f0 9091 0000 		lds r25,wait_for_start_space.1700
 540 01f4 9923      		tst r25
 541 01f6 01F4      		brne .+2
 542 01f8 00C0      		rjmp .L27
3137:irmp.c        ****                 {                                                               // yes
 544               	.LM76:
 545 01fa 87FF      		sbrs r24,7
 546 01fc 00C0      		rjmp .L28
3139:irmp.c        **** 
 548               	.LM77:
 549 01fe 8091 0000 		lds r24,irmp_pause_time.1702
 550 0202 8F5F      		subi r24,lo8(-(1))
 551 0204 8093 0000 		sts irmp_pause_time.1702,r24
3145:irmp.c        **** #endif
 553               	.LM78:
 554 0208 8A3E      		cpi r24,lo8(-22)
 555 020a 00F4      		brsh .+2
 556 020c 00C0      		rjmp .L38
 557               	.L39:
3162:irmp.c        ****                         irmp_pulse_time         = 0;
 559               	.LM79:
 560 020e 1092 0000 		sts irmp_start_bit_detected.1698,__zero_reg__
 561               	.L71:
5501:irmp.c        ****                 irmp_pause_time         = 0;
 563               	.LM80:
 564 0212 1092 0000 		sts irmp_pulse_time.1701,__zero_reg__
5502:irmp.c        **** 
 566               	.LM81:
 567 0216 1092 0000 		sts irmp_pause_time.1702,__zero_reg__
 568 021a 00C0      		rjmp .L25
 569               	.L28:
 570               	.LBB2:
3210:irmp.c        ****                         irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_ST
 572               	.LM82:
 573 021c 8091 0000 		lds r24,irmp_pulse_time.1701
 574 0220 8E55      		subi r24,lo8(-(-94))
3210:irmp.c        ****                         irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_ST
 576               	.LM83:
 577 0222 8435      		cpi r24,lo8(84)
 578 0224 00F4      		brsh .L30
3211:irmp.c        ****                     {
 580               	.LM84:
 581 0226 8091 0000 		lds r24,irmp_pause_time.1702
3210:irmp.c        ****                         irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_ST
 583               	.LM85:
 584 022a 92ED      		ldi r25,lo8(-46)
 585 022c 980F      		add r25,r24
3226:irmp.c        **** #endif
 587               	.LM86:
 588 022e 60E0      		ldi r22,lo8(nec_param)
 589 0230 70E0      		ldi r23,hi8(nec_param)
3210:irmp.c        ****                         irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_ST
 591               	.LM87:
 592 0232 9C32      		cpi r25,lo8(44)
 593 0234 00F0      		brlo .L31
3229:irmp.c        ****                              irmp_pause_time >= NEC_REPEAT_START_BIT_PAUSE_LEN_MIN && irmp_pause_ti
 595               	.LM88:
 596 0236 8751      		subi r24,lo8(-(-23))
3251:irmp.c        ****                         }
 598               	.LM89:
 599 0238 60E0      		ldi r22,lo8(nec_rep_param)
 600 023a 70E0      		ldi r23,hi8(nec_rep_param)
3229:irmp.c        ****                              irmp_pause_time >= NEC_REPEAT_START_BIT_PAUSE_LEN_MIN && irmp_pause_ti
 602               	.LM90:
 603 023c 8731      		cpi r24,lo8(23)
 604 023e 00F0      		brlo .L31
 605               	.L30:
3942:irmp.c        ****                     }
 607               	.LM91:
 608 0240 1092 0000 		sts irmp_start_bit_detected.1698,__zero_reg__
3170:irmp.c        **** 
 610               	.LM92:
 611 0244 70E0      		ldi r23,0
 612 0246 60E0      		ldi r22,0
 613               	.L31:
3945:irmp.c        ****                     {
 615               	.LM93:
 616 0248 8091 0000 		lds r24,irmp_start_bit_detected.1698
 617 024c 8823      		tst r24
 618 024e 01F0      		breq .L32
3947:irmp.c        **** 
 620               	.LM94:
 621 0250 41E1      		ldi r20,lo8(17)
 622 0252 50E0      		ldi r21,0
 623 0254 80E0      		ldi r24,lo8(irmp_param)
 624 0256 90E0      		ldi r25,hi8(irmp_param)
 625 0258 0E94 0000 		call memcpy_P
 626               	.L32:
4021:irmp.c        **** 
 628               	.LM95:
 629 025c 1092 0000 		sts irmp_bit,__zero_reg__
4116:irmp.c        ****                     irmp_pause_time = 0;
 631               	.LM96:
 632 0260 81E0      		ldi r24,lo8(1)
 633 0262 8093 0000 		sts irmp_pulse_time.1701,r24
4117:irmp.c        ****                     wait_for_start_space = 0;
 635               	.LM97:
 636 0266 1092 0000 		sts irmp_pause_time.1702,__zero_reg__
4118:irmp.c        ****                 }
 638               	.LM98:
 639 026a 1092 0000 		sts wait_for_start_space.1700,__zero_reg__
 640               	.L33:
 641               	.LBE2:
5175:irmp.c        ****             {
 643               	.LM99:
 644 026e 8091 0000 		lds r24,irmp_start_bit_detected.1698
 645 0272 8823      		tst r24
 646 0274 01F4      		brne .+2
 647 0276 00C0      		rjmp .L25
 648 0278 00C0      		rjmp .L38
 649               	.L27:
4121:irmp.c        ****             {                                                                   // counting the tim
 651               	.LM100:
 652 027a 9091 0000 		lds r25,wait_for_space.1699
 653 027e 9923      		tst r25
 654 0280 01F4      		brne .+2
 655 0282 00C0      		rjmp .L34
 656               	.LBB3:
4125:irmp.c        ****                 {                                                               // yes...
 658               	.LM101:
 659 0284 87FF      		sbrs r24,7
 660 0286 00C0      		rjmp .L35
4127:irmp.c        ****                     {
 662               	.LM102:
 663 0288 2091 0000 		lds r18,irmp_param+13
4127:irmp.c        ****                     {
 665               	.LM103:
 666 028c 8091 0000 		lds r24,irmp_bit
4127:irmp.c        ****                     {
 668               	.LM104:
 669 0290 2813      		cpse r18,r24
 670 0292 00C0      		rjmp .L36
4127:irmp.c        ****                     {
 672               	.LM105:
 673 0294 9091 0000 		lds r25,irmp_param+14
 674 0298 9130      		cpi r25,lo8(1)
 675 029a 01F0      		breq .+2
 676 029c 00C0      		rjmp .L36
4136:irmp.c        ****                         {
 678               	.LM106:
 679 029e 8091 0000 		lds r24,irmp_pulse_time.1701
4129:irmp.c        **** #if IRMP_SUPPORT_MANCHESTER == 1
 681               	.LM107:
 682 02a2 9091 0000 		lds r25,irmp_param+5
 683 02a6 8917      		cp r24,r25
 684 02a8 00F4      		brsh .+2
 685 02aa 00C0      		rjmp .L39
4136:irmp.c        ****                         {
 687               	.LM108:
 688 02ac 9091 0000 		lds r25,irmp_param+6
 689 02b0 9817      		cp r25,r24
 690 02b2 00F4      		brsh .+2
 691 02b4 00C0      		rjmp .L39
4144:irmp.c        ****                         }
 693               	.LM109:
 694 02b6 1092 0000 		sts irmp_param+14,__zero_reg__
 695               	.L38:
 696               	.LBE3:
5175:irmp.c        ****             {
 698               	.LM110:
 699 02ba 9091 0000 		lds r25,irmp_bit
5175:irmp.c        ****             {
 701               	.LM111:
 702 02be 8091 0000 		lds r24,irmp_param+13
 703 02c2 8913      		cpse r24,r25
 704 02c4 00C0      		rjmp .L25
5175:irmp.c        ****             {
 706               	.LM112:
 707 02c6 8091 0000 		lds r24,irmp_param+14
 708 02ca 8111      		cpse r24,__zero_reg__
 709 02cc 00C0      		rjmp .L25
5177:irmp.c        ****                 {
 711               	.LM113:
 712 02ce 4091 0000 		lds r20,last_irmp_command.1704
 713 02d2 5091 0000 		lds r21,last_irmp_command.1704+1
5177:irmp.c        ****                 {
 715               	.LM114:
 716 02d6 2091 0000 		lds r18,irmp_tmp_command
 717 02da 3091 0000 		lds r19,irmp_tmp_command+1
 718 02de 4217      		cp r20,r18
 719 02e0 5307      		cpc r21,r19
 720 02e2 01F0      		breq .+2
 721 02e4 00C0      		rjmp .L47
5177:irmp.c        ****                 {
 723               	.LM115:
 724 02e6 2091 0000 		lds r18,key_repetition_len.1705
 725 02ea 3091 0000 		lds r19,key_repetition_len.1705+1
 726 02ee 203B      		cpi r18,-80
 727 02f0 3440      		sbci r19,4
 728 02f2 00F0      		brlo .+2
 729 02f4 00C0      		rjmp .L47
5179:irmp.c        ****                 }
 731               	.LM116:
 732 02f6 8091 0000 		lds r24,repetition_frame_number.1706
 733 02fa 8F5F      		subi r24,lo8(-(1))
 734 02fc 8093 0000 		sts repetition_frame_number.1706,r24
 735               	.L48:
5268:irmp.c        **** 
 737               	.LM117:
 738 0300 81E0      		ldi r24,lo8(1)
 739 0302 8093 0000 		sts irmp_ir_detected,r24
5329:irmp.c        ****                         {
 741               	.LM118:
 742 0306 2091 0000 		lds r18,irmp_param
5329:irmp.c        ****                         {
 744               	.LM119:
 745 030a 2230      		cpi r18,lo8(2)
 746 030c 01F4      		brne .L49
5329:irmp.c        ****                         {
 748               	.LM120:
 749 030e 9111      		cpse r25,__zero_reg__
 750 0310 00C0      		rjmp .L49
5331:irmp.c        ****                             {
 752               	.LM121:
 753 0312 8091 0000 		lds r24,key_repetition_len.1705
 754 0316 9091 0000 		lds r25,key_repetition_len.1705+1
 755 031a 8830      		cpi r24,8
 756 031c 9740      		sbci r25,7
 757 031e 00F0      		brlo .+2
 758 0320 00C0      		rjmp .L50
5337:irmp.c        ****                                 irmp_tmp_command = last_irmp_command;                   // command 
 760               	.LM122:
 761 0322 8091 0000 		lds r24,last_irmp_address.1703
 762 0326 9091 0000 		lds r25,last_irmp_address.1703+1
 763 032a 9093 0000 		sts irmp_tmp_address+1,r25
 764 032e 8093 0000 		sts irmp_tmp_address,r24
5338:irmp.c        ****                                 irmp_flags |= IRMP_FLAG_REPETITION;
 766               	.LM123:
 767 0332 5093 0000 		sts irmp_tmp_command+1,r21
 768 0336 4093 0000 		sts irmp_tmp_command,r20
5339:irmp.c        ****                                 key_repetition_len = 0;
 770               	.LM124:
 771 033a 8091 0000 		lds r24,irmp_flags
 772 033e 8160      		ori r24,lo8(1)
 773 0340 8093 0000 		sts irmp_flags,r24
5340:irmp.c        ****                             }
 775               	.LM125:
 776 0344 1092 0000 		sts key_repetition_len.1705+1,__zero_reg__
 777 0348 1092 0000 		sts key_repetition_len.1705,__zero_reg__
 778               	.L49:
5431:irmp.c        ****                         }
 780               	.LM126:
 781 034c 2093 0000 		sts irmp_protocol,r18
5450:irmp.c        **** #if IRMP_SUPPORT_NEC_PROTOCOL == 1
 783               	.LM127:
 784 0350 8091 0000 		lds r24,irmp_tmp_address
 785 0354 9091 0000 		lds r25,irmp_tmp_address+1
 786 0358 9093 0000 		sts irmp_address+1,r25
 787 035c 8093 0000 		sts irmp_address,r24
5452:irmp.c        ****                         {
 789               	.LM128:
 790 0360 2230      		cpi r18,lo8(2)
 791 0362 01F4      		brne .L51
5454:irmp.c        ****                         }
 793               	.LM129:
 794 0364 9093 0000 		sts last_irmp_address.1703+1,r25
 795 0368 8093 0000 		sts last_irmp_address.1703,r24
 796               	.L51:
5470:irmp.c        **** 
 798               	.LM130:
 799 036c 2091 0000 		lds r18,irmp_tmp_command
 800 0370 3091 0000 		lds r19,irmp_tmp_command+1
 801 0374 3093 0000 		sts irmp_command+1,r19
 802 0378 2093 0000 		sts irmp_command,r18
5478:irmp.c        ****                 {
 804               	.LM131:
 805 037c 6091 0000 		lds r22,irmp_ir_detected
5478:irmp.c        ****                 {
 807               	.LM132:
 808 0380 6623      		tst r22
 809 0382 01F0      		breq .L52
5480:irmp.c        ****                         last_irmp_address == irmp_tmp_address &&
 811               	.LM133:
 812 0384 4217      		cp r20,r18
 813 0386 5307      		cpc r21,r19
 814 0388 01F4      		brne .L53
5480:irmp.c        ****                         last_irmp_address == irmp_tmp_address &&
 816               	.LM134:
 817 038a 4091 0000 		lds r20,last_irmp_address.1703
 818 038e 5091 0000 		lds r21,last_irmp_address.1703+1
 819 0392 8417      		cp r24,r20
 820 0394 9507      		cpc r25,r21
 821 0396 01F4      		brne .L53
5481:irmp.c        ****                         key_repetition_len < IRMP_KEY_REPETITION_LEN)
 823               	.LM135:
 824 0398 4091 0000 		lds r20,key_repetition_len.1705
 825 039c 5091 0000 		lds r21,key_repetition_len.1705+1
 826 03a0 4A3C      		cpi r20,-54
 827 03a2 5840      		sbci r21,8
 828 03a4 00F4      		brsh .L53
5484:irmp.c        ****                     }
 830               	.LM136:
 831 03a6 4091 0000 		lds r20,irmp_flags
 832 03aa 4160      		ori r20,lo8(1)
 833 03ac 4093 0000 		sts irmp_flags,r20
 834               	.L53:
5487:irmp.c        ****                     last_irmp_command = irmp_tmp_command;                           // store as las
 836               	.LM137:
 837 03b0 9093 0000 		sts last_irmp_address.1703+1,r25
 838 03b4 8093 0000 		sts last_irmp_address.1703,r24
5488:irmp.c        **** 
 840               	.LM138:
 841 03b8 3093 0000 		sts last_irmp_command.1704+1,r19
 842 03bc 2093 0000 		sts last_irmp_command.1704,r18
5490:irmp.c        ****                 }
 844               	.LM139:
 845 03c0 1092 0000 		sts key_repetition_len.1705+1,__zero_reg__
 846 03c4 1092 0000 		sts key_repetition_len.1705,__zero_reg__
 847               	.L52:
5499:irmp.c        ****                 irmp_tmp_command        = 0;
 849               	.LM140:
 850 03c8 1092 0000 		sts irmp_start_bit_detected.1698,__zero_reg__
5500:irmp.c        ****                 irmp_pulse_time         = 0;
 852               	.LM141:
 853 03cc 1092 0000 		sts irmp_tmp_command+1,__zero_reg__
 854 03d0 1092 0000 		sts irmp_tmp_command,__zero_reg__
 855 03d4 00C0      		rjmp .L71
 856               	.L36:
 857               	.LBB4:
4159:irmp.c        **** 
 859               	.LM142:
 860 03d6 9091 0000 		lds r25,irmp_pause_time.1702
 861 03da 9F5F      		subi r25,lo8(-(1))
 862 03dc 9093 0000 		sts irmp_pause_time.1702,r25
4320:irmp.c        ****                         {                                                       // yes...
 864               	.LM143:
 865 03e0 9A3E      		cpi r25,lo8(-22)
 866 03e2 00F4      		brsh .+2
 867 03e4 00C0      		rjmp .L38
4322:irmp.c        ****                             {
 869               	.LM144:
 870 03e6 2150      		subi r18,1
 871 03e8 330B      		sbc r19,r19
4322:irmp.c        ****                             {
 873               	.LM145:
 874 03ea 8217      		cp r24,r18
 875 03ec 1306      		cpc __zero_reg__,r19
 876 03ee 01F4      		brne .L40
4322:irmp.c        ****                             {
 878               	.LM146:
 879 03f0 9091 0000 		lds r25,irmp_param+14
 880 03f4 9111      		cpse r25,__zero_reg__
 881 03f6 00C0      		rjmp .L40
4324:irmp.c        ****                             }
 883               	.LM147:
 884 03f8 8F5F      		subi r24,lo8(-(1))
 885 03fa 8093 0000 		sts irmp_bit,r24
 886 03fe 00C0      		rjmp .L38
 887               	.L40:
4327:irmp.c        ****                             {                                                               // it w
 889               	.LM148:
 890 0400 9091 0000 		lds r25,irmp_param
4327:irmp.c        ****                             {                                                               // it w
 892               	.LM149:
 893 0404 9230      		cpi r25,lo8(2)
 894 0406 01F0      		breq .L41
4327:irmp.c        ****                             {                                                               // it w
 896               	.LM150:
 897 0408 9C31      		cpi r25,lo8(28)
 898 040a 01F0      		breq .+2
 899 040c 00C0      		rjmp .L39
 900               	.L41:
4327:irmp.c        ****                             {                                                               // it w
 902               	.LM151:
 903 040e 8111      		cpse r24,__zero_reg__
 904 0410 00C0      		rjmp .L39
4332:irmp.c        ****                                 {
 906               	.LM152:
 907 0412 8091 0000 		lds r24,key_repetition_len.1705
 908 0416 9091 0000 		lds r25,key_repetition_len.1705+1
 909 041a 8830      		cpi r24,8
 910 041c 9740      		sbci r25,7
 911 041e 00F4      		brsh .L42
4334:irmp.c        ****                                     irmp_param.protocol     = IRMP_NEC_PROTOCOL;            // swit
 913               	.LM153:
 914 0420 81E0      		ldi r24,lo8(1)
 915 0422 8093 0000 		sts irmp_param+14,r24
4335:irmp.c        ****                                     irmp_param.complete_len = irmp_bit;                     // patc
 917               	.LM154:
 918 0426 82E0      		ldi r24,lo8(2)
 919 0428 8093 0000 		sts irmp_param,r24
4336:irmp.c        ****                                     irmp_tmp_address = last_irmp_address;                   // addr
 921               	.LM155:
 922 042c 1092 0000 		sts irmp_param+13,__zero_reg__
4337:irmp.c        ****                                     irmp_tmp_command = last_irmp_command;                   // comm
 924               	.LM156:
 925 0430 8091 0000 		lds r24,last_irmp_address.1703
 926 0434 9091 0000 		lds r25,last_irmp_address.1703+1
 927 0438 9093 0000 		sts irmp_tmp_address+1,r25
 928 043c 8093 0000 		sts irmp_tmp_address,r24
4338:irmp.c        ****                                     irmp_flags |= IRMP_FLAG_REPETITION;
 930               	.LM157:
 931 0440 8091 0000 		lds r24,last_irmp_command.1704
 932 0444 9091 0000 		lds r25,last_irmp_command.1704+1
 933 0448 9093 0000 		sts irmp_tmp_command+1,r25
 934 044c 8093 0000 		sts irmp_tmp_command,r24
4339:irmp.c        ****                                     key_repetition_len = 0;
 936               	.LM158:
 937 0450 8091 0000 		lds r24,irmp_flags
 938 0454 8160      		ori r24,lo8(1)
 939 0456 8093 0000 		sts irmp_flags,r24
4340:irmp.c        ****                                 }
 941               	.LM159:
 942 045a 1092 0000 		sts key_repetition_len.1705+1,__zero_reg__
 943 045e 1092 0000 		sts key_repetition_len.1705,__zero_reg__
 944 0462 00C0      		rjmp .L38
 945               	.L42:
4348:irmp.c        ****                                 }
 947               	.LM160:
 948 0464 1092 0000 		sts irmp_ir_detected,__zero_reg__
 949 0468 00C0      		rjmp .L38
 950               	.L35:
5072:irmp.c        ****                         irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_pa
 952               	.LM161:
 953 046a 8091 0000 		lds r24,irmp_pulse_time.1701
5072:irmp.c        ****                         irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_pa
 955               	.LM162:
 956 046e 9091 0000 		lds r25,irmp_param+1
 957 0472 8917      		cp r24,r25
 958 0474 00F0      		brlo .L43
5072:irmp.c        ****                         irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_pa
 960               	.LM163:
 961 0476 9091 0000 		lds r25,irmp_param+2
 962 047a 9817      		cp r25,r24
 963 047c 00F0      		brlo .L43
5073:irmp.c        ****                     {                                                               // pulse & paus
 965               	.LM164:
 966 047e 9091 0000 		lds r25,irmp_pause_time.1702
5072:irmp.c        ****                         irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_pa
 968               	.LM165:
 969 0482 2091 0000 		lds r18,irmp_param+3
 970 0486 9217      		cp r25,r18
 971 0488 00F0      		brlo .L43
5073:irmp.c        ****                     {                                                               // pulse & paus
 973               	.LM166:
 974 048a 2091 0000 		lds r18,irmp_param+4
 975 048e 2917      		cp r18,r25
 976 0490 00F0      		brlo .L43
5079:irmp.c        ****                         wait_for_space = 0;
 978               	.LM167:
 979 0492 81E0      		ldi r24,lo8(1)
 980               	.L70:
5089:irmp.c        ****                         wait_for_space = 0;
 982               	.LM168:
 983 0494 0E94 0000 		call irmp_store_bit
5090:irmp.c        ****                     }
 985               	.LM169:
 986 0498 1092 0000 		sts wait_for_space.1699,__zero_reg__
 987               	.L44:
5133:irmp.c        ****                 }
 989               	.LM170:
 990 049c 81E0      		ldi r24,lo8(1)
 991 049e 8093 0000 		sts irmp_pulse_time.1701,r24
 992 04a2 00C0      		rjmp .L33
 993               	.L43:
5082:irmp.c        ****                              irmp_pause_time >= irmp_param.pause_0_len_min && irmp_pause_time <= ir
 995               	.LM171:
 996 04a4 9091 0000 		lds r25,irmp_param+5
 997 04a8 8917      		cp r24,r25
 998 04aa 00F0      		brlo .L45
5082:irmp.c        ****                              irmp_pause_time >= irmp_param.pause_0_len_min && irmp_pause_time <= ir
 1000               	.LM172:
 1001 04ac 9091 0000 		lds r25,irmp_param+6
 1002 04b0 9817      		cp r25,r24
 1003 04b2 00F0      		brlo .L45
5083:irmp.c        ****                     {                                                               // pulse & paus
 1005               	.LM173:
 1006 04b4 8091 0000 		lds r24,irmp_pause_time.1702
5082:irmp.c        ****                              irmp_pause_time >= irmp_param.pause_0_len_min && irmp_pause_time <= ir
 1008               	.LM174:
 1009 04b8 9091 0000 		lds r25,irmp_param+7
 1010 04bc 8917      		cp r24,r25
 1011 04be 00F0      		brlo .L45
5083:irmp.c        ****                     {                                                               // pulse & paus
 1013               	.LM175:
 1014 04c0 9091 0000 		lds r25,irmp_param+8
 1015 04c4 9817      		cp r25,r24
 1016 04c6 00F0      		brlo .L45
5089:irmp.c        ****                         wait_for_space = 0;
 1018               	.LM176:
 1019 04c8 80E0      		ldi r24,0
 1020 04ca 00C0      		rjmp .L70
 1021               	.L45:
5129:irmp.c        ****                         irmp_pause_time         = 0;
 1023               	.LM177:
 1024 04cc 1092 0000 		sts irmp_start_bit_detected.1698,__zero_reg__
5130:irmp.c        ****                     }
 1026               	.LM178:
 1027 04d0 1092 0000 		sts irmp_pause_time.1702,__zero_reg__
 1028 04d4 00C0      		rjmp .L44
 1029               	.L34:
 1030               	.LBE4:
5138:irmp.c        ****                 {                                                                   // yes...
 1032               	.LM179:
 1033 04d6 87FD      		sbrc r24,7
 1034 04d8 00C0      		rjmp .L46
5140:irmp.c        ****                 }
 1036               	.LM180:
 1037 04da 8091 0000 		lds r24,irmp_pulse_time.1701
 1038 04de 8F5F      		subi r24,lo8(-(1))
 1039 04e0 8093 0000 		sts irmp_pulse_time.1701,r24
 1040 04e4 00C0      		rjmp .L38
 1041               	.L46:
5144:irmp.c        ****                     irmp_pause_time = 1;                                            // set pause co
 1043               	.LM181:
 1044 04e6 81E0      		ldi r24,lo8(1)
 1045 04e8 8093 0000 		sts wait_for_space.1699,r24
5145:irmp.c        **** 
 1047               	.LM182:
 1048 04ec 8093 0000 		sts irmp_pause_time.1702,r24
 1049 04f0 00C0      		rjmp .L38
 1050               	.L47:
5183:irmp.c        ****                 }
 1052               	.LM183:
 1053 04f2 1092 0000 		sts repetition_frame_number.1706,__zero_reg__
 1054 04f6 00C0      		rjmp .L48
 1055               	.L50:
5348:irmp.c        ****                             }
 1057               	.LM184:
 1058 04f8 1092 0000 		sts irmp_ir_detected,__zero_reg__
 1059 04fc 00C0      		rjmp .L49
 1075               	.Lscope4:
 1077               		.stabd	78,0,0
 1078               		.local	repetition_frame_number.1706
 1079               		.comm	repetition_frame_number.1706,1,1
 1081               		.data
 1084               	last_irmp_command.1704:
 1085 0000 FFFF      		.word	-1
 1089               	last_irmp_address.1703:
 1090 0002 FFFF      		.word	-1
 1092               		.local	key_repetition_len.1705
 1093               		.comm	key_repetition_len.1705,2,1
 1095               		.local	irmp_pause_time.1702
 1096               		.comm	irmp_pause_time.1702,1,1
 1098               		.local	wait_for_space.1699
 1099               		.comm	wait_for_space.1699,1,1
 1101               		.local	wait_for_start_space.1700
 1102               		.comm	wait_for_start_space.1700,1,1
 1104               		.local	irmp_pulse_time.1701
 1105               		.comm	irmp_pulse_time.1701,1,1
 1107               		.local	irmp_start_bit_detected.1698
 1108               		.comm	irmp_start_bit_detected.1698,1,1
 1110               		.local	irmp_tmp_command
 1111               		.comm	irmp_tmp_command,2,1
 1113               		.local	irmp_tmp_address
 1114               		.comm	irmp_tmp_address,2,1
 1116               		.local	irmp_flags
 1117               		.comm	irmp_flags,1,1
 1119               		.local	irmp_id
 1120               		.comm	irmp_id,2,1
 1122               		.local	irmp_command
 1123               		.comm	irmp_command,2,1
 1125               		.local	irmp_address
 1126               		.comm	irmp_address,2,1
 1128               		.local	irmp_protocol
 1129               		.comm	irmp_protocol,1,1
 1131               		.local	irmp_ir_detected
 1132               		.comm	irmp_ir_detected,1,1
 1134               		.local	irmp_param
 1135               		.comm	irmp_param,17,1
 1137               		.local	irmp_bit
 1138               		.comm	irmp_bit,1,1
 1140               		.section	.progmem.data,"a",@progbits
 1143               	nec_rep_param:
 1144 0000 02        		.byte	2
 1145 0001 05        		.byte	5
 1146 0002 0C        		.byte	12
 1147 0003 11        		.byte	17
 1148 0004 22        		.byte	34
 1149 0005 05        		.byte	5
 1150 0006 0C        		.byte	12
 1151 0007 05        		.byte	5
 1152 0008 0C        		.byte	12
 1153 0009 00        		.byte	0
 1154 000a 00        		.byte	0
 1155 000b 00        		.byte	0
 1156 000c 00        		.byte	0
 1157 000d 00        		.byte	0
 1158 000e 01        		.byte	1
 1159 000f 01        		.byte	1
 1160 0010 00        		.byte	0
 1164               	nec_param:
 1165 0011 02        		.byte	2
 1166 0012 05        		.byte	5
 1167 0013 0C        		.byte	12
 1168 0014 11        		.byte	17
 1169 0015 22        		.byte	34
 1170 0016 05        		.byte	5
 1171 0017 0C        		.byte	12
 1172 0018 05        		.byte	5
 1173 0019 0C        		.byte	12
 1174 001a 00        		.byte	0
 1175 001b 10        		.byte	16
 1176 001c 10        		.byte	16
 1177 001d 20        		.byte	32
 1178 001e 20        		.byte	32
 1179 001f 01        		.byte	1
 1180 0020 01        		.byte	1
 1181 0021 00        		.byte	0
 1183               		.text
 1185               	.Letext0:
 1186               		.ident	"GCC: (GNU) 9.2.0"
 1187               	.global __do_copy_data
 1188               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 irmp.c
     /tmp/ccevfmQy.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccevfmQy.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccevfmQy.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccevfmQy.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccevfmQy.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccevfmQy.s:129    .text:0000000000000000 irmp_store_bit
     /tmp/ccevfmQy.s:1132   .bss:0000000000000015 irmp_param
     /tmp/ccevfmQy.s:1135   .bss:0000000000000026 irmp_bit
     /tmp/ccevfmQy.s:1111   .bss:000000000000000a irmp_tmp_address
     /tmp/ccevfmQy.s:1108   .bss:0000000000000008 irmp_tmp_command
     /tmp/ccevfmQy.s:256    .text:000000000000009c irmp_init
     /tmp/ccevfmQy.s:283    .text:00000000000000a2 irmp_get_data
     /tmp/ccevfmQy.s:1129   .bss:0000000000000014 irmp_ir_detected
     /tmp/ccevfmQy.s:1126   .bss:0000000000000013 irmp_protocol
     /tmp/ccevfmQy.s:1123   .bss:0000000000000011 irmp_address
     /tmp/ccevfmQy.s:1120   .bss:000000000000000f irmp_command
     /tmp/ccevfmQy.s:1114   .bss:000000000000000c irmp_flags
     /tmp/ccevfmQy.s:448    .text:0000000000000182 irmp_ISR
     /tmp/ccevfmQy.s:1105   .bss:0000000000000007 irmp_start_bit_detected.1698
     /tmp/ccevfmQy.s:1102   .bss:0000000000000006 irmp_pulse_time.1701
     /tmp/ccevfmQy.s:1099   .bss:0000000000000005 wait_for_start_space.1700
     /tmp/ccevfmQy.s:1096   .bss:0000000000000004 wait_for_space.1699
     /tmp/ccevfmQy.s:1093   .bss:0000000000000003 irmp_pause_time.1702
     /tmp/ccevfmQy.s:1079   .bss:0000000000000001 key_repetition_len.1705
     /tmp/ccevfmQy.s:1164   .progmem.data:0000000000000011 nec_param
     /tmp/ccevfmQy.s:1143   .progmem.data:0000000000000000 nec_rep_param
     /tmp/ccevfmQy.s:1084   .data:0000000000000000 last_irmp_command.1704
                             .bss:0000000000000000 repetition_frame_number.1706
     /tmp/ccevfmQy.s:1089   .data:0000000000000002 last_irmp_address.1703
     /tmp/ccevfmQy.s:1117   .bss:000000000000000d irmp_id

UNDEFINED SYMBOLS
memcpy_P
__do_copy_data
__do_clear_bss
